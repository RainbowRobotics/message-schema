// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_DEPLOY_DEPLOY_H_
#define FLATBUFFERS_GENERATED_DEPLOY_DEPLOY_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

namespace deploy {

struct Response_Deploy_Upload;
struct Response_Deploy_UploadBuilder;
struct Response_Deploy_UploadT;

struct Response_Deploy_Progress;
struct Response_Deploy_ProgressBuilder;
struct Response_Deploy_ProgressT;

struct Response_Deploy_UploadT : public ::flatbuffers::NativeTable {
  typedef Response_Deploy_Upload TableType;
  std::string tag{};
  std::string file_name{};
  std::string sha256{};
  std::string path{};
};

struct Response_Deploy_Upload FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Response_Deploy_UploadT NativeTableType;
  typedef Response_Deploy_UploadBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TAG = 4,
    VT_FILE_NAME = 6,
    VT_SHA256 = 8,
    VT_PATH = 10
  };
  const ::flatbuffers::String *tag() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAG);
  }
  const ::flatbuffers::String *file_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FILE_NAME);
  }
  const ::flatbuffers::String *sha256() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SHA256);
  }
  const ::flatbuffers::String *path() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PATH);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TAG) &&
           verifier.VerifyString(tag()) &&
           VerifyOffset(verifier, VT_FILE_NAME) &&
           verifier.VerifyString(file_name()) &&
           VerifyOffset(verifier, VT_SHA256) &&
           verifier.VerifyString(sha256()) &&
           VerifyOffset(verifier, VT_PATH) &&
           verifier.VerifyString(path()) &&
           verifier.EndTable();
  }
  Response_Deploy_UploadT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Response_Deploy_UploadT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Response_Deploy_Upload> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Response_Deploy_UploadT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Response_Deploy_UploadBuilder {
  typedef Response_Deploy_Upload Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_tag(::flatbuffers::Offset<::flatbuffers::String> tag) {
    fbb_.AddOffset(Response_Deploy_Upload::VT_TAG, tag);
  }
  void add_file_name(::flatbuffers::Offset<::flatbuffers::String> file_name) {
    fbb_.AddOffset(Response_Deploy_Upload::VT_FILE_NAME, file_name);
  }
  void add_sha256(::flatbuffers::Offset<::flatbuffers::String> sha256) {
    fbb_.AddOffset(Response_Deploy_Upload::VT_SHA256, sha256);
  }
  void add_path(::flatbuffers::Offset<::flatbuffers::String> path) {
    fbb_.AddOffset(Response_Deploy_Upload::VT_PATH, path);
  }
  explicit Response_Deploy_UploadBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Response_Deploy_Upload> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Response_Deploy_Upload>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Response_Deploy_Upload> CreateResponse_Deploy_Upload(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> tag = 0,
    ::flatbuffers::Offset<::flatbuffers::String> file_name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> sha256 = 0,
    ::flatbuffers::Offset<::flatbuffers::String> path = 0) {
  Response_Deploy_UploadBuilder builder_(_fbb);
  builder_.add_path(path);
  builder_.add_sha256(sha256);
  builder_.add_file_name(file_name);
  builder_.add_tag(tag);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Response_Deploy_Upload> CreateResponse_Deploy_UploadDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *tag = nullptr,
    const char *file_name = nullptr,
    const char *sha256 = nullptr,
    const char *path = nullptr) {
  auto tag__ = tag ? _fbb.CreateString(tag) : 0;
  auto file_name__ = file_name ? _fbb.CreateString(file_name) : 0;
  auto sha256__ = sha256 ? _fbb.CreateString(sha256) : 0;
  auto path__ = path ? _fbb.CreateString(path) : 0;
  return deploy::CreateResponse_Deploy_Upload(
      _fbb,
      tag__,
      file_name__,
      sha256__,
      path__);
}

::flatbuffers::Offset<Response_Deploy_Upload> CreateResponse_Deploy_Upload(::flatbuffers::FlatBufferBuilder &_fbb, const Response_Deploy_UploadT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Response_Deploy_ProgressT : public ::flatbuffers::NativeTable {
  typedef Response_Deploy_Progress TableType;
  std::string sw_name{};
  std::string mode{};
  std::string tag{};
  int32_t percentage = 0;
  std::string service_name{};
  std::string result{};
};

struct Response_Deploy_Progress FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Response_Deploy_ProgressT NativeTableType;
  typedef Response_Deploy_ProgressBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SW_NAME = 4,
    VT_MODE = 6,
    VT_TAG = 8,
    VT_PERCENTAGE = 10,
    VT_SERVICE_NAME = 12,
    VT_RESULT = 14
  };
  const ::flatbuffers::String *sw_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SW_NAME);
  }
  const ::flatbuffers::String *mode() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MODE);
  }
  const ::flatbuffers::String *tag() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAG);
  }
  int32_t percentage() const {
    return GetField<int32_t>(VT_PERCENTAGE, 0);
  }
  const ::flatbuffers::String *service_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SERVICE_NAME);
  }
  const ::flatbuffers::String *result() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RESULT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SW_NAME) &&
           verifier.VerifyString(sw_name()) &&
           VerifyOffset(verifier, VT_MODE) &&
           verifier.VerifyString(mode()) &&
           VerifyOffset(verifier, VT_TAG) &&
           verifier.VerifyString(tag()) &&
           VerifyField<int32_t>(verifier, VT_PERCENTAGE, 4) &&
           VerifyOffset(verifier, VT_SERVICE_NAME) &&
           verifier.VerifyString(service_name()) &&
           VerifyOffset(verifier, VT_RESULT) &&
           verifier.VerifyString(result()) &&
           verifier.EndTable();
  }
  Response_Deploy_ProgressT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Response_Deploy_ProgressT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Response_Deploy_Progress> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Response_Deploy_ProgressT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Response_Deploy_ProgressBuilder {
  typedef Response_Deploy_Progress Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_sw_name(::flatbuffers::Offset<::flatbuffers::String> sw_name) {
    fbb_.AddOffset(Response_Deploy_Progress::VT_SW_NAME, sw_name);
  }
  void add_mode(::flatbuffers::Offset<::flatbuffers::String> mode) {
    fbb_.AddOffset(Response_Deploy_Progress::VT_MODE, mode);
  }
  void add_tag(::flatbuffers::Offset<::flatbuffers::String> tag) {
    fbb_.AddOffset(Response_Deploy_Progress::VT_TAG, tag);
  }
  void add_percentage(int32_t percentage) {
    fbb_.AddElement<int32_t>(Response_Deploy_Progress::VT_PERCENTAGE, percentage, 0);
  }
  void add_service_name(::flatbuffers::Offset<::flatbuffers::String> service_name) {
    fbb_.AddOffset(Response_Deploy_Progress::VT_SERVICE_NAME, service_name);
  }
  void add_result(::flatbuffers::Offset<::flatbuffers::String> result) {
    fbb_.AddOffset(Response_Deploy_Progress::VT_RESULT, result);
  }
  explicit Response_Deploy_ProgressBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Response_Deploy_Progress> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Response_Deploy_Progress>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Response_Deploy_Progress> CreateResponse_Deploy_Progress(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> sw_name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> mode = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tag = 0,
    int32_t percentage = 0,
    ::flatbuffers::Offset<::flatbuffers::String> service_name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> result = 0) {
  Response_Deploy_ProgressBuilder builder_(_fbb);
  builder_.add_result(result);
  builder_.add_service_name(service_name);
  builder_.add_percentage(percentage);
  builder_.add_tag(tag);
  builder_.add_mode(mode);
  builder_.add_sw_name(sw_name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Response_Deploy_Progress> CreateResponse_Deploy_ProgressDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *sw_name = nullptr,
    const char *mode = nullptr,
    const char *tag = nullptr,
    int32_t percentage = 0,
    const char *service_name = nullptr,
    const char *result = nullptr) {
  auto sw_name__ = sw_name ? _fbb.CreateString(sw_name) : 0;
  auto mode__ = mode ? _fbb.CreateString(mode) : 0;
  auto tag__ = tag ? _fbb.CreateString(tag) : 0;
  auto service_name__ = service_name ? _fbb.CreateString(service_name) : 0;
  auto result__ = result ? _fbb.CreateString(result) : 0;
  return deploy::CreateResponse_Deploy_Progress(
      _fbb,
      sw_name__,
      mode__,
      tag__,
      percentage,
      service_name__,
      result__);
}

::flatbuffers::Offset<Response_Deploy_Progress> CreateResponse_Deploy_Progress(::flatbuffers::FlatBufferBuilder &_fbb, const Response_Deploy_ProgressT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline Response_Deploy_UploadT *Response_Deploy_Upload::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Response_Deploy_UploadT>(new Response_Deploy_UploadT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Response_Deploy_Upload::UnPackTo(Response_Deploy_UploadT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = tag(); if (_e) _o->tag = _e->str(); }
  { auto _e = file_name(); if (_e) _o->file_name = _e->str(); }
  { auto _e = sha256(); if (_e) _o->sha256 = _e->str(); }
  { auto _e = path(); if (_e) _o->path = _e->str(); }
}

inline ::flatbuffers::Offset<Response_Deploy_Upload> Response_Deploy_Upload::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Response_Deploy_UploadT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateResponse_Deploy_Upload(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Response_Deploy_Upload> CreateResponse_Deploy_Upload(::flatbuffers::FlatBufferBuilder &_fbb, const Response_Deploy_UploadT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const Response_Deploy_UploadT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _tag = _o->tag.empty() ? 0 : _fbb.CreateString(_o->tag);
  auto _file_name = _o->file_name.empty() ? 0 : _fbb.CreateString(_o->file_name);
  auto _sha256 = _o->sha256.empty() ? 0 : _fbb.CreateString(_o->sha256);
  auto _path = _o->path.empty() ? 0 : _fbb.CreateString(_o->path);
  return deploy::CreateResponse_Deploy_Upload(
      _fbb,
      _tag,
      _file_name,
      _sha256,
      _path);
}

inline Response_Deploy_ProgressT *Response_Deploy_Progress::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Response_Deploy_ProgressT>(new Response_Deploy_ProgressT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Response_Deploy_Progress::UnPackTo(Response_Deploy_ProgressT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = sw_name(); if (_e) _o->sw_name = _e->str(); }
  { auto _e = mode(); if (_e) _o->mode = _e->str(); }
  { auto _e = tag(); if (_e) _o->tag = _e->str(); }
  { auto _e = percentage(); _o->percentage = _e; }
  { auto _e = service_name(); if (_e) _o->service_name = _e->str(); }
  { auto _e = result(); if (_e) _o->result = _e->str(); }
}

inline ::flatbuffers::Offset<Response_Deploy_Progress> Response_Deploy_Progress::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Response_Deploy_ProgressT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateResponse_Deploy_Progress(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Response_Deploy_Progress> CreateResponse_Deploy_Progress(::flatbuffers::FlatBufferBuilder &_fbb, const Response_Deploy_ProgressT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const Response_Deploy_ProgressT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _sw_name = _o->sw_name.empty() ? 0 : _fbb.CreateString(_o->sw_name);
  auto _mode = _o->mode.empty() ? 0 : _fbb.CreateString(_o->mode);
  auto _tag = _o->tag.empty() ? 0 : _fbb.CreateString(_o->tag);
  auto _percentage = _o->percentage;
  auto _service_name = _o->service_name.empty() ? 0 : _fbb.CreateString(_o->service_name);
  auto _result = _o->result.empty() ? 0 : _fbb.CreateString(_o->result);
  return deploy::CreateResponse_Deploy_Progress(
      _fbb,
      _sw_name,
      _mode,
      _tag,
      _percentage,
      _service_name,
      _result);
}

}  // namespace deploy

#endif  // FLATBUFFERS_GENERATED_DEPLOY_DEPLOY_H_
