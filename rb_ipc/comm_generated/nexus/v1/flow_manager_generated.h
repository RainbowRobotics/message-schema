// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_FLOWMANAGER_FLOW_MANAGER_H_
#define FLATBUFFERS_GENERATED_FLOWMANAGER_FLOW_MANAGER_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

namespace flow_manager {

struct Request_Update_Step_State;
struct Request_Update_Step_StateBuilder;
struct Request_Update_Step_StateT;

struct Request_Update_All_Step_State;
struct Request_Update_All_Step_StateBuilder;
struct Request_Update_All_Step_StateT;

struct Request_Update_Executor_State;
struct Request_Update_Executor_StateBuilder;
struct Request_Update_Executor_StateT;

enum RB_Flow_Manager_ProgramState : int8_t {
  RB_Flow_Manager_ProgramState_IDLE = 0,
  RB_Flow_Manager_ProgramState_RUNNING = 1,
  RB_Flow_Manager_ProgramState_PAUSED = 2,
  RB_Flow_Manager_ProgramState_STOPPED = 3,
  RB_Flow_Manager_ProgramState_WAITING = 4,
  RB_Flow_Manager_ProgramState_ERROR = 5,
  RB_Flow_Manager_ProgramState_COMPLETED = 6,
  RB_Flow_Manager_ProgramState_AFTER_COMPLETED = 7,
  RB_Flow_Manager_ProgramState_MIN = RB_Flow_Manager_ProgramState_IDLE,
  RB_Flow_Manager_ProgramState_MAX = RB_Flow_Manager_ProgramState_AFTER_COMPLETED
};

inline const RB_Flow_Manager_ProgramState (&EnumValuesRB_Flow_Manager_ProgramState())[8] {
  static const RB_Flow_Manager_ProgramState values[] = {
    RB_Flow_Manager_ProgramState_IDLE,
    RB_Flow_Manager_ProgramState_RUNNING,
    RB_Flow_Manager_ProgramState_PAUSED,
    RB_Flow_Manager_ProgramState_STOPPED,
    RB_Flow_Manager_ProgramState_WAITING,
    RB_Flow_Manager_ProgramState_ERROR,
    RB_Flow_Manager_ProgramState_COMPLETED,
    RB_Flow_Manager_ProgramState_AFTER_COMPLETED
  };
  return values;
}

inline const char * const *EnumNamesRB_Flow_Manager_ProgramState() {
  static const char * const names[9] = {
    "IDLE",
    "RUNNING",
    "PAUSED",
    "STOPPED",
    "WAITING",
    "ERROR",
    "COMPLETED",
    "AFTER_COMPLETED",
    nullptr
  };
  return names;
}

inline const char *EnumNameRB_Flow_Manager_ProgramState(RB_Flow_Manager_ProgramState e) {
  if (::flatbuffers::IsOutRange(e, RB_Flow_Manager_ProgramState_IDLE, RB_Flow_Manager_ProgramState_AFTER_COMPLETED)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRB_Flow_Manager_ProgramState()[index];
}

struct Request_Update_Step_StateT : public ::flatbuffers::NativeTable {
  typedef Request_Update_Step_State TableType;
  std::string step_id{};
  std::string task_id{};
  flow_manager::RB_Flow_Manager_ProgramState state = flow_manager::RB_Flow_Manager_ProgramState_IDLE;
  std::string error{};
};

struct Request_Update_Step_State FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Request_Update_Step_StateT NativeTableType;
  typedef Request_Update_Step_StateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STEP_ID = 4,
    VT_TASK_ID = 6,
    VT_STATE = 8,
    VT_ERROR = 10
  };
  const ::flatbuffers::String *step_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STEP_ID);
  }
  const ::flatbuffers::String *task_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TASK_ID);
  }
  flow_manager::RB_Flow_Manager_ProgramState state() const {
    return static_cast<flow_manager::RB_Flow_Manager_ProgramState>(GetField<int8_t>(VT_STATE, 0));
  }
  const ::flatbuffers::String *error() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ERROR);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_STEP_ID) &&
           verifier.VerifyString(step_id()) &&
           VerifyOffset(verifier, VT_TASK_ID) &&
           verifier.VerifyString(task_id()) &&
           VerifyField<int8_t>(verifier, VT_STATE, 1) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyString(error()) &&
           verifier.EndTable();
  }
  Request_Update_Step_StateT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_Update_Step_StateT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Request_Update_Step_State> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Update_Step_StateT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_Update_Step_StateBuilder {
  typedef Request_Update_Step_State Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_step_id(::flatbuffers::Offset<::flatbuffers::String> step_id) {
    fbb_.AddOffset(Request_Update_Step_State::VT_STEP_ID, step_id);
  }
  void add_task_id(::flatbuffers::Offset<::flatbuffers::String> task_id) {
    fbb_.AddOffset(Request_Update_Step_State::VT_TASK_ID, task_id);
  }
  void add_state(flow_manager::RB_Flow_Manager_ProgramState state) {
    fbb_.AddElement<int8_t>(Request_Update_Step_State::VT_STATE, static_cast<int8_t>(state), 0);
  }
  void add_error(::flatbuffers::Offset<::flatbuffers::String> error) {
    fbb_.AddOffset(Request_Update_Step_State::VT_ERROR, error);
  }
  explicit Request_Update_Step_StateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Request_Update_Step_State> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Request_Update_Step_State>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Request_Update_Step_State> CreateRequest_Update_Step_State(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> step_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> task_id = 0,
    flow_manager::RB_Flow_Manager_ProgramState state = flow_manager::RB_Flow_Manager_ProgramState_IDLE,
    ::flatbuffers::Offset<::flatbuffers::String> error = 0) {
  Request_Update_Step_StateBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_task_id(task_id);
  builder_.add_step_id(step_id);
  builder_.add_state(state);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Request_Update_Step_State> CreateRequest_Update_Step_StateDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *step_id = nullptr,
    const char *task_id = nullptr,
    flow_manager::RB_Flow_Manager_ProgramState state = flow_manager::RB_Flow_Manager_ProgramState_IDLE,
    const char *error = nullptr) {
  auto step_id__ = step_id ? _fbb.CreateString(step_id) : 0;
  auto task_id__ = task_id ? _fbb.CreateString(task_id) : 0;
  auto error__ = error ? _fbb.CreateString(error) : 0;
  return flow_manager::CreateRequest_Update_Step_State(
      _fbb,
      step_id__,
      task_id__,
      state,
      error__);
}

::flatbuffers::Offset<Request_Update_Step_State> CreateRequest_Update_Step_State(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Update_Step_StateT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Request_Update_All_Step_StateT : public ::flatbuffers::NativeTable {
  typedef Request_Update_All_Step_State TableType;
  std::string task_id{};
  flow_manager::RB_Flow_Manager_ProgramState state = flow_manager::RB_Flow_Manager_ProgramState_IDLE;
};

struct Request_Update_All_Step_State FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Request_Update_All_Step_StateT NativeTableType;
  typedef Request_Update_All_Step_StateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TASK_ID = 4,
    VT_STATE = 6
  };
  const ::flatbuffers::String *task_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TASK_ID);
  }
  flow_manager::RB_Flow_Manager_ProgramState state() const {
    return static_cast<flow_manager::RB_Flow_Manager_ProgramState>(GetField<int8_t>(VT_STATE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TASK_ID) &&
           verifier.VerifyString(task_id()) &&
           VerifyField<int8_t>(verifier, VT_STATE, 1) &&
           verifier.EndTable();
  }
  Request_Update_All_Step_StateT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_Update_All_Step_StateT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Request_Update_All_Step_State> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Update_All_Step_StateT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_Update_All_Step_StateBuilder {
  typedef Request_Update_All_Step_State Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_task_id(::flatbuffers::Offset<::flatbuffers::String> task_id) {
    fbb_.AddOffset(Request_Update_All_Step_State::VT_TASK_ID, task_id);
  }
  void add_state(flow_manager::RB_Flow_Manager_ProgramState state) {
    fbb_.AddElement<int8_t>(Request_Update_All_Step_State::VT_STATE, static_cast<int8_t>(state), 0);
  }
  explicit Request_Update_All_Step_StateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Request_Update_All_Step_State> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Request_Update_All_Step_State>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Request_Update_All_Step_State> CreateRequest_Update_All_Step_State(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> task_id = 0,
    flow_manager::RB_Flow_Manager_ProgramState state = flow_manager::RB_Flow_Manager_ProgramState_IDLE) {
  Request_Update_All_Step_StateBuilder builder_(_fbb);
  builder_.add_task_id(task_id);
  builder_.add_state(state);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Request_Update_All_Step_State> CreateRequest_Update_All_Step_StateDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *task_id = nullptr,
    flow_manager::RB_Flow_Manager_ProgramState state = flow_manager::RB_Flow_Manager_ProgramState_IDLE) {
  auto task_id__ = task_id ? _fbb.CreateString(task_id) : 0;
  return flow_manager::CreateRequest_Update_All_Step_State(
      _fbb,
      task_id__,
      state);
}

::flatbuffers::Offset<Request_Update_All_Step_State> CreateRequest_Update_All_Step_State(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Update_All_Step_StateT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Request_Update_Executor_StateT : public ::flatbuffers::NativeTable {
  typedef Request_Update_Executor_State TableType;
  flow_manager::RB_Flow_Manager_ProgramState state = flow_manager::RB_Flow_Manager_ProgramState_IDLE;
  std::string error{};
};

struct Request_Update_Executor_State FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Request_Update_Executor_StateT NativeTableType;
  typedef Request_Update_Executor_StateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STATE = 4,
    VT_ERROR = 6
  };
  flow_manager::RB_Flow_Manager_ProgramState state() const {
    return static_cast<flow_manager::RB_Flow_Manager_ProgramState>(GetField<int8_t>(VT_STATE, 0));
  }
  const ::flatbuffers::String *error() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ERROR);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_STATE, 1) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyString(error()) &&
           verifier.EndTable();
  }
  Request_Update_Executor_StateT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_Update_Executor_StateT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Request_Update_Executor_State> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Update_Executor_StateT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_Update_Executor_StateBuilder {
  typedef Request_Update_Executor_State Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_state(flow_manager::RB_Flow_Manager_ProgramState state) {
    fbb_.AddElement<int8_t>(Request_Update_Executor_State::VT_STATE, static_cast<int8_t>(state), 0);
  }
  void add_error(::flatbuffers::Offset<::flatbuffers::String> error) {
    fbb_.AddOffset(Request_Update_Executor_State::VT_ERROR, error);
  }
  explicit Request_Update_Executor_StateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Request_Update_Executor_State> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Request_Update_Executor_State>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Request_Update_Executor_State> CreateRequest_Update_Executor_State(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    flow_manager::RB_Flow_Manager_ProgramState state = flow_manager::RB_Flow_Manager_ProgramState_IDLE,
    ::flatbuffers::Offset<::flatbuffers::String> error = 0) {
  Request_Update_Executor_StateBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_state(state);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Request_Update_Executor_State> CreateRequest_Update_Executor_StateDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    flow_manager::RB_Flow_Manager_ProgramState state = flow_manager::RB_Flow_Manager_ProgramState_IDLE,
    const char *error = nullptr) {
  auto error__ = error ? _fbb.CreateString(error) : 0;
  return flow_manager::CreateRequest_Update_Executor_State(
      _fbb,
      state,
      error__);
}

::flatbuffers::Offset<Request_Update_Executor_State> CreateRequest_Update_Executor_State(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Update_Executor_StateT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline Request_Update_Step_StateT *Request_Update_Step_State::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Request_Update_Step_StateT>(new Request_Update_Step_StateT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Request_Update_Step_State::UnPackTo(Request_Update_Step_StateT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = step_id(); if (_e) _o->step_id = _e->str(); }
  { auto _e = task_id(); if (_e) _o->task_id = _e->str(); }
  { auto _e = state(); _o->state = _e; }
  { auto _e = error(); if (_e) _o->error = _e->str(); }
}

inline ::flatbuffers::Offset<Request_Update_Step_State> Request_Update_Step_State::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Update_Step_StateT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_Update_Step_State(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Request_Update_Step_State> CreateRequest_Update_Step_State(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Update_Step_StateT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const Request_Update_Step_StateT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _step_id = _o->step_id.empty() ? 0 : _fbb.CreateString(_o->step_id);
  auto _task_id = _o->task_id.empty() ? 0 : _fbb.CreateString(_o->task_id);
  auto _state = _o->state;
  auto _error = _o->error.empty() ? 0 : _fbb.CreateString(_o->error);
  return flow_manager::CreateRequest_Update_Step_State(
      _fbb,
      _step_id,
      _task_id,
      _state,
      _error);
}

inline Request_Update_All_Step_StateT *Request_Update_All_Step_State::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Request_Update_All_Step_StateT>(new Request_Update_All_Step_StateT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Request_Update_All_Step_State::UnPackTo(Request_Update_All_Step_StateT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = task_id(); if (_e) _o->task_id = _e->str(); }
  { auto _e = state(); _o->state = _e; }
}

inline ::flatbuffers::Offset<Request_Update_All_Step_State> Request_Update_All_Step_State::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Update_All_Step_StateT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_Update_All_Step_State(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Request_Update_All_Step_State> CreateRequest_Update_All_Step_State(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Update_All_Step_StateT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const Request_Update_All_Step_StateT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _task_id = _o->task_id.empty() ? 0 : _fbb.CreateString(_o->task_id);
  auto _state = _o->state;
  return flow_manager::CreateRequest_Update_All_Step_State(
      _fbb,
      _task_id,
      _state);
}

inline Request_Update_Executor_StateT *Request_Update_Executor_State::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Request_Update_Executor_StateT>(new Request_Update_Executor_StateT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Request_Update_Executor_State::UnPackTo(Request_Update_Executor_StateT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = state(); _o->state = _e; }
  { auto _e = error(); if (_e) _o->error = _e->str(); }
}

inline ::flatbuffers::Offset<Request_Update_Executor_State> Request_Update_Executor_State::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Update_Executor_StateT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_Update_Executor_State(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Request_Update_Executor_State> CreateRequest_Update_Executor_State(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Update_Executor_StateT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const Request_Update_Executor_StateT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _state = _o->state;
  auto _error = _o->error.empty() ? 0 : _fbb.CreateString(_o->error);
  return flow_manager::CreateRequest_Update_Executor_State(
      _fbb,
      _state,
      _error);
}

}  // namespace flow_manager

#endif  // FLATBUFFERS_GENERATED_FLOWMANAGER_FLOW_MANAGER_H_
