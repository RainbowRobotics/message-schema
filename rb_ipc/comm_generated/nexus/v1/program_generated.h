// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_PROGRAM_PROGRAM_H_
#define FLATBUFFERS_GENERATED_PROGRAM_PROGRAM_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

#include "flow_manager_generated.h"

namespace program {

struct RB_Program_Task_Status;
struct RB_Program_Task_StatusBuilder;
struct RB_Program_Task_StatusT;

struct RB_Program_Task_Checkpoint;
struct RB_Program_Task_CheckpointBuilder;
struct RB_Program_Task_CheckpointT;

struct RB_Program_Dialog;
struct RB_Program_DialogBuilder;
struct RB_Program_DialogT;

struct RB_Program_Log;
struct RB_Program_LogBuilder;
struct RB_Program_LogT;

struct Request_Program_At_Start;
struct Request_Program_At_StartBuilder;
struct Request_Program_At_StartT;

struct Request_Program_At_End;
struct Request_Program_At_EndBuilder;
struct Request_Program_At_EndT;

struct Request_Update_Sub_Task_State;
struct Request_Update_Sub_Task_StateBuilder;
struct Request_Update_Sub_Task_StateT;

enum RB_Program_Sub_Task_Type : int8_t {
  RB_Program_Sub_Task_Type_SUB_TASK_INSERT = 0,
  RB_Program_Sub_Task_Type_SUB_TASK_CHANGE = 1,
  RB_Program_Sub_Task_Type_MIN = RB_Program_Sub_Task_Type_SUB_TASK_INSERT,
  RB_Program_Sub_Task_Type_MAX = RB_Program_Sub_Task_Type_SUB_TASK_CHANGE
};

inline const RB_Program_Sub_Task_Type (&EnumValuesRB_Program_Sub_Task_Type())[2] {
  static const RB_Program_Sub_Task_Type values[] = {
    RB_Program_Sub_Task_Type_SUB_TASK_INSERT,
    RB_Program_Sub_Task_Type_SUB_TASK_CHANGE
  };
  return values;
}

inline const char * const *EnumNamesRB_Program_Sub_Task_Type() {
  static const char * const names[3] = {
    "SUB_TASK_INSERT",
    "SUB_TASK_CHANGE",
    nullptr
  };
  return names;
}

inline const char *EnumNameRB_Program_Sub_Task_Type(RB_Program_Sub_Task_Type e) {
  if (::flatbuffers::IsOutRange(e, RB_Program_Sub_Task_Type_SUB_TASK_INSERT, RB_Program_Sub_Task_Type_SUB_TASK_CHANGE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRB_Program_Sub_Task_Type()[index];
}

enum RB_Program_Log_Type : int8_t {
  RB_Program_Log_Type_INFO = 0,
  RB_Program_Log_Type_WARNING = 1,
  RB_Program_Log_Type_ERROR = 2,
  RB_Program_Log_Type_USER = 3,
  RB_Program_Log_Type_DEBUG = 4,
  RB_Program_Log_Type_GENERAL = 5,
  RB_Program_Log_Type_MIN = RB_Program_Log_Type_INFO,
  RB_Program_Log_Type_MAX = RB_Program_Log_Type_GENERAL
};

inline const RB_Program_Log_Type (&EnumValuesRB_Program_Log_Type())[6] {
  static const RB_Program_Log_Type values[] = {
    RB_Program_Log_Type_INFO,
    RB_Program_Log_Type_WARNING,
    RB_Program_Log_Type_ERROR,
    RB_Program_Log_Type_USER,
    RB_Program_Log_Type_DEBUG,
    RB_Program_Log_Type_GENERAL
  };
  return values;
}

inline const char * const *EnumNamesRB_Program_Log_Type() {
  static const char * const names[7] = {
    "INFO",
    "WARNING",
    "ERROR",
    "USER",
    "DEBUG",
    "GENERAL",
    nullptr
  };
  return names;
}

inline const char *EnumNameRB_Program_Log_Type(RB_Program_Log_Type e) {
  if (::flatbuffers::IsOutRange(e, RB_Program_Log_Type_INFO, RB_Program_Log_Type_GENERAL)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRB_Program_Log_Type()[index];
}

struct RB_Program_Task_StatusT : public ::flatbuffers::NativeTable {
  typedef RB_Program_Task_Status TableType;
  std::string task_id{};
  std::string program_id{};
  std::vector<std::string> sync_task_ids{};
  std::vector<std::string> node_path{};
  std::string status{};
  int32_t offset = 0;
};

struct RB_Program_Task_Status FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RB_Program_Task_StatusT NativeTableType;
  typedef RB_Program_Task_StatusBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TASK_ID = 4,
    VT_PROGRAM_ID = 6,
    VT_SYNC_TASK_IDS = 8,
    VT_NODE_PATH = 10,
    VT_STATUS = 12,
    VT_OFFSET = 14
  };
  const ::flatbuffers::String *task_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TASK_ID);
  }
  const ::flatbuffers::String *program_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PROGRAM_ID);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *sync_task_ids() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_SYNC_TASK_IDS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *node_path() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_NODE_PATH);
  }
  const ::flatbuffers::String *status() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STATUS);
  }
  int32_t offset() const {
    return GetField<int32_t>(VT_OFFSET, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TASK_ID) &&
           verifier.VerifyString(task_id()) &&
           VerifyOffset(verifier, VT_PROGRAM_ID) &&
           verifier.VerifyString(program_id()) &&
           VerifyOffset(verifier, VT_SYNC_TASK_IDS) &&
           verifier.VerifyVector(sync_task_ids()) &&
           verifier.VerifyVectorOfStrings(sync_task_ids()) &&
           VerifyOffset(verifier, VT_NODE_PATH) &&
           verifier.VerifyVector(node_path()) &&
           verifier.VerifyVectorOfStrings(node_path()) &&
           VerifyOffset(verifier, VT_STATUS) &&
           verifier.VerifyString(status()) &&
           VerifyField<int32_t>(verifier, VT_OFFSET, 4) &&
           verifier.EndTable();
  }
  RB_Program_Task_StatusT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RB_Program_Task_StatusT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<RB_Program_Task_Status> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RB_Program_Task_StatusT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RB_Program_Task_StatusBuilder {
  typedef RB_Program_Task_Status Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_task_id(::flatbuffers::Offset<::flatbuffers::String> task_id) {
    fbb_.AddOffset(RB_Program_Task_Status::VT_TASK_ID, task_id);
  }
  void add_program_id(::flatbuffers::Offset<::flatbuffers::String> program_id) {
    fbb_.AddOffset(RB_Program_Task_Status::VT_PROGRAM_ID, program_id);
  }
  void add_sync_task_ids(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> sync_task_ids) {
    fbb_.AddOffset(RB_Program_Task_Status::VT_SYNC_TASK_IDS, sync_task_ids);
  }
  void add_node_path(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> node_path) {
    fbb_.AddOffset(RB_Program_Task_Status::VT_NODE_PATH, node_path);
  }
  void add_status(::flatbuffers::Offset<::flatbuffers::String> status) {
    fbb_.AddOffset(RB_Program_Task_Status::VT_STATUS, status);
  }
  void add_offset(int32_t offset) {
    fbb_.AddElement<int32_t>(RB_Program_Task_Status::VT_OFFSET, offset, 0);
  }
  explicit RB_Program_Task_StatusBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RB_Program_Task_Status> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RB_Program_Task_Status>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RB_Program_Task_Status> CreateRB_Program_Task_Status(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> task_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> program_id = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> sync_task_ids = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> node_path = 0,
    ::flatbuffers::Offset<::flatbuffers::String> status = 0,
    int32_t offset = 0) {
  RB_Program_Task_StatusBuilder builder_(_fbb);
  builder_.add_offset(offset);
  builder_.add_status(status);
  builder_.add_node_path(node_path);
  builder_.add_sync_task_ids(sync_task_ids);
  builder_.add_program_id(program_id);
  builder_.add_task_id(task_id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RB_Program_Task_Status> CreateRB_Program_Task_StatusDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *task_id = nullptr,
    const char *program_id = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *sync_task_ids = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *node_path = nullptr,
    const char *status = nullptr,
    int32_t offset = 0) {
  auto task_id__ = task_id ? _fbb.CreateString(task_id) : 0;
  auto program_id__ = program_id ? _fbb.CreateString(program_id) : 0;
  auto sync_task_ids__ = sync_task_ids ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*sync_task_ids) : 0;
  auto node_path__ = node_path ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*node_path) : 0;
  auto status__ = status ? _fbb.CreateString(status) : 0;
  return program::CreateRB_Program_Task_Status(
      _fbb,
      task_id__,
      program_id__,
      sync_task_ids__,
      node_path__,
      status__,
      offset);
}

::flatbuffers::Offset<RB_Program_Task_Status> CreateRB_Program_Task_Status(::flatbuffers::FlatBufferBuilder &_fbb, const RB_Program_Task_StatusT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RB_Program_Task_CheckpointT : public ::flatbuffers::NativeTable {
  typedef RB_Program_Task_Checkpoint TableType;
  std::string task_id{};
  std::string program_id{};
  std::vector<std::string> sync_task_ids{};
  std::vector<std::string> node_path{};
  int32_t offset = 0;
  std::string status{};
};

struct RB_Program_Task_Checkpoint FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RB_Program_Task_CheckpointT NativeTableType;
  typedef RB_Program_Task_CheckpointBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TASK_ID = 4,
    VT_PROGRAM_ID = 6,
    VT_SYNC_TASK_IDS = 8,
    VT_NODE_PATH = 10,
    VT_OFFSET = 12,
    VT_STATUS = 14
  };
  const ::flatbuffers::String *task_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TASK_ID);
  }
  const ::flatbuffers::String *program_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PROGRAM_ID);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *sync_task_ids() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_SYNC_TASK_IDS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *node_path() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_NODE_PATH);
  }
  int32_t offset() const {
    return GetField<int32_t>(VT_OFFSET, 0);
  }
  const ::flatbuffers::String *status() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STATUS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TASK_ID) &&
           verifier.VerifyString(task_id()) &&
           VerifyOffset(verifier, VT_PROGRAM_ID) &&
           verifier.VerifyString(program_id()) &&
           VerifyOffset(verifier, VT_SYNC_TASK_IDS) &&
           verifier.VerifyVector(sync_task_ids()) &&
           verifier.VerifyVectorOfStrings(sync_task_ids()) &&
           VerifyOffset(verifier, VT_NODE_PATH) &&
           verifier.VerifyVector(node_path()) &&
           verifier.VerifyVectorOfStrings(node_path()) &&
           VerifyField<int32_t>(verifier, VT_OFFSET, 4) &&
           VerifyOffset(verifier, VT_STATUS) &&
           verifier.VerifyString(status()) &&
           verifier.EndTable();
  }
  RB_Program_Task_CheckpointT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RB_Program_Task_CheckpointT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<RB_Program_Task_Checkpoint> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RB_Program_Task_CheckpointT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RB_Program_Task_CheckpointBuilder {
  typedef RB_Program_Task_Checkpoint Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_task_id(::flatbuffers::Offset<::flatbuffers::String> task_id) {
    fbb_.AddOffset(RB_Program_Task_Checkpoint::VT_TASK_ID, task_id);
  }
  void add_program_id(::flatbuffers::Offset<::flatbuffers::String> program_id) {
    fbb_.AddOffset(RB_Program_Task_Checkpoint::VT_PROGRAM_ID, program_id);
  }
  void add_sync_task_ids(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> sync_task_ids) {
    fbb_.AddOffset(RB_Program_Task_Checkpoint::VT_SYNC_TASK_IDS, sync_task_ids);
  }
  void add_node_path(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> node_path) {
    fbb_.AddOffset(RB_Program_Task_Checkpoint::VT_NODE_PATH, node_path);
  }
  void add_offset(int32_t offset) {
    fbb_.AddElement<int32_t>(RB_Program_Task_Checkpoint::VT_OFFSET, offset, 0);
  }
  void add_status(::flatbuffers::Offset<::flatbuffers::String> status) {
    fbb_.AddOffset(RB_Program_Task_Checkpoint::VT_STATUS, status);
  }
  explicit RB_Program_Task_CheckpointBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RB_Program_Task_Checkpoint> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RB_Program_Task_Checkpoint>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RB_Program_Task_Checkpoint> CreateRB_Program_Task_Checkpoint(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> task_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> program_id = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> sync_task_ids = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> node_path = 0,
    int32_t offset = 0,
    ::flatbuffers::Offset<::flatbuffers::String> status = 0) {
  RB_Program_Task_CheckpointBuilder builder_(_fbb);
  builder_.add_status(status);
  builder_.add_offset(offset);
  builder_.add_node_path(node_path);
  builder_.add_sync_task_ids(sync_task_ids);
  builder_.add_program_id(program_id);
  builder_.add_task_id(task_id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RB_Program_Task_Checkpoint> CreateRB_Program_Task_CheckpointDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *task_id = nullptr,
    const char *program_id = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *sync_task_ids = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *node_path = nullptr,
    int32_t offset = 0,
    const char *status = nullptr) {
  auto task_id__ = task_id ? _fbb.CreateString(task_id) : 0;
  auto program_id__ = program_id ? _fbb.CreateString(program_id) : 0;
  auto sync_task_ids__ = sync_task_ids ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*sync_task_ids) : 0;
  auto node_path__ = node_path ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*node_path) : 0;
  auto status__ = status ? _fbb.CreateString(status) : 0;
  return program::CreateRB_Program_Task_Checkpoint(
      _fbb,
      task_id__,
      program_id__,
      sync_task_ids__,
      node_path__,
      offset,
      status__);
}

::flatbuffers::Offset<RB_Program_Task_Checkpoint> CreateRB_Program_Task_Checkpoint(::flatbuffers::FlatBufferBuilder &_fbb, const RB_Program_Task_CheckpointT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RB_Program_DialogT : public ::flatbuffers::NativeTable {
  typedef RB_Program_Dialog TableType;
  std::string robot_model{};
  std::string title{};
  std::string content{};
};

struct RB_Program_Dialog FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RB_Program_DialogT NativeTableType;
  typedef RB_Program_DialogBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ROBOT_MODEL = 4,
    VT_TITLE = 6,
    VT_CONTENT = 8
  };
  const ::flatbuffers::String *robot_model() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ROBOT_MODEL);
  }
  const ::flatbuffers::String *title() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TITLE);
  }
  const ::flatbuffers::String *content() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CONTENT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ROBOT_MODEL) &&
           verifier.VerifyString(robot_model()) &&
           VerifyOffset(verifier, VT_TITLE) &&
           verifier.VerifyString(title()) &&
           VerifyOffset(verifier, VT_CONTENT) &&
           verifier.VerifyString(content()) &&
           verifier.EndTable();
  }
  RB_Program_DialogT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RB_Program_DialogT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<RB_Program_Dialog> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RB_Program_DialogT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RB_Program_DialogBuilder {
  typedef RB_Program_Dialog Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_robot_model(::flatbuffers::Offset<::flatbuffers::String> robot_model) {
    fbb_.AddOffset(RB_Program_Dialog::VT_ROBOT_MODEL, robot_model);
  }
  void add_title(::flatbuffers::Offset<::flatbuffers::String> title) {
    fbb_.AddOffset(RB_Program_Dialog::VT_TITLE, title);
  }
  void add_content(::flatbuffers::Offset<::flatbuffers::String> content) {
    fbb_.AddOffset(RB_Program_Dialog::VT_CONTENT, content);
  }
  explicit RB_Program_DialogBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RB_Program_Dialog> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RB_Program_Dialog>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RB_Program_Dialog> CreateRB_Program_Dialog(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> robot_model = 0,
    ::flatbuffers::Offset<::flatbuffers::String> title = 0,
    ::flatbuffers::Offset<::flatbuffers::String> content = 0) {
  RB_Program_DialogBuilder builder_(_fbb);
  builder_.add_content(content);
  builder_.add_title(title);
  builder_.add_robot_model(robot_model);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RB_Program_Dialog> CreateRB_Program_DialogDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *robot_model = nullptr,
    const char *title = nullptr,
    const char *content = nullptr) {
  auto robot_model__ = robot_model ? _fbb.CreateString(robot_model) : 0;
  auto title__ = title ? _fbb.CreateString(title) : 0;
  auto content__ = content ? _fbb.CreateString(content) : 0;
  return program::CreateRB_Program_Dialog(
      _fbb,
      robot_model__,
      title__,
      content__);
}

::flatbuffers::Offset<RB_Program_Dialog> CreateRB_Program_Dialog(::flatbuffers::FlatBufferBuilder &_fbb, const RB_Program_DialogT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RB_Program_LogT : public ::flatbuffers::NativeTable {
  typedef RB_Program_Log TableType;
  std::string content{};
  std::string robot_model{};
  program::RB_Program_Log_Type type = program::RB_Program_Log_Type_INFO;
};

struct RB_Program_Log FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RB_Program_LogT NativeTableType;
  typedef RB_Program_LogBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONTENT = 4,
    VT_ROBOT_MODEL = 6,
    VT_TYPE = 8
  };
  const ::flatbuffers::String *content() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CONTENT);
  }
  const ::flatbuffers::String *robot_model() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ROBOT_MODEL);
  }
  program::RB_Program_Log_Type type() const {
    return static_cast<program::RB_Program_Log_Type>(GetField<int8_t>(VT_TYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CONTENT) &&
           verifier.VerifyString(content()) &&
           VerifyOffset(verifier, VT_ROBOT_MODEL) &&
           verifier.VerifyString(robot_model()) &&
           VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           verifier.EndTable();
  }
  RB_Program_LogT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RB_Program_LogT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<RB_Program_Log> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RB_Program_LogT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RB_Program_LogBuilder {
  typedef RB_Program_Log Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_content(::flatbuffers::Offset<::flatbuffers::String> content) {
    fbb_.AddOffset(RB_Program_Log::VT_CONTENT, content);
  }
  void add_robot_model(::flatbuffers::Offset<::flatbuffers::String> robot_model) {
    fbb_.AddOffset(RB_Program_Log::VT_ROBOT_MODEL, robot_model);
  }
  void add_type(program::RB_Program_Log_Type type) {
    fbb_.AddElement<int8_t>(RB_Program_Log::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  explicit RB_Program_LogBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RB_Program_Log> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RB_Program_Log>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RB_Program_Log> CreateRB_Program_Log(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> content = 0,
    ::flatbuffers::Offset<::flatbuffers::String> robot_model = 0,
    program::RB_Program_Log_Type type = program::RB_Program_Log_Type_INFO) {
  RB_Program_LogBuilder builder_(_fbb);
  builder_.add_robot_model(robot_model);
  builder_.add_content(content);
  builder_.add_type(type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RB_Program_Log> CreateRB_Program_LogDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *content = nullptr,
    const char *robot_model = nullptr,
    program::RB_Program_Log_Type type = program::RB_Program_Log_Type_INFO) {
  auto content__ = content ? _fbb.CreateString(content) : 0;
  auto robot_model__ = robot_model ? _fbb.CreateString(robot_model) : 0;
  return program::CreateRB_Program_Log(
      _fbb,
      content__,
      robot_model__,
      type);
}

::flatbuffers::Offset<RB_Program_Log> CreateRB_Program_Log(::flatbuffers::FlatBufferBuilder &_fbb, const RB_Program_LogT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Request_Program_At_StartT : public ::flatbuffers::NativeTable {
  typedef Request_Program_At_Start TableType;
  std::string task_id{};
};

struct Request_Program_At_Start FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Request_Program_At_StartT NativeTableType;
  typedef Request_Program_At_StartBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TASK_ID = 4
  };
  const ::flatbuffers::String *task_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TASK_ID);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TASK_ID) &&
           verifier.VerifyString(task_id()) &&
           verifier.EndTable();
  }
  Request_Program_At_StartT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_Program_At_StartT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Request_Program_At_Start> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Program_At_StartT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_Program_At_StartBuilder {
  typedef Request_Program_At_Start Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_task_id(::flatbuffers::Offset<::flatbuffers::String> task_id) {
    fbb_.AddOffset(Request_Program_At_Start::VT_TASK_ID, task_id);
  }
  explicit Request_Program_At_StartBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Request_Program_At_Start> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Request_Program_At_Start>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Request_Program_At_Start> CreateRequest_Program_At_Start(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> task_id = 0) {
  Request_Program_At_StartBuilder builder_(_fbb);
  builder_.add_task_id(task_id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Request_Program_At_Start> CreateRequest_Program_At_StartDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *task_id = nullptr) {
  auto task_id__ = task_id ? _fbb.CreateString(task_id) : 0;
  return program::CreateRequest_Program_At_Start(
      _fbb,
      task_id__);
}

::flatbuffers::Offset<Request_Program_At_Start> CreateRequest_Program_At_Start(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Program_At_StartT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Request_Program_At_EndT : public ::flatbuffers::NativeTable {
  typedef Request_Program_At_End TableType;
  std::string task_id{};
};

struct Request_Program_At_End FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Request_Program_At_EndT NativeTableType;
  typedef Request_Program_At_EndBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TASK_ID = 4
  };
  const ::flatbuffers::String *task_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TASK_ID);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TASK_ID) &&
           verifier.VerifyString(task_id()) &&
           verifier.EndTable();
  }
  Request_Program_At_EndT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_Program_At_EndT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Request_Program_At_End> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Program_At_EndT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_Program_At_EndBuilder {
  typedef Request_Program_At_End Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_task_id(::flatbuffers::Offset<::flatbuffers::String> task_id) {
    fbb_.AddOffset(Request_Program_At_End::VT_TASK_ID, task_id);
  }
  explicit Request_Program_At_EndBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Request_Program_At_End> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Request_Program_At_End>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Request_Program_At_End> CreateRequest_Program_At_End(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> task_id = 0) {
  Request_Program_At_EndBuilder builder_(_fbb);
  builder_.add_task_id(task_id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Request_Program_At_End> CreateRequest_Program_At_EndDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *task_id = nullptr) {
  auto task_id__ = task_id ? _fbb.CreateString(task_id) : 0;
  return program::CreateRequest_Program_At_End(
      _fbb,
      task_id__);
}

::flatbuffers::Offset<Request_Program_At_End> CreateRequest_Program_At_End(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Program_At_EndT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Request_Update_Sub_Task_StateT : public ::flatbuffers::NativeTable {
  typedef Request_Update_Sub_Task_State TableType;
  std::string sub_task_id{};
  program::RB_Program_Sub_Task_Type sub_task_type = program::RB_Program_Sub_Task_Type_SUB_TASK_INSERT;
  flow_manager::RB_Flow_Manager_ProgramState state = flow_manager::RB_Flow_Manager_ProgramState_IDLE;
};

struct Request_Update_Sub_Task_State FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Request_Update_Sub_Task_StateT NativeTableType;
  typedef Request_Update_Sub_Task_StateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUB_TASK_ID = 4,
    VT_SUB_TASK_TYPE = 6,
    VT_STATE = 8
  };
  const ::flatbuffers::String *sub_task_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SUB_TASK_ID);
  }
  program::RB_Program_Sub_Task_Type sub_task_type() const {
    return static_cast<program::RB_Program_Sub_Task_Type>(GetField<int8_t>(VT_SUB_TASK_TYPE, 0));
  }
  flow_manager::RB_Flow_Manager_ProgramState state() const {
    return static_cast<flow_manager::RB_Flow_Manager_ProgramState>(GetField<int8_t>(VT_STATE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SUB_TASK_ID) &&
           verifier.VerifyString(sub_task_id()) &&
           VerifyField<int8_t>(verifier, VT_SUB_TASK_TYPE, 1) &&
           VerifyField<int8_t>(verifier, VT_STATE, 1) &&
           verifier.EndTable();
  }
  Request_Update_Sub_Task_StateT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_Update_Sub_Task_StateT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Request_Update_Sub_Task_State> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Update_Sub_Task_StateT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_Update_Sub_Task_StateBuilder {
  typedef Request_Update_Sub_Task_State Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_sub_task_id(::flatbuffers::Offset<::flatbuffers::String> sub_task_id) {
    fbb_.AddOffset(Request_Update_Sub_Task_State::VT_SUB_TASK_ID, sub_task_id);
  }
  void add_sub_task_type(program::RB_Program_Sub_Task_Type sub_task_type) {
    fbb_.AddElement<int8_t>(Request_Update_Sub_Task_State::VT_SUB_TASK_TYPE, static_cast<int8_t>(sub_task_type), 0);
  }
  void add_state(flow_manager::RB_Flow_Manager_ProgramState state) {
    fbb_.AddElement<int8_t>(Request_Update_Sub_Task_State::VT_STATE, static_cast<int8_t>(state), 0);
  }
  explicit Request_Update_Sub_Task_StateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Request_Update_Sub_Task_State> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Request_Update_Sub_Task_State>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Request_Update_Sub_Task_State> CreateRequest_Update_Sub_Task_State(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> sub_task_id = 0,
    program::RB_Program_Sub_Task_Type sub_task_type = program::RB_Program_Sub_Task_Type_SUB_TASK_INSERT,
    flow_manager::RB_Flow_Manager_ProgramState state = flow_manager::RB_Flow_Manager_ProgramState_IDLE) {
  Request_Update_Sub_Task_StateBuilder builder_(_fbb);
  builder_.add_sub_task_id(sub_task_id);
  builder_.add_state(state);
  builder_.add_sub_task_type(sub_task_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Request_Update_Sub_Task_State> CreateRequest_Update_Sub_Task_StateDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *sub_task_id = nullptr,
    program::RB_Program_Sub_Task_Type sub_task_type = program::RB_Program_Sub_Task_Type_SUB_TASK_INSERT,
    flow_manager::RB_Flow_Manager_ProgramState state = flow_manager::RB_Flow_Manager_ProgramState_IDLE) {
  auto sub_task_id__ = sub_task_id ? _fbb.CreateString(sub_task_id) : 0;
  return program::CreateRequest_Update_Sub_Task_State(
      _fbb,
      sub_task_id__,
      sub_task_type,
      state);
}

::flatbuffers::Offset<Request_Update_Sub_Task_State> CreateRequest_Update_Sub_Task_State(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Update_Sub_Task_StateT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline RB_Program_Task_StatusT *RB_Program_Task_Status::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<RB_Program_Task_StatusT>(new RB_Program_Task_StatusT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RB_Program_Task_Status::UnPackTo(RB_Program_Task_StatusT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = task_id(); if (_e) _o->task_id = _e->str(); }
  { auto _e = program_id(); if (_e) _o->program_id = _e->str(); }
  { auto _e = sync_task_ids(); if (_e) { _o->sync_task_ids.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->sync_task_ids[_i] = _e->Get(_i)->str(); } } else { _o->sync_task_ids.resize(0); } }
  { auto _e = node_path(); if (_e) { _o->node_path.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->node_path[_i] = _e->Get(_i)->str(); } } else { _o->node_path.resize(0); } }
  { auto _e = status(); if (_e) _o->status = _e->str(); }
  { auto _e = offset(); _o->offset = _e; }
}

inline ::flatbuffers::Offset<RB_Program_Task_Status> RB_Program_Task_Status::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RB_Program_Task_StatusT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRB_Program_Task_Status(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<RB_Program_Task_Status> CreateRB_Program_Task_Status(::flatbuffers::FlatBufferBuilder &_fbb, const RB_Program_Task_StatusT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const RB_Program_Task_StatusT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _task_id = _o->task_id.empty() ? 0 : _fbb.CreateString(_o->task_id);
  auto _program_id = _o->program_id.empty() ? 0 : _fbb.CreateString(_o->program_id);
  auto _sync_task_ids = _o->sync_task_ids.size() ? _fbb.CreateVectorOfStrings(_o->sync_task_ids) : 0;
  auto _node_path = _o->node_path.size() ? _fbb.CreateVectorOfStrings(_o->node_path) : 0;
  auto _status = _o->status.empty() ? 0 : _fbb.CreateString(_o->status);
  auto _offset = _o->offset;
  return program::CreateRB_Program_Task_Status(
      _fbb,
      _task_id,
      _program_id,
      _sync_task_ids,
      _node_path,
      _status,
      _offset);
}

inline RB_Program_Task_CheckpointT *RB_Program_Task_Checkpoint::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<RB_Program_Task_CheckpointT>(new RB_Program_Task_CheckpointT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RB_Program_Task_Checkpoint::UnPackTo(RB_Program_Task_CheckpointT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = task_id(); if (_e) _o->task_id = _e->str(); }
  { auto _e = program_id(); if (_e) _o->program_id = _e->str(); }
  { auto _e = sync_task_ids(); if (_e) { _o->sync_task_ids.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->sync_task_ids[_i] = _e->Get(_i)->str(); } } else { _o->sync_task_ids.resize(0); } }
  { auto _e = node_path(); if (_e) { _o->node_path.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->node_path[_i] = _e->Get(_i)->str(); } } else { _o->node_path.resize(0); } }
  { auto _e = offset(); _o->offset = _e; }
  { auto _e = status(); if (_e) _o->status = _e->str(); }
}

inline ::flatbuffers::Offset<RB_Program_Task_Checkpoint> RB_Program_Task_Checkpoint::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RB_Program_Task_CheckpointT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRB_Program_Task_Checkpoint(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<RB_Program_Task_Checkpoint> CreateRB_Program_Task_Checkpoint(::flatbuffers::FlatBufferBuilder &_fbb, const RB_Program_Task_CheckpointT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const RB_Program_Task_CheckpointT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _task_id = _o->task_id.empty() ? 0 : _fbb.CreateString(_o->task_id);
  auto _program_id = _o->program_id.empty() ? 0 : _fbb.CreateString(_o->program_id);
  auto _sync_task_ids = _o->sync_task_ids.size() ? _fbb.CreateVectorOfStrings(_o->sync_task_ids) : 0;
  auto _node_path = _o->node_path.size() ? _fbb.CreateVectorOfStrings(_o->node_path) : 0;
  auto _offset = _o->offset;
  auto _status = _o->status.empty() ? 0 : _fbb.CreateString(_o->status);
  return program::CreateRB_Program_Task_Checkpoint(
      _fbb,
      _task_id,
      _program_id,
      _sync_task_ids,
      _node_path,
      _offset,
      _status);
}

inline RB_Program_DialogT *RB_Program_Dialog::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<RB_Program_DialogT>(new RB_Program_DialogT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RB_Program_Dialog::UnPackTo(RB_Program_DialogT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = robot_model(); if (_e) _o->robot_model = _e->str(); }
  { auto _e = title(); if (_e) _o->title = _e->str(); }
  { auto _e = content(); if (_e) _o->content = _e->str(); }
}

inline ::flatbuffers::Offset<RB_Program_Dialog> RB_Program_Dialog::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RB_Program_DialogT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRB_Program_Dialog(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<RB_Program_Dialog> CreateRB_Program_Dialog(::flatbuffers::FlatBufferBuilder &_fbb, const RB_Program_DialogT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const RB_Program_DialogT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _robot_model = _o->robot_model.empty() ? 0 : _fbb.CreateString(_o->robot_model);
  auto _title = _o->title.empty() ? 0 : _fbb.CreateString(_o->title);
  auto _content = _o->content.empty() ? 0 : _fbb.CreateString(_o->content);
  return program::CreateRB_Program_Dialog(
      _fbb,
      _robot_model,
      _title,
      _content);
}

inline RB_Program_LogT *RB_Program_Log::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<RB_Program_LogT>(new RB_Program_LogT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RB_Program_Log::UnPackTo(RB_Program_LogT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = content(); if (_e) _o->content = _e->str(); }
  { auto _e = robot_model(); if (_e) _o->robot_model = _e->str(); }
  { auto _e = type(); _o->type = _e; }
}

inline ::flatbuffers::Offset<RB_Program_Log> RB_Program_Log::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RB_Program_LogT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRB_Program_Log(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<RB_Program_Log> CreateRB_Program_Log(::flatbuffers::FlatBufferBuilder &_fbb, const RB_Program_LogT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const RB_Program_LogT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _content = _o->content.empty() ? 0 : _fbb.CreateString(_o->content);
  auto _robot_model = _o->robot_model.empty() ? 0 : _fbb.CreateString(_o->robot_model);
  auto _type = _o->type;
  return program::CreateRB_Program_Log(
      _fbb,
      _content,
      _robot_model,
      _type);
}

inline Request_Program_At_StartT *Request_Program_At_Start::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Request_Program_At_StartT>(new Request_Program_At_StartT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Request_Program_At_Start::UnPackTo(Request_Program_At_StartT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = task_id(); if (_e) _o->task_id = _e->str(); }
}

inline ::flatbuffers::Offset<Request_Program_At_Start> Request_Program_At_Start::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Program_At_StartT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_Program_At_Start(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Request_Program_At_Start> CreateRequest_Program_At_Start(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Program_At_StartT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const Request_Program_At_StartT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _task_id = _o->task_id.empty() ? 0 : _fbb.CreateString(_o->task_id);
  return program::CreateRequest_Program_At_Start(
      _fbb,
      _task_id);
}

inline Request_Program_At_EndT *Request_Program_At_End::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Request_Program_At_EndT>(new Request_Program_At_EndT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Request_Program_At_End::UnPackTo(Request_Program_At_EndT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = task_id(); if (_e) _o->task_id = _e->str(); }
}

inline ::flatbuffers::Offset<Request_Program_At_End> Request_Program_At_End::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Program_At_EndT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_Program_At_End(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Request_Program_At_End> CreateRequest_Program_At_End(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Program_At_EndT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const Request_Program_At_EndT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _task_id = _o->task_id.empty() ? 0 : _fbb.CreateString(_o->task_id);
  return program::CreateRequest_Program_At_End(
      _fbb,
      _task_id);
}

inline Request_Update_Sub_Task_StateT *Request_Update_Sub_Task_State::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Request_Update_Sub_Task_StateT>(new Request_Update_Sub_Task_StateT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Request_Update_Sub_Task_State::UnPackTo(Request_Update_Sub_Task_StateT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = sub_task_id(); if (_e) _o->sub_task_id = _e->str(); }
  { auto _e = sub_task_type(); _o->sub_task_type = _e; }
  { auto _e = state(); _o->state = _e; }
}

inline ::flatbuffers::Offset<Request_Update_Sub_Task_State> Request_Update_Sub_Task_State::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Update_Sub_Task_StateT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_Update_Sub_Task_State(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Request_Update_Sub_Task_State> CreateRequest_Update_Sub_Task_State(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Update_Sub_Task_StateT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const Request_Update_Sub_Task_StateT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _sub_task_id = _o->sub_task_id.empty() ? 0 : _fbb.CreateString(_o->sub_task_id);
  auto _sub_task_type = _o->sub_task_type;
  auto _state = _o->state;
  return program::CreateRequest_Update_Sub_Task_State(
      _fbb,
      _sub_task_id,
      _sub_task_type,
      _state);
}

}  // namespace program

#endif  // FLATBUFFERS_GENERATED_PROGRAM_PROGRAM_H_
