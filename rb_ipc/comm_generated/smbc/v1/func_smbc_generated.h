// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_FUNCSMBC_SMBC_H_
#define FLATBUFFERS_GENERATED_FUNCSMBC_SMBC_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

namespace SMBC {

struct N_32_i;

struct Request_Read;
struct Request_ReadBuilder;
struct Request_ReadT;

struct Response_Read;
struct Response_ReadBuilder;
struct Response_ReadT;

struct Request_Write;
struct Request_WriteBuilder;
struct Request_WriteT;

struct Response_Write;
struct Response_WriteBuilder;
struct Response_WriteT;

struct Request_PrintInfo;
struct Request_PrintInfoBuilder;
struct Request_PrintInfoT;

struct Response_Functions;
struct Response_FunctionsBuilder;
struct Response_FunctionsT;

struct State_Log;
struct State_LogBuilder;
struct State_LogT;

struct State_Message;
struct State_MessageBuilder;
struct State_MessageT;

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) N_32_i FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t i_[32];

 public:
  N_32_i()
      : i_() {
  }
  N_32_i(::flatbuffers::span<const int32_t, 32> _i) {
    ::flatbuffers::CastToArray(i_).CopyFromSpan(_i);
  }
  const ::flatbuffers::Array<int32_t, 32> *i() const {
    return &::flatbuffers::CastToArray(i_);
  }
};
FLATBUFFERS_STRUCT_END(N_32_i, 128);

struct Request_ReadT : public ::flatbuffers::NativeTable {
  typedef Request_Read TableType;
  std::string issue_core{};
  std::string server_ip{};
  int32_t server_port = 0;
  int32_t function_code = 0;
  int32_t register_addr = 0;
  int32_t number_of_read = 0;
  int32_t timeout_ms = 0;
};

struct Request_Read FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Request_ReadT NativeTableType;
  typedef Request_ReadBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ISSUE_CORE = 4,
    VT_SERVER_IP = 6,
    VT_SERVER_PORT = 8,
    VT_FUNCTION_CODE = 10,
    VT_REGISTER_ADDR = 12,
    VT_NUMBER_OF_READ = 14,
    VT_TIMEOUT_MS = 16
  };
  const ::flatbuffers::String *issue_core() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ISSUE_CORE);
  }
  const ::flatbuffers::String *server_ip() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SERVER_IP);
  }
  int32_t server_port() const {
    return GetField<int32_t>(VT_SERVER_PORT, 0);
  }
  int32_t function_code() const {
    return GetField<int32_t>(VT_FUNCTION_CODE, 0);
  }
  int32_t register_addr() const {
    return GetField<int32_t>(VT_REGISTER_ADDR, 0);
  }
  int32_t number_of_read() const {
    return GetField<int32_t>(VT_NUMBER_OF_READ, 0);
  }
  int32_t timeout_ms() const {
    return GetField<int32_t>(VT_TIMEOUT_MS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ISSUE_CORE) &&
           verifier.VerifyString(issue_core()) &&
           VerifyOffset(verifier, VT_SERVER_IP) &&
           verifier.VerifyString(server_ip()) &&
           VerifyField<int32_t>(verifier, VT_SERVER_PORT, 4) &&
           VerifyField<int32_t>(verifier, VT_FUNCTION_CODE, 4) &&
           VerifyField<int32_t>(verifier, VT_REGISTER_ADDR, 4) &&
           VerifyField<int32_t>(verifier, VT_NUMBER_OF_READ, 4) &&
           VerifyField<int32_t>(verifier, VT_TIMEOUT_MS, 4) &&
           verifier.EndTable();
  }
  Request_ReadT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_ReadT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Request_Read> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Request_ReadT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_ReadBuilder {
  typedef Request_Read Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_issue_core(::flatbuffers::Offset<::flatbuffers::String> issue_core) {
    fbb_.AddOffset(Request_Read::VT_ISSUE_CORE, issue_core);
  }
  void add_server_ip(::flatbuffers::Offset<::flatbuffers::String> server_ip) {
    fbb_.AddOffset(Request_Read::VT_SERVER_IP, server_ip);
  }
  void add_server_port(int32_t server_port) {
    fbb_.AddElement<int32_t>(Request_Read::VT_SERVER_PORT, server_port, 0);
  }
  void add_function_code(int32_t function_code) {
    fbb_.AddElement<int32_t>(Request_Read::VT_FUNCTION_CODE, function_code, 0);
  }
  void add_register_addr(int32_t register_addr) {
    fbb_.AddElement<int32_t>(Request_Read::VT_REGISTER_ADDR, register_addr, 0);
  }
  void add_number_of_read(int32_t number_of_read) {
    fbb_.AddElement<int32_t>(Request_Read::VT_NUMBER_OF_READ, number_of_read, 0);
  }
  void add_timeout_ms(int32_t timeout_ms) {
    fbb_.AddElement<int32_t>(Request_Read::VT_TIMEOUT_MS, timeout_ms, 0);
  }
  explicit Request_ReadBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Request_Read> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Request_Read>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Request_Read> CreateRequest_Read(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> issue_core = 0,
    ::flatbuffers::Offset<::flatbuffers::String> server_ip = 0,
    int32_t server_port = 0,
    int32_t function_code = 0,
    int32_t register_addr = 0,
    int32_t number_of_read = 0,
    int32_t timeout_ms = 0) {
  Request_ReadBuilder builder_(_fbb);
  builder_.add_timeout_ms(timeout_ms);
  builder_.add_number_of_read(number_of_read);
  builder_.add_register_addr(register_addr);
  builder_.add_function_code(function_code);
  builder_.add_server_port(server_port);
  builder_.add_server_ip(server_ip);
  builder_.add_issue_core(issue_core);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Request_Read> CreateRequest_ReadDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *issue_core = nullptr,
    const char *server_ip = nullptr,
    int32_t server_port = 0,
    int32_t function_code = 0,
    int32_t register_addr = 0,
    int32_t number_of_read = 0,
    int32_t timeout_ms = 0) {
  auto issue_core__ = issue_core ? _fbb.CreateString(issue_core) : 0;
  auto server_ip__ = server_ip ? _fbb.CreateString(server_ip) : 0;
  return SMBC::CreateRequest_Read(
      _fbb,
      issue_core__,
      server_ip__,
      server_port,
      function_code,
      register_addr,
      number_of_read,
      timeout_ms);
}

::flatbuffers::Offset<Request_Read> CreateRequest_Read(::flatbuffers::FlatBufferBuilder &_fbb, const Request_ReadT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Response_ReadT : public ::flatbuffers::NativeTable {
  typedef Response_Read TableType;
  int32_t result = 0;
  int32_t payload_dlc = 0;
  std::unique_ptr<SMBC::N_32_i> payload{};
  Response_ReadT() = default;
  Response_ReadT(const Response_ReadT &o);
  Response_ReadT(Response_ReadT&&) FLATBUFFERS_NOEXCEPT = default;
  Response_ReadT &operator=(Response_ReadT o) FLATBUFFERS_NOEXCEPT;
};

struct Response_Read FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Response_ReadT NativeTableType;
  typedef Response_ReadBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4,
    VT_PAYLOAD_DLC = 6,
    VT_PAYLOAD = 8
  };
  int32_t result() const {
    return GetField<int32_t>(VT_RESULT, 0);
  }
  int32_t payload_dlc() const {
    return GetField<int32_t>(VT_PAYLOAD_DLC, 0);
  }
  const SMBC::N_32_i *payload() const {
    return GetStruct<const SMBC::N_32_i *>(VT_PAYLOAD);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RESULT, 4) &&
           VerifyField<int32_t>(verifier, VT_PAYLOAD_DLC, 4) &&
           VerifyField<SMBC::N_32_i>(verifier, VT_PAYLOAD, 4) &&
           verifier.EndTable();
  }
  Response_ReadT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Response_ReadT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Response_Read> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Response_ReadT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Response_ReadBuilder {
  typedef Response_Read Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(int32_t result) {
    fbb_.AddElement<int32_t>(Response_Read::VT_RESULT, result, 0);
  }
  void add_payload_dlc(int32_t payload_dlc) {
    fbb_.AddElement<int32_t>(Response_Read::VT_PAYLOAD_DLC, payload_dlc, 0);
  }
  void add_payload(const SMBC::N_32_i *payload) {
    fbb_.AddStruct(Response_Read::VT_PAYLOAD, payload);
  }
  explicit Response_ReadBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Response_Read> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Response_Read>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Response_Read> CreateResponse_Read(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t result = 0,
    int32_t payload_dlc = 0,
    const SMBC::N_32_i *payload = nullptr) {
  Response_ReadBuilder builder_(_fbb);
  builder_.add_payload(payload);
  builder_.add_payload_dlc(payload_dlc);
  builder_.add_result(result);
  return builder_.Finish();
}

::flatbuffers::Offset<Response_Read> CreateResponse_Read(::flatbuffers::FlatBufferBuilder &_fbb, const Response_ReadT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Request_WriteT : public ::flatbuffers::NativeTable {
  typedef Request_Write TableType;
  std::string issue_core{};
  std::string server_ip{};
  int32_t server_port = 0;
  int32_t function_code = 0;
  int32_t register_addr = 0;
  int32_t payload_dlc = 0;
  std::unique_ptr<SMBC::N_32_i> payload{};
  int32_t timeout_ms = 0;
  Request_WriteT() = default;
  Request_WriteT(const Request_WriteT &o);
  Request_WriteT(Request_WriteT&&) FLATBUFFERS_NOEXCEPT = default;
  Request_WriteT &operator=(Request_WriteT o) FLATBUFFERS_NOEXCEPT;
};

struct Request_Write FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Request_WriteT NativeTableType;
  typedef Request_WriteBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ISSUE_CORE = 4,
    VT_SERVER_IP = 6,
    VT_SERVER_PORT = 8,
    VT_FUNCTION_CODE = 10,
    VT_REGISTER_ADDR = 12,
    VT_PAYLOAD_DLC = 14,
    VT_PAYLOAD = 16,
    VT_TIMEOUT_MS = 18
  };
  const ::flatbuffers::String *issue_core() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ISSUE_CORE);
  }
  const ::flatbuffers::String *server_ip() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SERVER_IP);
  }
  int32_t server_port() const {
    return GetField<int32_t>(VT_SERVER_PORT, 0);
  }
  int32_t function_code() const {
    return GetField<int32_t>(VT_FUNCTION_CODE, 0);
  }
  int32_t register_addr() const {
    return GetField<int32_t>(VT_REGISTER_ADDR, 0);
  }
  int32_t payload_dlc() const {
    return GetField<int32_t>(VT_PAYLOAD_DLC, 0);
  }
  const SMBC::N_32_i *payload() const {
    return GetStruct<const SMBC::N_32_i *>(VT_PAYLOAD);
  }
  int32_t timeout_ms() const {
    return GetField<int32_t>(VT_TIMEOUT_MS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ISSUE_CORE) &&
           verifier.VerifyString(issue_core()) &&
           VerifyOffset(verifier, VT_SERVER_IP) &&
           verifier.VerifyString(server_ip()) &&
           VerifyField<int32_t>(verifier, VT_SERVER_PORT, 4) &&
           VerifyField<int32_t>(verifier, VT_FUNCTION_CODE, 4) &&
           VerifyField<int32_t>(verifier, VT_REGISTER_ADDR, 4) &&
           VerifyField<int32_t>(verifier, VT_PAYLOAD_DLC, 4) &&
           VerifyField<SMBC::N_32_i>(verifier, VT_PAYLOAD, 4) &&
           VerifyField<int32_t>(verifier, VT_TIMEOUT_MS, 4) &&
           verifier.EndTable();
  }
  Request_WriteT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_WriteT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Request_Write> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Request_WriteT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_WriteBuilder {
  typedef Request_Write Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_issue_core(::flatbuffers::Offset<::flatbuffers::String> issue_core) {
    fbb_.AddOffset(Request_Write::VT_ISSUE_CORE, issue_core);
  }
  void add_server_ip(::flatbuffers::Offset<::flatbuffers::String> server_ip) {
    fbb_.AddOffset(Request_Write::VT_SERVER_IP, server_ip);
  }
  void add_server_port(int32_t server_port) {
    fbb_.AddElement<int32_t>(Request_Write::VT_SERVER_PORT, server_port, 0);
  }
  void add_function_code(int32_t function_code) {
    fbb_.AddElement<int32_t>(Request_Write::VT_FUNCTION_CODE, function_code, 0);
  }
  void add_register_addr(int32_t register_addr) {
    fbb_.AddElement<int32_t>(Request_Write::VT_REGISTER_ADDR, register_addr, 0);
  }
  void add_payload_dlc(int32_t payload_dlc) {
    fbb_.AddElement<int32_t>(Request_Write::VT_PAYLOAD_DLC, payload_dlc, 0);
  }
  void add_payload(const SMBC::N_32_i *payload) {
    fbb_.AddStruct(Request_Write::VT_PAYLOAD, payload);
  }
  void add_timeout_ms(int32_t timeout_ms) {
    fbb_.AddElement<int32_t>(Request_Write::VT_TIMEOUT_MS, timeout_ms, 0);
  }
  explicit Request_WriteBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Request_Write> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Request_Write>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Request_Write> CreateRequest_Write(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> issue_core = 0,
    ::flatbuffers::Offset<::flatbuffers::String> server_ip = 0,
    int32_t server_port = 0,
    int32_t function_code = 0,
    int32_t register_addr = 0,
    int32_t payload_dlc = 0,
    const SMBC::N_32_i *payload = nullptr,
    int32_t timeout_ms = 0) {
  Request_WriteBuilder builder_(_fbb);
  builder_.add_timeout_ms(timeout_ms);
  builder_.add_payload(payload);
  builder_.add_payload_dlc(payload_dlc);
  builder_.add_register_addr(register_addr);
  builder_.add_function_code(function_code);
  builder_.add_server_port(server_port);
  builder_.add_server_ip(server_ip);
  builder_.add_issue_core(issue_core);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Request_Write> CreateRequest_WriteDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *issue_core = nullptr,
    const char *server_ip = nullptr,
    int32_t server_port = 0,
    int32_t function_code = 0,
    int32_t register_addr = 0,
    int32_t payload_dlc = 0,
    const SMBC::N_32_i *payload = nullptr,
    int32_t timeout_ms = 0) {
  auto issue_core__ = issue_core ? _fbb.CreateString(issue_core) : 0;
  auto server_ip__ = server_ip ? _fbb.CreateString(server_ip) : 0;
  return SMBC::CreateRequest_Write(
      _fbb,
      issue_core__,
      server_ip__,
      server_port,
      function_code,
      register_addr,
      payload_dlc,
      payload,
      timeout_ms);
}

::flatbuffers::Offset<Request_Write> CreateRequest_Write(::flatbuffers::FlatBufferBuilder &_fbb, const Request_WriteT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Response_WriteT : public ::flatbuffers::NativeTable {
  typedef Response_Write TableType;
  int32_t result = 0;
};

struct Response_Write FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Response_WriteT NativeTableType;
  typedef Response_WriteBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4
  };
  int32_t result() const {
    return GetField<int32_t>(VT_RESULT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RESULT, 4) &&
           verifier.EndTable();
  }
  Response_WriteT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Response_WriteT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Response_Write> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Response_WriteT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Response_WriteBuilder {
  typedef Response_Write Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(int32_t result) {
    fbb_.AddElement<int32_t>(Response_Write::VT_RESULT, result, 0);
  }
  explicit Response_WriteBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Response_Write> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Response_Write>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Response_Write> CreateResponse_Write(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t result = 0) {
  Response_WriteBuilder builder_(_fbb);
  builder_.add_result(result);
  return builder_.Finish();
}

::flatbuffers::Offset<Response_Write> CreateResponse_Write(::flatbuffers::FlatBufferBuilder &_fbb, const Response_WriteT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Request_PrintInfoT : public ::flatbuffers::NativeTable {
  typedef Request_PrintInfo TableType;
};

struct Request_PrintInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Request_PrintInfoT NativeTableType;
  typedef Request_PrintInfoBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  Request_PrintInfoT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_PrintInfoT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Request_PrintInfo> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Request_PrintInfoT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_PrintInfoBuilder {
  typedef Request_PrintInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit Request_PrintInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Request_PrintInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Request_PrintInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Request_PrintInfo> CreateRequest_PrintInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  Request_PrintInfoBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<Request_PrintInfo> CreateRequest_PrintInfo(::flatbuffers::FlatBufferBuilder &_fbb, const Request_PrintInfoT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Response_FunctionsT : public ::flatbuffers::NativeTable {
  typedef Response_Functions TableType;
  int32_t return_value = 0;
};

struct Response_Functions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Response_FunctionsT NativeTableType;
  typedef Response_FunctionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RETURN_VALUE = 4
  };
  int32_t return_value() const {
    return GetField<int32_t>(VT_RETURN_VALUE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RETURN_VALUE, 4) &&
           verifier.EndTable();
  }
  Response_FunctionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Response_FunctionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Response_Functions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Response_FunctionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Response_FunctionsBuilder {
  typedef Response_Functions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_return_value(int32_t return_value) {
    fbb_.AddElement<int32_t>(Response_Functions::VT_RETURN_VALUE, return_value, 0);
  }
  explicit Response_FunctionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Response_Functions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Response_Functions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Response_Functions> CreateResponse_Functions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t return_value = 0) {
  Response_FunctionsBuilder builder_(_fbb);
  builder_.add_return_value(return_value);
  return builder_.Finish();
}

::flatbuffers::Offset<Response_Functions> CreateResponse_Functions(::flatbuffers::FlatBufferBuilder &_fbb, const Response_FunctionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct State_LogT : public ::flatbuffers::NativeTable {
  typedef State_Log TableType;
  int32_t level = 0;
  std::string timestamp{};
  std::string contents{};
};

struct State_Log FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef State_LogT NativeTableType;
  typedef State_LogBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LEVEL = 4,
    VT_TIMESTAMP = 6,
    VT_CONTENTS = 8
  };
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  const ::flatbuffers::String *timestamp() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TIMESTAMP);
  }
  const ::flatbuffers::String *contents() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CONTENTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_LEVEL, 4) &&
           VerifyOffset(verifier, VT_TIMESTAMP) &&
           verifier.VerifyString(timestamp()) &&
           VerifyOffset(verifier, VT_CONTENTS) &&
           verifier.VerifyString(contents()) &&
           verifier.EndTable();
  }
  State_LogT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(State_LogT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<State_Log> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const State_LogT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct State_LogBuilder {
  typedef State_Log Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(State_Log::VT_LEVEL, level, 0);
  }
  void add_timestamp(::flatbuffers::Offset<::flatbuffers::String> timestamp) {
    fbb_.AddOffset(State_Log::VT_TIMESTAMP, timestamp);
  }
  void add_contents(::flatbuffers::Offset<::flatbuffers::String> contents) {
    fbb_.AddOffset(State_Log::VT_CONTENTS, contents);
  }
  explicit State_LogBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<State_Log> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<State_Log>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<State_Log> CreateState_Log(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t level = 0,
    ::flatbuffers::Offset<::flatbuffers::String> timestamp = 0,
    ::flatbuffers::Offset<::flatbuffers::String> contents = 0) {
  State_LogBuilder builder_(_fbb);
  builder_.add_contents(contents);
  builder_.add_timestamp(timestamp);
  builder_.add_level(level);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<State_Log> CreateState_LogDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t level = 0,
    const char *timestamp = nullptr,
    const char *contents = nullptr) {
  auto timestamp__ = timestamp ? _fbb.CreateString(timestamp) : 0;
  auto contents__ = contents ? _fbb.CreateString(contents) : 0;
  return SMBC::CreateState_Log(
      _fbb,
      level,
      timestamp__,
      contents__);
}

::flatbuffers::Offset<State_Log> CreateState_Log(::flatbuffers::FlatBufferBuilder &_fbb, const State_LogT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct State_MessageT : public ::flatbuffers::NativeTable {
  typedef State_Message TableType;
  int32_t type = 0;
  int32_t code = 0;
  std::string sub_str{};
};

struct State_Message FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef State_MessageT NativeTableType;
  typedef State_MessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_CODE = 6,
    VT_SUB_STR = 8
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  int32_t code() const {
    return GetField<int32_t>(VT_CODE, 0);
  }
  const ::flatbuffers::String *sub_str() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SUB_STR);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE, 4) &&
           VerifyField<int32_t>(verifier, VT_CODE, 4) &&
           VerifyOffset(verifier, VT_SUB_STR) &&
           verifier.VerifyString(sub_str()) &&
           verifier.EndTable();
  }
  State_MessageT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(State_MessageT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<State_Message> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const State_MessageT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct State_MessageBuilder {
  typedef State_Message Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(State_Message::VT_TYPE, type, 0);
  }
  void add_code(int32_t code) {
    fbb_.AddElement<int32_t>(State_Message::VT_CODE, code, 0);
  }
  void add_sub_str(::flatbuffers::Offset<::flatbuffers::String> sub_str) {
    fbb_.AddOffset(State_Message::VT_SUB_STR, sub_str);
  }
  explicit State_MessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<State_Message> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<State_Message>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<State_Message> CreateState_Message(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 0,
    int32_t code = 0,
    ::flatbuffers::Offset<::flatbuffers::String> sub_str = 0) {
  State_MessageBuilder builder_(_fbb);
  builder_.add_sub_str(sub_str);
  builder_.add_code(code);
  builder_.add_type(type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<State_Message> CreateState_MessageDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 0,
    int32_t code = 0,
    const char *sub_str = nullptr) {
  auto sub_str__ = sub_str ? _fbb.CreateString(sub_str) : 0;
  return SMBC::CreateState_Message(
      _fbb,
      type,
      code,
      sub_str__);
}

::flatbuffers::Offset<State_Message> CreateState_Message(::flatbuffers::FlatBufferBuilder &_fbb, const State_MessageT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline Request_ReadT *Request_Read::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Request_ReadT>(new Request_ReadT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Request_Read::UnPackTo(Request_ReadT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = issue_core(); if (_e) _o->issue_core = _e->str(); }
  { auto _e = server_ip(); if (_e) _o->server_ip = _e->str(); }
  { auto _e = server_port(); _o->server_port = _e; }
  { auto _e = function_code(); _o->function_code = _e; }
  { auto _e = register_addr(); _o->register_addr = _e; }
  { auto _e = number_of_read(); _o->number_of_read = _e; }
  { auto _e = timeout_ms(); _o->timeout_ms = _e; }
}

inline ::flatbuffers::Offset<Request_Read> Request_Read::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Request_ReadT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_Read(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Request_Read> CreateRequest_Read(::flatbuffers::FlatBufferBuilder &_fbb, const Request_ReadT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const Request_ReadT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _issue_core = _o->issue_core.empty() ? 0 : _fbb.CreateString(_o->issue_core);
  auto _server_ip = _o->server_ip.empty() ? 0 : _fbb.CreateString(_o->server_ip);
  auto _server_port = _o->server_port;
  auto _function_code = _o->function_code;
  auto _register_addr = _o->register_addr;
  auto _number_of_read = _o->number_of_read;
  auto _timeout_ms = _o->timeout_ms;
  return SMBC::CreateRequest_Read(
      _fbb,
      _issue_core,
      _server_ip,
      _server_port,
      _function_code,
      _register_addr,
      _number_of_read,
      _timeout_ms);
}

inline Response_ReadT::Response_ReadT(const Response_ReadT &o)
      : result(o.result),
        payload_dlc(o.payload_dlc),
        payload((o.payload) ? new SMBC::N_32_i(*o.payload) : nullptr) {
}

inline Response_ReadT &Response_ReadT::operator=(Response_ReadT o) FLATBUFFERS_NOEXCEPT {
  std::swap(result, o.result);
  std::swap(payload_dlc, o.payload_dlc);
  std::swap(payload, o.payload);
  return *this;
}

inline Response_ReadT *Response_Read::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Response_ReadT>(new Response_ReadT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Response_Read::UnPackTo(Response_ReadT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = result(); _o->result = _e; }
  { auto _e = payload_dlc(); _o->payload_dlc = _e; }
  { auto _e = payload(); if (_e) _o->payload = std::unique_ptr<SMBC::N_32_i>(new SMBC::N_32_i(*_e)); }
}

inline ::flatbuffers::Offset<Response_Read> Response_Read::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Response_ReadT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateResponse_Read(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Response_Read> CreateResponse_Read(::flatbuffers::FlatBufferBuilder &_fbb, const Response_ReadT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const Response_ReadT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _result = _o->result;
  auto _payload_dlc = _o->payload_dlc;
  auto _payload = _o->payload ? _o->payload.get() : nullptr;
  return SMBC::CreateResponse_Read(
      _fbb,
      _result,
      _payload_dlc,
      _payload);
}

inline Request_WriteT::Request_WriteT(const Request_WriteT &o)
      : issue_core(o.issue_core),
        server_ip(o.server_ip),
        server_port(o.server_port),
        function_code(o.function_code),
        register_addr(o.register_addr),
        payload_dlc(o.payload_dlc),
        payload((o.payload) ? new SMBC::N_32_i(*o.payload) : nullptr),
        timeout_ms(o.timeout_ms) {
}

inline Request_WriteT &Request_WriteT::operator=(Request_WriteT o) FLATBUFFERS_NOEXCEPT {
  std::swap(issue_core, o.issue_core);
  std::swap(server_ip, o.server_ip);
  std::swap(server_port, o.server_port);
  std::swap(function_code, o.function_code);
  std::swap(register_addr, o.register_addr);
  std::swap(payload_dlc, o.payload_dlc);
  std::swap(payload, o.payload);
  std::swap(timeout_ms, o.timeout_ms);
  return *this;
}

inline Request_WriteT *Request_Write::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Request_WriteT>(new Request_WriteT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Request_Write::UnPackTo(Request_WriteT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = issue_core(); if (_e) _o->issue_core = _e->str(); }
  { auto _e = server_ip(); if (_e) _o->server_ip = _e->str(); }
  { auto _e = server_port(); _o->server_port = _e; }
  { auto _e = function_code(); _o->function_code = _e; }
  { auto _e = register_addr(); _o->register_addr = _e; }
  { auto _e = payload_dlc(); _o->payload_dlc = _e; }
  { auto _e = payload(); if (_e) _o->payload = std::unique_ptr<SMBC::N_32_i>(new SMBC::N_32_i(*_e)); }
  { auto _e = timeout_ms(); _o->timeout_ms = _e; }
}

inline ::flatbuffers::Offset<Request_Write> Request_Write::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Request_WriteT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_Write(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Request_Write> CreateRequest_Write(::flatbuffers::FlatBufferBuilder &_fbb, const Request_WriteT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const Request_WriteT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _issue_core = _o->issue_core.empty() ? 0 : _fbb.CreateString(_o->issue_core);
  auto _server_ip = _o->server_ip.empty() ? 0 : _fbb.CreateString(_o->server_ip);
  auto _server_port = _o->server_port;
  auto _function_code = _o->function_code;
  auto _register_addr = _o->register_addr;
  auto _payload_dlc = _o->payload_dlc;
  auto _payload = _o->payload ? _o->payload.get() : nullptr;
  auto _timeout_ms = _o->timeout_ms;
  return SMBC::CreateRequest_Write(
      _fbb,
      _issue_core,
      _server_ip,
      _server_port,
      _function_code,
      _register_addr,
      _payload_dlc,
      _payload,
      _timeout_ms);
}

inline Response_WriteT *Response_Write::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Response_WriteT>(new Response_WriteT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Response_Write::UnPackTo(Response_WriteT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = result(); _o->result = _e; }
}

inline ::flatbuffers::Offset<Response_Write> Response_Write::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Response_WriteT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateResponse_Write(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Response_Write> CreateResponse_Write(::flatbuffers::FlatBufferBuilder &_fbb, const Response_WriteT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const Response_WriteT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _result = _o->result;
  return SMBC::CreateResponse_Write(
      _fbb,
      _result);
}

inline Request_PrintInfoT *Request_PrintInfo::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Request_PrintInfoT>(new Request_PrintInfoT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Request_PrintInfo::UnPackTo(Request_PrintInfoT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<Request_PrintInfo> Request_PrintInfo::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Request_PrintInfoT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_PrintInfo(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Request_PrintInfo> CreateRequest_PrintInfo(::flatbuffers::FlatBufferBuilder &_fbb, const Request_PrintInfoT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const Request_PrintInfoT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return SMBC::CreateRequest_PrintInfo(
      _fbb);
}

inline Response_FunctionsT *Response_Functions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Response_FunctionsT>(new Response_FunctionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Response_Functions::UnPackTo(Response_FunctionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = return_value(); _o->return_value = _e; }
}

inline ::flatbuffers::Offset<Response_Functions> Response_Functions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Response_FunctionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateResponse_Functions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Response_Functions> CreateResponse_Functions(::flatbuffers::FlatBufferBuilder &_fbb, const Response_FunctionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const Response_FunctionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _return_value = _o->return_value;
  return SMBC::CreateResponse_Functions(
      _fbb,
      _return_value);
}

inline State_LogT *State_Log::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<State_LogT>(new State_LogT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void State_Log::UnPackTo(State_LogT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = level(); _o->level = _e; }
  { auto _e = timestamp(); if (_e) _o->timestamp = _e->str(); }
  { auto _e = contents(); if (_e) _o->contents = _e->str(); }
}

inline ::flatbuffers::Offset<State_Log> State_Log::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const State_LogT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateState_Log(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<State_Log> CreateState_Log(::flatbuffers::FlatBufferBuilder &_fbb, const State_LogT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const State_LogT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _level = _o->level;
  auto _timestamp = _o->timestamp.empty() ? 0 : _fbb.CreateString(_o->timestamp);
  auto _contents = _o->contents.empty() ? 0 : _fbb.CreateString(_o->contents);
  return SMBC::CreateState_Log(
      _fbb,
      _level,
      _timestamp,
      _contents);
}

inline State_MessageT *State_Message::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<State_MessageT>(new State_MessageT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void State_Message::UnPackTo(State_MessageT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; }
  { auto _e = code(); _o->code = _e; }
  { auto _e = sub_str(); if (_e) _o->sub_str = _e->str(); }
}

inline ::flatbuffers::Offset<State_Message> State_Message::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const State_MessageT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateState_Message(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<State_Message> CreateState_Message(::flatbuffers::FlatBufferBuilder &_fbb, const State_MessageT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const State_MessageT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _code = _o->code;
  auto _sub_str = _o->sub_str.empty() ? 0 : _fbb.CreateString(_o->sub_str);
  return SMBC::CreateState_Message(
      _fbb,
      _type,
      _code,
      _sub_str);
}

}  // namespace SMBC

#endif  // FLATBUFFERS_GENERATED_FUNCSMBC_SMBC_H_
