// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_STATELOG_IPC_H_
#define FLATBUFFERS_GENERATED_STATELOG_IPC_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

namespace IPC {

struct State_Log;
struct State_LogBuilder;
struct State_LogT;

struct State_LogT : public ::flatbuffers::NativeTable {
  typedef State_Log TableType;
  int32_t level = 0;
  std::string timestamp{};
  std::string contents{};
};

struct State_Log FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef State_LogT NativeTableType;
  typedef State_LogBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LEVEL = 4,
    VT_TIMESTAMP = 6,
    VT_CONTENTS = 8
  };
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  const ::flatbuffers::String *timestamp() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TIMESTAMP);
  }
  const ::flatbuffers::String *contents() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CONTENTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_LEVEL, 4) &&
           VerifyOffset(verifier, VT_TIMESTAMP) &&
           verifier.VerifyString(timestamp()) &&
           VerifyOffset(verifier, VT_CONTENTS) &&
           verifier.VerifyString(contents()) &&
           verifier.EndTable();
  }
  State_LogT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(State_LogT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<State_Log> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const State_LogT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct State_LogBuilder {
  typedef State_Log Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(State_Log::VT_LEVEL, level, 0);
  }
  void add_timestamp(::flatbuffers::Offset<::flatbuffers::String> timestamp) {
    fbb_.AddOffset(State_Log::VT_TIMESTAMP, timestamp);
  }
  void add_contents(::flatbuffers::Offset<::flatbuffers::String> contents) {
    fbb_.AddOffset(State_Log::VT_CONTENTS, contents);
  }
  explicit State_LogBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<State_Log> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<State_Log>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<State_Log> CreateState_Log(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t level = 0,
    ::flatbuffers::Offset<::flatbuffers::String> timestamp = 0,
    ::flatbuffers::Offset<::flatbuffers::String> contents = 0) {
  State_LogBuilder builder_(_fbb);
  builder_.add_contents(contents);
  builder_.add_timestamp(timestamp);
  builder_.add_level(level);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<State_Log> CreateState_LogDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t level = 0,
    const char *timestamp = nullptr,
    const char *contents = nullptr) {
  auto timestamp__ = timestamp ? _fbb.CreateString(timestamp) : 0;
  auto contents__ = contents ? _fbb.CreateString(contents) : 0;
  return IPC::CreateState_Log(
      _fbb,
      level,
      timestamp__,
      contents__);
}

::flatbuffers::Offset<State_Log> CreateState_Log(::flatbuffers::FlatBufferBuilder &_fbb, const State_LogT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline State_LogT *State_Log::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<State_LogT>(new State_LogT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void State_Log::UnPackTo(State_LogT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = level(); _o->level = _e; }
  { auto _e = timestamp(); if (_e) _o->timestamp = _e->str(); }
  { auto _e = contents(); if (_e) _o->contents = _e->str(); }
}

inline ::flatbuffers::Offset<State_Log> State_Log::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const State_LogT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateState_Log(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<State_Log> CreateState_Log(::flatbuffers::FlatBufferBuilder &_fbb, const State_LogT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const State_LogT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _level = _o->level;
  auto _timestamp = _o->timestamp.empty() ? 0 : _fbb.CreateString(_o->timestamp);
  auto _contents = _o->contents.empty() ? 0 : _fbb.CreateString(_o->contents);
  return IPC::CreateState_Log(
      _fbb,
      _level,
      _timestamp,
      _contents);
}

inline const IPC::State_Log *GetState_Log(const void *buf) {
  return ::flatbuffers::GetRoot<IPC::State_Log>(buf);
}

inline const IPC::State_Log *GetSizePrefixedState_Log(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<IPC::State_Log>(buf);
}

inline bool VerifyState_LogBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<IPC::State_Log>(nullptr);
}

inline bool VerifySizePrefixedState_LogBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<IPC::State_Log>(nullptr);
}

inline void FinishState_LogBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<IPC::State_Log> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedState_LogBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<IPC::State_Log> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<IPC::State_LogT> UnPackState_Log(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<IPC::State_LogT>(GetState_Log(buf)->UnPack(res));
}

inline std::unique_ptr<IPC::State_LogT> UnPackSizePrefixedState_Log(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<IPC::State_LogT>(GetSizePrefixedState_Log(buf)->UnPack(res));
}

}  // namespace IPC

#endif  // FLATBUFFERS_GENERATED_STATELOG_IPC_H_
