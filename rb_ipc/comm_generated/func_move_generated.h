// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_FUNCMOVE_IPC_H_
#define FLATBUFFERS_GENERATED_FUNCMOVE_IPC_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

#include "common_struct_generated.h"
#include "func_return_generated.h"

namespace IPC {

struct Request_Move_SmoothJogJ;
struct Request_Move_SmoothJogJBuilder;
struct Request_Move_SmoothJogJT;

struct Request_Move_SmoothJogL;
struct Request_Move_SmoothJogLBuilder;
struct Request_Move_SmoothJogLT;

struct Request_Move_SmoothJogStop;
struct Request_Move_SmoothJogStopBuilder;
struct Request_Move_SmoothJogStopT;

struct Request_Move_TickJogJ;
struct Request_Move_TickJogJBuilder;
struct Request_Move_TickJogJT;

struct Request_Move_TickJogL;
struct Request_Move_TickJogLBuilder;
struct Request_Move_TickJogLT;

struct Request_Move_J;
struct Request_Move_JBuilder;
struct Request_Move_JT;

struct Request_Move_L;
struct Request_Move_LBuilder;
struct Request_Move_LT;

struct Request_Move_JB_CLR;
struct Request_Move_JB_CLRBuilder;
struct Request_Move_JB_CLRT;

struct Request_Move_JB_ADD;
struct Request_Move_JB_ADDBuilder;
struct Request_Move_JB_ADDT;

struct Request_Move_JB_RUN;
struct Request_Move_JB_RUNBuilder;
struct Request_Move_JB_RUNT;

struct Request_Move_LB_CLR;
struct Request_Move_LB_CLRBuilder;
struct Request_Move_LB_CLRT;

struct Request_Move_LB_ADD;
struct Request_Move_LB_ADDBuilder;
struct Request_Move_LB_ADDT;

struct Request_Move_LB_RUN;
struct Request_Move_LB_RUNBuilder;
struct Request_Move_LB_RUNT;

struct Request_Move_XB_CLR;
struct Request_Move_XB_CLRBuilder;
struct Request_Move_XB_CLRT;

struct Request_Move_XB_ADD;
struct Request_Move_XB_ADDBuilder;
struct Request_Move_XB_ADDT;

struct Request_Move_XB_RUN;
struct Request_Move_XB_RUNBuilder;
struct Request_Move_XB_RUNT;

struct Request_Move_SmoothJogJT : public ::flatbuffers::NativeTable {
  typedef Request_Move_SmoothJogJ TableType;
  std::unique_ptr<IPC::MoveInput_TargetT> target{};
  Request_Move_SmoothJogJT() = default;
  Request_Move_SmoothJogJT(const Request_Move_SmoothJogJT &o);
  Request_Move_SmoothJogJT(Request_Move_SmoothJogJT&&) FLATBUFFERS_NOEXCEPT = default;
  Request_Move_SmoothJogJT &operator=(Request_Move_SmoothJogJT o) FLATBUFFERS_NOEXCEPT;
};

struct Request_Move_SmoothJogJ FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Request_Move_SmoothJogJT NativeTableType;
  typedef Request_Move_SmoothJogJBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TARGET = 4
  };
  const IPC::MoveInput_Target *target() const {
    return GetPointer<const IPC::MoveInput_Target *>(VT_TARGET);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TARGET) &&
           verifier.VerifyTable(target()) &&
           verifier.EndTable();
  }
  Request_Move_SmoothJogJT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_Move_SmoothJogJT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Request_Move_SmoothJogJ> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Move_SmoothJogJT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_Move_SmoothJogJBuilder {
  typedef Request_Move_SmoothJogJ Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_target(::flatbuffers::Offset<IPC::MoveInput_Target> target) {
    fbb_.AddOffset(Request_Move_SmoothJogJ::VT_TARGET, target);
  }
  explicit Request_Move_SmoothJogJBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Request_Move_SmoothJogJ> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Request_Move_SmoothJogJ>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Request_Move_SmoothJogJ> CreateRequest_Move_SmoothJogJ(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<IPC::MoveInput_Target> target = 0) {
  Request_Move_SmoothJogJBuilder builder_(_fbb);
  builder_.add_target(target);
  return builder_.Finish();
}

::flatbuffers::Offset<Request_Move_SmoothJogJ> CreateRequest_Move_SmoothJogJ(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Move_SmoothJogJT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Request_Move_SmoothJogLT : public ::flatbuffers::NativeTable {
  typedef Request_Move_SmoothJogL TableType;
  std::unique_ptr<IPC::MoveInput_TargetT> target{};
  Request_Move_SmoothJogLT() = default;
  Request_Move_SmoothJogLT(const Request_Move_SmoothJogLT &o);
  Request_Move_SmoothJogLT(Request_Move_SmoothJogLT&&) FLATBUFFERS_NOEXCEPT = default;
  Request_Move_SmoothJogLT &operator=(Request_Move_SmoothJogLT o) FLATBUFFERS_NOEXCEPT;
};

struct Request_Move_SmoothJogL FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Request_Move_SmoothJogLT NativeTableType;
  typedef Request_Move_SmoothJogLBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TARGET = 4
  };
  const IPC::MoveInput_Target *target() const {
    return GetPointer<const IPC::MoveInput_Target *>(VT_TARGET);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TARGET) &&
           verifier.VerifyTable(target()) &&
           verifier.EndTable();
  }
  Request_Move_SmoothJogLT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_Move_SmoothJogLT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Request_Move_SmoothJogL> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Move_SmoothJogLT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_Move_SmoothJogLBuilder {
  typedef Request_Move_SmoothJogL Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_target(::flatbuffers::Offset<IPC::MoveInput_Target> target) {
    fbb_.AddOffset(Request_Move_SmoothJogL::VT_TARGET, target);
  }
  explicit Request_Move_SmoothJogLBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Request_Move_SmoothJogL> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Request_Move_SmoothJogL>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Request_Move_SmoothJogL> CreateRequest_Move_SmoothJogL(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<IPC::MoveInput_Target> target = 0) {
  Request_Move_SmoothJogLBuilder builder_(_fbb);
  builder_.add_target(target);
  return builder_.Finish();
}

::flatbuffers::Offset<Request_Move_SmoothJogL> CreateRequest_Move_SmoothJogL(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Move_SmoothJogLT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Request_Move_SmoothJogStopT : public ::flatbuffers::NativeTable {
  typedef Request_Move_SmoothJogStop TableType;
  float stoptime = 0.0f;
};

struct Request_Move_SmoothJogStop FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Request_Move_SmoothJogStopT NativeTableType;
  typedef Request_Move_SmoothJogStopBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STOPTIME = 4
  };
  float stoptime() const {
    return GetField<float>(VT_STOPTIME, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_STOPTIME, 4) &&
           verifier.EndTable();
  }
  Request_Move_SmoothJogStopT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_Move_SmoothJogStopT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Request_Move_SmoothJogStop> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Move_SmoothJogStopT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_Move_SmoothJogStopBuilder {
  typedef Request_Move_SmoothJogStop Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_stoptime(float stoptime) {
    fbb_.AddElement<float>(Request_Move_SmoothJogStop::VT_STOPTIME, stoptime, 0.0f);
  }
  explicit Request_Move_SmoothJogStopBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Request_Move_SmoothJogStop> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Request_Move_SmoothJogStop>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Request_Move_SmoothJogStop> CreateRequest_Move_SmoothJogStop(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float stoptime = 0.0f) {
  Request_Move_SmoothJogStopBuilder builder_(_fbb);
  builder_.add_stoptime(stoptime);
  return builder_.Finish();
}

::flatbuffers::Offset<Request_Move_SmoothJogStop> CreateRequest_Move_SmoothJogStop(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Move_SmoothJogStopT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Request_Move_TickJogJT : public ::flatbuffers::NativeTable {
  typedef Request_Move_TickJogJ TableType;
  std::unique_ptr<IPC::MoveInput_TargetT> target{};
  std::unique_ptr<IPC::MoveInput_SpeedT> speed{};
  Request_Move_TickJogJT() = default;
  Request_Move_TickJogJT(const Request_Move_TickJogJT &o);
  Request_Move_TickJogJT(Request_Move_TickJogJT&&) FLATBUFFERS_NOEXCEPT = default;
  Request_Move_TickJogJT &operator=(Request_Move_TickJogJT o) FLATBUFFERS_NOEXCEPT;
};

struct Request_Move_TickJogJ FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Request_Move_TickJogJT NativeTableType;
  typedef Request_Move_TickJogJBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TARGET = 4,
    VT_SPEED = 6
  };
  const IPC::MoveInput_Target *target() const {
    return GetPointer<const IPC::MoveInput_Target *>(VT_TARGET);
  }
  const IPC::MoveInput_Speed *speed() const {
    return GetPointer<const IPC::MoveInput_Speed *>(VT_SPEED);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TARGET) &&
           verifier.VerifyTable(target()) &&
           VerifyOffset(verifier, VT_SPEED) &&
           verifier.VerifyTable(speed()) &&
           verifier.EndTable();
  }
  Request_Move_TickJogJT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_Move_TickJogJT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Request_Move_TickJogJ> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Move_TickJogJT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_Move_TickJogJBuilder {
  typedef Request_Move_TickJogJ Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_target(::flatbuffers::Offset<IPC::MoveInput_Target> target) {
    fbb_.AddOffset(Request_Move_TickJogJ::VT_TARGET, target);
  }
  void add_speed(::flatbuffers::Offset<IPC::MoveInput_Speed> speed) {
    fbb_.AddOffset(Request_Move_TickJogJ::VT_SPEED, speed);
  }
  explicit Request_Move_TickJogJBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Request_Move_TickJogJ> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Request_Move_TickJogJ>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Request_Move_TickJogJ> CreateRequest_Move_TickJogJ(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<IPC::MoveInput_Target> target = 0,
    ::flatbuffers::Offset<IPC::MoveInput_Speed> speed = 0) {
  Request_Move_TickJogJBuilder builder_(_fbb);
  builder_.add_speed(speed);
  builder_.add_target(target);
  return builder_.Finish();
}

::flatbuffers::Offset<Request_Move_TickJogJ> CreateRequest_Move_TickJogJ(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Move_TickJogJT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Request_Move_TickJogLT : public ::flatbuffers::NativeTable {
  typedef Request_Move_TickJogL TableType;
  std::unique_ptr<IPC::MoveInput_TargetT> target{};
  std::unique_ptr<IPC::MoveInput_SpeedT> speed{};
  Request_Move_TickJogLT() = default;
  Request_Move_TickJogLT(const Request_Move_TickJogLT &o);
  Request_Move_TickJogLT(Request_Move_TickJogLT&&) FLATBUFFERS_NOEXCEPT = default;
  Request_Move_TickJogLT &operator=(Request_Move_TickJogLT o) FLATBUFFERS_NOEXCEPT;
};

struct Request_Move_TickJogL FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Request_Move_TickJogLT NativeTableType;
  typedef Request_Move_TickJogLBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TARGET = 4,
    VT_SPEED = 6
  };
  const IPC::MoveInput_Target *target() const {
    return GetPointer<const IPC::MoveInput_Target *>(VT_TARGET);
  }
  const IPC::MoveInput_Speed *speed() const {
    return GetPointer<const IPC::MoveInput_Speed *>(VT_SPEED);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TARGET) &&
           verifier.VerifyTable(target()) &&
           VerifyOffset(verifier, VT_SPEED) &&
           verifier.VerifyTable(speed()) &&
           verifier.EndTable();
  }
  Request_Move_TickJogLT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_Move_TickJogLT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Request_Move_TickJogL> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Move_TickJogLT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_Move_TickJogLBuilder {
  typedef Request_Move_TickJogL Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_target(::flatbuffers::Offset<IPC::MoveInput_Target> target) {
    fbb_.AddOffset(Request_Move_TickJogL::VT_TARGET, target);
  }
  void add_speed(::flatbuffers::Offset<IPC::MoveInput_Speed> speed) {
    fbb_.AddOffset(Request_Move_TickJogL::VT_SPEED, speed);
  }
  explicit Request_Move_TickJogLBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Request_Move_TickJogL> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Request_Move_TickJogL>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Request_Move_TickJogL> CreateRequest_Move_TickJogL(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<IPC::MoveInput_Target> target = 0,
    ::flatbuffers::Offset<IPC::MoveInput_Speed> speed = 0) {
  Request_Move_TickJogLBuilder builder_(_fbb);
  builder_.add_speed(speed);
  builder_.add_target(target);
  return builder_.Finish();
}

::flatbuffers::Offset<Request_Move_TickJogL> CreateRequest_Move_TickJogL(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Move_TickJogLT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Request_Move_JT : public ::flatbuffers::NativeTable {
  typedef Request_Move_J TableType;
  std::unique_ptr<IPC::MoveInput_TargetT> target{};
  std::unique_ptr<IPC::MoveInput_SpeedT> speed{};
  Request_Move_JT() = default;
  Request_Move_JT(const Request_Move_JT &o);
  Request_Move_JT(Request_Move_JT&&) FLATBUFFERS_NOEXCEPT = default;
  Request_Move_JT &operator=(Request_Move_JT o) FLATBUFFERS_NOEXCEPT;
};

struct Request_Move_J FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Request_Move_JT NativeTableType;
  typedef Request_Move_JBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TARGET = 4,
    VT_SPEED = 6
  };
  const IPC::MoveInput_Target *target() const {
    return GetPointer<const IPC::MoveInput_Target *>(VT_TARGET);
  }
  const IPC::MoveInput_Speed *speed() const {
    return GetPointer<const IPC::MoveInput_Speed *>(VT_SPEED);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TARGET) &&
           verifier.VerifyTable(target()) &&
           VerifyOffset(verifier, VT_SPEED) &&
           verifier.VerifyTable(speed()) &&
           verifier.EndTable();
  }
  Request_Move_JT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_Move_JT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Request_Move_J> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Move_JT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_Move_JBuilder {
  typedef Request_Move_J Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_target(::flatbuffers::Offset<IPC::MoveInput_Target> target) {
    fbb_.AddOffset(Request_Move_J::VT_TARGET, target);
  }
  void add_speed(::flatbuffers::Offset<IPC::MoveInput_Speed> speed) {
    fbb_.AddOffset(Request_Move_J::VT_SPEED, speed);
  }
  explicit Request_Move_JBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Request_Move_J> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Request_Move_J>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Request_Move_J> CreateRequest_Move_J(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<IPC::MoveInput_Target> target = 0,
    ::flatbuffers::Offset<IPC::MoveInput_Speed> speed = 0) {
  Request_Move_JBuilder builder_(_fbb);
  builder_.add_speed(speed);
  builder_.add_target(target);
  return builder_.Finish();
}

::flatbuffers::Offset<Request_Move_J> CreateRequest_Move_J(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Move_JT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Request_Move_LT : public ::flatbuffers::NativeTable {
  typedef Request_Move_L TableType;
  std::unique_ptr<IPC::MoveInput_TargetT> target{};
  std::unique_ptr<IPC::MoveInput_SpeedT> speed{};
  Request_Move_LT() = default;
  Request_Move_LT(const Request_Move_LT &o);
  Request_Move_LT(Request_Move_LT&&) FLATBUFFERS_NOEXCEPT = default;
  Request_Move_LT &operator=(Request_Move_LT o) FLATBUFFERS_NOEXCEPT;
};

struct Request_Move_L FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Request_Move_LT NativeTableType;
  typedef Request_Move_LBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TARGET = 4,
    VT_SPEED = 6
  };
  const IPC::MoveInput_Target *target() const {
    return GetPointer<const IPC::MoveInput_Target *>(VT_TARGET);
  }
  const IPC::MoveInput_Speed *speed() const {
    return GetPointer<const IPC::MoveInput_Speed *>(VT_SPEED);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TARGET) &&
           verifier.VerifyTable(target()) &&
           VerifyOffset(verifier, VT_SPEED) &&
           verifier.VerifyTable(speed()) &&
           verifier.EndTable();
  }
  Request_Move_LT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_Move_LT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Request_Move_L> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Move_LT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_Move_LBuilder {
  typedef Request_Move_L Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_target(::flatbuffers::Offset<IPC::MoveInput_Target> target) {
    fbb_.AddOffset(Request_Move_L::VT_TARGET, target);
  }
  void add_speed(::flatbuffers::Offset<IPC::MoveInput_Speed> speed) {
    fbb_.AddOffset(Request_Move_L::VT_SPEED, speed);
  }
  explicit Request_Move_LBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Request_Move_L> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Request_Move_L>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Request_Move_L> CreateRequest_Move_L(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<IPC::MoveInput_Target> target = 0,
    ::flatbuffers::Offset<IPC::MoveInput_Speed> speed = 0) {
  Request_Move_LBuilder builder_(_fbb);
  builder_.add_speed(speed);
  builder_.add_target(target);
  return builder_.Finish();
}

::flatbuffers::Offset<Request_Move_L> CreateRequest_Move_L(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Move_LT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Request_Move_JB_CLRT : public ::flatbuffers::NativeTable {
  typedef Request_Move_JB_CLR TableType;
};

struct Request_Move_JB_CLR FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Request_Move_JB_CLRT NativeTableType;
  typedef Request_Move_JB_CLRBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  Request_Move_JB_CLRT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_Move_JB_CLRT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Request_Move_JB_CLR> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Move_JB_CLRT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_Move_JB_CLRBuilder {
  typedef Request_Move_JB_CLR Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit Request_Move_JB_CLRBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Request_Move_JB_CLR> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Request_Move_JB_CLR>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Request_Move_JB_CLR> CreateRequest_Move_JB_CLR(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  Request_Move_JB_CLRBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<Request_Move_JB_CLR> CreateRequest_Move_JB_CLR(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Move_JB_CLRT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Request_Move_JB_ADDT : public ::flatbuffers::NativeTable {
  typedef Request_Move_JB_ADD TableType;
  std::unique_ptr<IPC::MoveInput_TargetT> target{};
  std::unique_ptr<IPC::MoveInput_SpeedT> speed{};
  std::unique_ptr<IPC::MoveInput_TypeT> type{};
  Request_Move_JB_ADDT() = default;
  Request_Move_JB_ADDT(const Request_Move_JB_ADDT &o);
  Request_Move_JB_ADDT(Request_Move_JB_ADDT&&) FLATBUFFERS_NOEXCEPT = default;
  Request_Move_JB_ADDT &operator=(Request_Move_JB_ADDT o) FLATBUFFERS_NOEXCEPT;
};

struct Request_Move_JB_ADD FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Request_Move_JB_ADDT NativeTableType;
  typedef Request_Move_JB_ADDBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TARGET = 4,
    VT_SPEED = 6,
    VT_TYPE = 8
  };
  const IPC::MoveInput_Target *target() const {
    return GetPointer<const IPC::MoveInput_Target *>(VT_TARGET);
  }
  const IPC::MoveInput_Speed *speed() const {
    return GetPointer<const IPC::MoveInput_Speed *>(VT_SPEED);
  }
  const IPC::MoveInput_Type *type() const {
    return GetPointer<const IPC::MoveInput_Type *>(VT_TYPE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TARGET) &&
           verifier.VerifyTable(target()) &&
           VerifyOffset(verifier, VT_SPEED) &&
           verifier.VerifyTable(speed()) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyTable(type()) &&
           verifier.EndTable();
  }
  Request_Move_JB_ADDT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_Move_JB_ADDT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Request_Move_JB_ADD> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Move_JB_ADDT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_Move_JB_ADDBuilder {
  typedef Request_Move_JB_ADD Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_target(::flatbuffers::Offset<IPC::MoveInput_Target> target) {
    fbb_.AddOffset(Request_Move_JB_ADD::VT_TARGET, target);
  }
  void add_speed(::flatbuffers::Offset<IPC::MoveInput_Speed> speed) {
    fbb_.AddOffset(Request_Move_JB_ADD::VT_SPEED, speed);
  }
  void add_type(::flatbuffers::Offset<IPC::MoveInput_Type> type) {
    fbb_.AddOffset(Request_Move_JB_ADD::VT_TYPE, type);
  }
  explicit Request_Move_JB_ADDBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Request_Move_JB_ADD> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Request_Move_JB_ADD>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Request_Move_JB_ADD> CreateRequest_Move_JB_ADD(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<IPC::MoveInput_Target> target = 0,
    ::flatbuffers::Offset<IPC::MoveInput_Speed> speed = 0,
    ::flatbuffers::Offset<IPC::MoveInput_Type> type = 0) {
  Request_Move_JB_ADDBuilder builder_(_fbb);
  builder_.add_type(type);
  builder_.add_speed(speed);
  builder_.add_target(target);
  return builder_.Finish();
}

::flatbuffers::Offset<Request_Move_JB_ADD> CreateRequest_Move_JB_ADD(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Move_JB_ADDT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Request_Move_JB_RUNT : public ::flatbuffers::NativeTable {
  typedef Request_Move_JB_RUN TableType;
};

struct Request_Move_JB_RUN FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Request_Move_JB_RUNT NativeTableType;
  typedef Request_Move_JB_RUNBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  Request_Move_JB_RUNT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_Move_JB_RUNT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Request_Move_JB_RUN> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Move_JB_RUNT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_Move_JB_RUNBuilder {
  typedef Request_Move_JB_RUN Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit Request_Move_JB_RUNBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Request_Move_JB_RUN> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Request_Move_JB_RUN>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Request_Move_JB_RUN> CreateRequest_Move_JB_RUN(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  Request_Move_JB_RUNBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<Request_Move_JB_RUN> CreateRequest_Move_JB_RUN(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Move_JB_RUNT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Request_Move_LB_CLRT : public ::flatbuffers::NativeTable {
  typedef Request_Move_LB_CLR TableType;
};

struct Request_Move_LB_CLR FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Request_Move_LB_CLRT NativeTableType;
  typedef Request_Move_LB_CLRBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  Request_Move_LB_CLRT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_Move_LB_CLRT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Request_Move_LB_CLR> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Move_LB_CLRT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_Move_LB_CLRBuilder {
  typedef Request_Move_LB_CLR Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit Request_Move_LB_CLRBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Request_Move_LB_CLR> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Request_Move_LB_CLR>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Request_Move_LB_CLR> CreateRequest_Move_LB_CLR(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  Request_Move_LB_CLRBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<Request_Move_LB_CLR> CreateRequest_Move_LB_CLR(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Move_LB_CLRT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Request_Move_LB_ADDT : public ::flatbuffers::NativeTable {
  typedef Request_Move_LB_ADD TableType;
  std::unique_ptr<IPC::MoveInput_TargetT> target{};
  std::unique_ptr<IPC::MoveInput_SpeedT> speed{};
  std::unique_ptr<IPC::MoveInput_TypeT> type{};
  Request_Move_LB_ADDT() = default;
  Request_Move_LB_ADDT(const Request_Move_LB_ADDT &o);
  Request_Move_LB_ADDT(Request_Move_LB_ADDT&&) FLATBUFFERS_NOEXCEPT = default;
  Request_Move_LB_ADDT &operator=(Request_Move_LB_ADDT o) FLATBUFFERS_NOEXCEPT;
};

struct Request_Move_LB_ADD FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Request_Move_LB_ADDT NativeTableType;
  typedef Request_Move_LB_ADDBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TARGET = 4,
    VT_SPEED = 6,
    VT_TYPE = 8
  };
  const IPC::MoveInput_Target *target() const {
    return GetPointer<const IPC::MoveInput_Target *>(VT_TARGET);
  }
  const IPC::MoveInput_Speed *speed() const {
    return GetPointer<const IPC::MoveInput_Speed *>(VT_SPEED);
  }
  const IPC::MoveInput_Type *type() const {
    return GetPointer<const IPC::MoveInput_Type *>(VT_TYPE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TARGET) &&
           verifier.VerifyTable(target()) &&
           VerifyOffset(verifier, VT_SPEED) &&
           verifier.VerifyTable(speed()) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyTable(type()) &&
           verifier.EndTable();
  }
  Request_Move_LB_ADDT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_Move_LB_ADDT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Request_Move_LB_ADD> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Move_LB_ADDT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_Move_LB_ADDBuilder {
  typedef Request_Move_LB_ADD Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_target(::flatbuffers::Offset<IPC::MoveInput_Target> target) {
    fbb_.AddOffset(Request_Move_LB_ADD::VT_TARGET, target);
  }
  void add_speed(::flatbuffers::Offset<IPC::MoveInput_Speed> speed) {
    fbb_.AddOffset(Request_Move_LB_ADD::VT_SPEED, speed);
  }
  void add_type(::flatbuffers::Offset<IPC::MoveInput_Type> type) {
    fbb_.AddOffset(Request_Move_LB_ADD::VT_TYPE, type);
  }
  explicit Request_Move_LB_ADDBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Request_Move_LB_ADD> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Request_Move_LB_ADD>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Request_Move_LB_ADD> CreateRequest_Move_LB_ADD(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<IPC::MoveInput_Target> target = 0,
    ::flatbuffers::Offset<IPC::MoveInput_Speed> speed = 0,
    ::flatbuffers::Offset<IPC::MoveInput_Type> type = 0) {
  Request_Move_LB_ADDBuilder builder_(_fbb);
  builder_.add_type(type);
  builder_.add_speed(speed);
  builder_.add_target(target);
  return builder_.Finish();
}

::flatbuffers::Offset<Request_Move_LB_ADD> CreateRequest_Move_LB_ADD(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Move_LB_ADDT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Request_Move_LB_RUNT : public ::flatbuffers::NativeTable {
  typedef Request_Move_LB_RUN TableType;
  int32_t orientation = 0;
};

struct Request_Move_LB_RUN FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Request_Move_LB_RUNT NativeTableType;
  typedef Request_Move_LB_RUNBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ORIENTATION = 4
  };
  int32_t orientation() const {
    return GetField<int32_t>(VT_ORIENTATION, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ORIENTATION, 4) &&
           verifier.EndTable();
  }
  Request_Move_LB_RUNT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_Move_LB_RUNT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Request_Move_LB_RUN> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Move_LB_RUNT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_Move_LB_RUNBuilder {
  typedef Request_Move_LB_RUN Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_orientation(int32_t orientation) {
    fbb_.AddElement<int32_t>(Request_Move_LB_RUN::VT_ORIENTATION, orientation, 0);
  }
  explicit Request_Move_LB_RUNBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Request_Move_LB_RUN> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Request_Move_LB_RUN>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Request_Move_LB_RUN> CreateRequest_Move_LB_RUN(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t orientation = 0) {
  Request_Move_LB_RUNBuilder builder_(_fbb);
  builder_.add_orientation(orientation);
  return builder_.Finish();
}

::flatbuffers::Offset<Request_Move_LB_RUN> CreateRequest_Move_LB_RUN(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Move_LB_RUNT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Request_Move_XB_CLRT : public ::flatbuffers::NativeTable {
  typedef Request_Move_XB_CLR TableType;
};

struct Request_Move_XB_CLR FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Request_Move_XB_CLRT NativeTableType;
  typedef Request_Move_XB_CLRBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  Request_Move_XB_CLRT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_Move_XB_CLRT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Request_Move_XB_CLR> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Move_XB_CLRT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_Move_XB_CLRBuilder {
  typedef Request_Move_XB_CLR Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit Request_Move_XB_CLRBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Request_Move_XB_CLR> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Request_Move_XB_CLR>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Request_Move_XB_CLR> CreateRequest_Move_XB_CLR(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  Request_Move_XB_CLRBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<Request_Move_XB_CLR> CreateRequest_Move_XB_CLR(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Move_XB_CLRT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Request_Move_XB_ADDT : public ::flatbuffers::NativeTable {
  typedef Request_Move_XB_ADD TableType;
  std::unique_ptr<IPC::MoveInput_TargetT> target{};
  std::unique_ptr<IPC::MoveInput_SpeedT> speed{};
  std::unique_ptr<IPC::MoveInput_TypeT> type{};
  int32_t method = 0;
  Request_Move_XB_ADDT() = default;
  Request_Move_XB_ADDT(const Request_Move_XB_ADDT &o);
  Request_Move_XB_ADDT(Request_Move_XB_ADDT&&) FLATBUFFERS_NOEXCEPT = default;
  Request_Move_XB_ADDT &operator=(Request_Move_XB_ADDT o) FLATBUFFERS_NOEXCEPT;
};

struct Request_Move_XB_ADD FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Request_Move_XB_ADDT NativeTableType;
  typedef Request_Move_XB_ADDBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TARGET = 4,
    VT_SPEED = 6,
    VT_TYPE = 8,
    VT_METHOD = 10
  };
  const IPC::MoveInput_Target *target() const {
    return GetPointer<const IPC::MoveInput_Target *>(VT_TARGET);
  }
  const IPC::MoveInput_Speed *speed() const {
    return GetPointer<const IPC::MoveInput_Speed *>(VT_SPEED);
  }
  const IPC::MoveInput_Type *type() const {
    return GetPointer<const IPC::MoveInput_Type *>(VT_TYPE);
  }
  int32_t method() const {
    return GetField<int32_t>(VT_METHOD, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TARGET) &&
           verifier.VerifyTable(target()) &&
           VerifyOffset(verifier, VT_SPEED) &&
           verifier.VerifyTable(speed()) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyTable(type()) &&
           VerifyField<int32_t>(verifier, VT_METHOD, 4) &&
           verifier.EndTable();
  }
  Request_Move_XB_ADDT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_Move_XB_ADDT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Request_Move_XB_ADD> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Move_XB_ADDT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_Move_XB_ADDBuilder {
  typedef Request_Move_XB_ADD Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_target(::flatbuffers::Offset<IPC::MoveInput_Target> target) {
    fbb_.AddOffset(Request_Move_XB_ADD::VT_TARGET, target);
  }
  void add_speed(::flatbuffers::Offset<IPC::MoveInput_Speed> speed) {
    fbb_.AddOffset(Request_Move_XB_ADD::VT_SPEED, speed);
  }
  void add_type(::flatbuffers::Offset<IPC::MoveInput_Type> type) {
    fbb_.AddOffset(Request_Move_XB_ADD::VT_TYPE, type);
  }
  void add_method(int32_t method) {
    fbb_.AddElement<int32_t>(Request_Move_XB_ADD::VT_METHOD, method, 0);
  }
  explicit Request_Move_XB_ADDBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Request_Move_XB_ADD> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Request_Move_XB_ADD>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Request_Move_XB_ADD> CreateRequest_Move_XB_ADD(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<IPC::MoveInput_Target> target = 0,
    ::flatbuffers::Offset<IPC::MoveInput_Speed> speed = 0,
    ::flatbuffers::Offset<IPC::MoveInput_Type> type = 0,
    int32_t method = 0) {
  Request_Move_XB_ADDBuilder builder_(_fbb);
  builder_.add_method(method);
  builder_.add_type(type);
  builder_.add_speed(speed);
  builder_.add_target(target);
  return builder_.Finish();
}

::flatbuffers::Offset<Request_Move_XB_ADD> CreateRequest_Move_XB_ADD(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Move_XB_ADDT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Request_Move_XB_RUNT : public ::flatbuffers::NativeTable {
  typedef Request_Move_XB_RUN TableType;
  int32_t running_mode = 0;
};

struct Request_Move_XB_RUN FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Request_Move_XB_RUNT NativeTableType;
  typedef Request_Move_XB_RUNBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RUNNING_MODE = 4
  };
  int32_t running_mode() const {
    return GetField<int32_t>(VT_RUNNING_MODE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RUNNING_MODE, 4) &&
           verifier.EndTable();
  }
  Request_Move_XB_RUNT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_Move_XB_RUNT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Request_Move_XB_RUN> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Move_XB_RUNT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_Move_XB_RUNBuilder {
  typedef Request_Move_XB_RUN Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_running_mode(int32_t running_mode) {
    fbb_.AddElement<int32_t>(Request_Move_XB_RUN::VT_RUNNING_MODE, running_mode, 0);
  }
  explicit Request_Move_XB_RUNBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Request_Move_XB_RUN> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Request_Move_XB_RUN>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Request_Move_XB_RUN> CreateRequest_Move_XB_RUN(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t running_mode = 0) {
  Request_Move_XB_RUNBuilder builder_(_fbb);
  builder_.add_running_mode(running_mode);
  return builder_.Finish();
}

::flatbuffers::Offset<Request_Move_XB_RUN> CreateRequest_Move_XB_RUN(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Move_XB_RUNT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline Request_Move_SmoothJogJT::Request_Move_SmoothJogJT(const Request_Move_SmoothJogJT &o)
      : target((o.target) ? new IPC::MoveInput_TargetT(*o.target) : nullptr) {
}

inline Request_Move_SmoothJogJT &Request_Move_SmoothJogJT::operator=(Request_Move_SmoothJogJT o) FLATBUFFERS_NOEXCEPT {
  std::swap(target, o.target);
  return *this;
}

inline Request_Move_SmoothJogJT *Request_Move_SmoothJogJ::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Request_Move_SmoothJogJT>(new Request_Move_SmoothJogJT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Request_Move_SmoothJogJ::UnPackTo(Request_Move_SmoothJogJT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = target(); if (_e) { if(_o->target) { _e->UnPackTo(_o->target.get(), _resolver); } else { _o->target = std::unique_ptr<IPC::MoveInput_TargetT>(_e->UnPack(_resolver)); } } else if (_o->target) { _o->target.reset(); } }
}

inline ::flatbuffers::Offset<Request_Move_SmoothJogJ> Request_Move_SmoothJogJ::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Move_SmoothJogJT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_Move_SmoothJogJ(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Request_Move_SmoothJogJ> CreateRequest_Move_SmoothJogJ(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Move_SmoothJogJT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const Request_Move_SmoothJogJT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _target = _o->target ? CreateMoveInput_Target(_fbb, _o->target.get(), _rehasher) : 0;
  return IPC::CreateRequest_Move_SmoothJogJ(
      _fbb,
      _target);
}

inline Request_Move_SmoothJogLT::Request_Move_SmoothJogLT(const Request_Move_SmoothJogLT &o)
      : target((o.target) ? new IPC::MoveInput_TargetT(*o.target) : nullptr) {
}

inline Request_Move_SmoothJogLT &Request_Move_SmoothJogLT::operator=(Request_Move_SmoothJogLT o) FLATBUFFERS_NOEXCEPT {
  std::swap(target, o.target);
  return *this;
}

inline Request_Move_SmoothJogLT *Request_Move_SmoothJogL::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Request_Move_SmoothJogLT>(new Request_Move_SmoothJogLT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Request_Move_SmoothJogL::UnPackTo(Request_Move_SmoothJogLT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = target(); if (_e) { if(_o->target) { _e->UnPackTo(_o->target.get(), _resolver); } else { _o->target = std::unique_ptr<IPC::MoveInput_TargetT>(_e->UnPack(_resolver)); } } else if (_o->target) { _o->target.reset(); } }
}

inline ::flatbuffers::Offset<Request_Move_SmoothJogL> Request_Move_SmoothJogL::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Move_SmoothJogLT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_Move_SmoothJogL(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Request_Move_SmoothJogL> CreateRequest_Move_SmoothJogL(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Move_SmoothJogLT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const Request_Move_SmoothJogLT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _target = _o->target ? CreateMoveInput_Target(_fbb, _o->target.get(), _rehasher) : 0;
  return IPC::CreateRequest_Move_SmoothJogL(
      _fbb,
      _target);
}

inline Request_Move_SmoothJogStopT *Request_Move_SmoothJogStop::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Request_Move_SmoothJogStopT>(new Request_Move_SmoothJogStopT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Request_Move_SmoothJogStop::UnPackTo(Request_Move_SmoothJogStopT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = stoptime(); _o->stoptime = _e; }
}

inline ::flatbuffers::Offset<Request_Move_SmoothJogStop> Request_Move_SmoothJogStop::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Move_SmoothJogStopT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_Move_SmoothJogStop(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Request_Move_SmoothJogStop> CreateRequest_Move_SmoothJogStop(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Move_SmoothJogStopT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const Request_Move_SmoothJogStopT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _stoptime = _o->stoptime;
  return IPC::CreateRequest_Move_SmoothJogStop(
      _fbb,
      _stoptime);
}

inline Request_Move_TickJogJT::Request_Move_TickJogJT(const Request_Move_TickJogJT &o)
      : target((o.target) ? new IPC::MoveInput_TargetT(*o.target) : nullptr),
        speed((o.speed) ? new IPC::MoveInput_SpeedT(*o.speed) : nullptr) {
}

inline Request_Move_TickJogJT &Request_Move_TickJogJT::operator=(Request_Move_TickJogJT o) FLATBUFFERS_NOEXCEPT {
  std::swap(target, o.target);
  std::swap(speed, o.speed);
  return *this;
}

inline Request_Move_TickJogJT *Request_Move_TickJogJ::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Request_Move_TickJogJT>(new Request_Move_TickJogJT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Request_Move_TickJogJ::UnPackTo(Request_Move_TickJogJT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = target(); if (_e) { if(_o->target) { _e->UnPackTo(_o->target.get(), _resolver); } else { _o->target = std::unique_ptr<IPC::MoveInput_TargetT>(_e->UnPack(_resolver)); } } else if (_o->target) { _o->target.reset(); } }
  { auto _e = speed(); if (_e) { if(_o->speed) { _e->UnPackTo(_o->speed.get(), _resolver); } else { _o->speed = std::unique_ptr<IPC::MoveInput_SpeedT>(_e->UnPack(_resolver)); } } else if (_o->speed) { _o->speed.reset(); } }
}

inline ::flatbuffers::Offset<Request_Move_TickJogJ> Request_Move_TickJogJ::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Move_TickJogJT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_Move_TickJogJ(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Request_Move_TickJogJ> CreateRequest_Move_TickJogJ(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Move_TickJogJT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const Request_Move_TickJogJT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _target = _o->target ? CreateMoveInput_Target(_fbb, _o->target.get(), _rehasher) : 0;
  auto _speed = _o->speed ? CreateMoveInput_Speed(_fbb, _o->speed.get(), _rehasher) : 0;
  return IPC::CreateRequest_Move_TickJogJ(
      _fbb,
      _target,
      _speed);
}

inline Request_Move_TickJogLT::Request_Move_TickJogLT(const Request_Move_TickJogLT &o)
      : target((o.target) ? new IPC::MoveInput_TargetT(*o.target) : nullptr),
        speed((o.speed) ? new IPC::MoveInput_SpeedT(*o.speed) : nullptr) {
}

inline Request_Move_TickJogLT &Request_Move_TickJogLT::operator=(Request_Move_TickJogLT o) FLATBUFFERS_NOEXCEPT {
  std::swap(target, o.target);
  std::swap(speed, o.speed);
  return *this;
}

inline Request_Move_TickJogLT *Request_Move_TickJogL::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Request_Move_TickJogLT>(new Request_Move_TickJogLT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Request_Move_TickJogL::UnPackTo(Request_Move_TickJogLT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = target(); if (_e) { if(_o->target) { _e->UnPackTo(_o->target.get(), _resolver); } else { _o->target = std::unique_ptr<IPC::MoveInput_TargetT>(_e->UnPack(_resolver)); } } else if (_o->target) { _o->target.reset(); } }
  { auto _e = speed(); if (_e) { if(_o->speed) { _e->UnPackTo(_o->speed.get(), _resolver); } else { _o->speed = std::unique_ptr<IPC::MoveInput_SpeedT>(_e->UnPack(_resolver)); } } else if (_o->speed) { _o->speed.reset(); } }
}

inline ::flatbuffers::Offset<Request_Move_TickJogL> Request_Move_TickJogL::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Move_TickJogLT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_Move_TickJogL(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Request_Move_TickJogL> CreateRequest_Move_TickJogL(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Move_TickJogLT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const Request_Move_TickJogLT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _target = _o->target ? CreateMoveInput_Target(_fbb, _o->target.get(), _rehasher) : 0;
  auto _speed = _o->speed ? CreateMoveInput_Speed(_fbb, _o->speed.get(), _rehasher) : 0;
  return IPC::CreateRequest_Move_TickJogL(
      _fbb,
      _target,
      _speed);
}

inline Request_Move_JT::Request_Move_JT(const Request_Move_JT &o)
      : target((o.target) ? new IPC::MoveInput_TargetT(*o.target) : nullptr),
        speed((o.speed) ? new IPC::MoveInput_SpeedT(*o.speed) : nullptr) {
}

inline Request_Move_JT &Request_Move_JT::operator=(Request_Move_JT o) FLATBUFFERS_NOEXCEPT {
  std::swap(target, o.target);
  std::swap(speed, o.speed);
  return *this;
}

inline Request_Move_JT *Request_Move_J::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Request_Move_JT>(new Request_Move_JT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Request_Move_J::UnPackTo(Request_Move_JT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = target(); if (_e) { if(_o->target) { _e->UnPackTo(_o->target.get(), _resolver); } else { _o->target = std::unique_ptr<IPC::MoveInput_TargetT>(_e->UnPack(_resolver)); } } else if (_o->target) { _o->target.reset(); } }
  { auto _e = speed(); if (_e) { if(_o->speed) { _e->UnPackTo(_o->speed.get(), _resolver); } else { _o->speed = std::unique_ptr<IPC::MoveInput_SpeedT>(_e->UnPack(_resolver)); } } else if (_o->speed) { _o->speed.reset(); } }
}

inline ::flatbuffers::Offset<Request_Move_J> Request_Move_J::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Move_JT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_Move_J(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Request_Move_J> CreateRequest_Move_J(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Move_JT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const Request_Move_JT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _target = _o->target ? CreateMoveInput_Target(_fbb, _o->target.get(), _rehasher) : 0;
  auto _speed = _o->speed ? CreateMoveInput_Speed(_fbb, _o->speed.get(), _rehasher) : 0;
  return IPC::CreateRequest_Move_J(
      _fbb,
      _target,
      _speed);
}

inline Request_Move_LT::Request_Move_LT(const Request_Move_LT &o)
      : target((o.target) ? new IPC::MoveInput_TargetT(*o.target) : nullptr),
        speed((o.speed) ? new IPC::MoveInput_SpeedT(*o.speed) : nullptr) {
}

inline Request_Move_LT &Request_Move_LT::operator=(Request_Move_LT o) FLATBUFFERS_NOEXCEPT {
  std::swap(target, o.target);
  std::swap(speed, o.speed);
  return *this;
}

inline Request_Move_LT *Request_Move_L::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Request_Move_LT>(new Request_Move_LT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Request_Move_L::UnPackTo(Request_Move_LT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = target(); if (_e) { if(_o->target) { _e->UnPackTo(_o->target.get(), _resolver); } else { _o->target = std::unique_ptr<IPC::MoveInput_TargetT>(_e->UnPack(_resolver)); } } else if (_o->target) { _o->target.reset(); } }
  { auto _e = speed(); if (_e) { if(_o->speed) { _e->UnPackTo(_o->speed.get(), _resolver); } else { _o->speed = std::unique_ptr<IPC::MoveInput_SpeedT>(_e->UnPack(_resolver)); } } else if (_o->speed) { _o->speed.reset(); } }
}

inline ::flatbuffers::Offset<Request_Move_L> Request_Move_L::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Move_LT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_Move_L(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Request_Move_L> CreateRequest_Move_L(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Move_LT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const Request_Move_LT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _target = _o->target ? CreateMoveInput_Target(_fbb, _o->target.get(), _rehasher) : 0;
  auto _speed = _o->speed ? CreateMoveInput_Speed(_fbb, _o->speed.get(), _rehasher) : 0;
  return IPC::CreateRequest_Move_L(
      _fbb,
      _target,
      _speed);
}

inline Request_Move_JB_CLRT *Request_Move_JB_CLR::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Request_Move_JB_CLRT>(new Request_Move_JB_CLRT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Request_Move_JB_CLR::UnPackTo(Request_Move_JB_CLRT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<Request_Move_JB_CLR> Request_Move_JB_CLR::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Move_JB_CLRT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_Move_JB_CLR(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Request_Move_JB_CLR> CreateRequest_Move_JB_CLR(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Move_JB_CLRT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const Request_Move_JB_CLRT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return IPC::CreateRequest_Move_JB_CLR(
      _fbb);
}

inline Request_Move_JB_ADDT::Request_Move_JB_ADDT(const Request_Move_JB_ADDT &o)
      : target((o.target) ? new IPC::MoveInput_TargetT(*o.target) : nullptr),
        speed((o.speed) ? new IPC::MoveInput_SpeedT(*o.speed) : nullptr),
        type((o.type) ? new IPC::MoveInput_TypeT(*o.type) : nullptr) {
}

inline Request_Move_JB_ADDT &Request_Move_JB_ADDT::operator=(Request_Move_JB_ADDT o) FLATBUFFERS_NOEXCEPT {
  std::swap(target, o.target);
  std::swap(speed, o.speed);
  std::swap(type, o.type);
  return *this;
}

inline Request_Move_JB_ADDT *Request_Move_JB_ADD::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Request_Move_JB_ADDT>(new Request_Move_JB_ADDT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Request_Move_JB_ADD::UnPackTo(Request_Move_JB_ADDT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = target(); if (_e) { if(_o->target) { _e->UnPackTo(_o->target.get(), _resolver); } else { _o->target = std::unique_ptr<IPC::MoveInput_TargetT>(_e->UnPack(_resolver)); } } else if (_o->target) { _o->target.reset(); } }
  { auto _e = speed(); if (_e) { if(_o->speed) { _e->UnPackTo(_o->speed.get(), _resolver); } else { _o->speed = std::unique_ptr<IPC::MoveInput_SpeedT>(_e->UnPack(_resolver)); } } else if (_o->speed) { _o->speed.reset(); } }
  { auto _e = type(); if (_e) { if(_o->type) { _e->UnPackTo(_o->type.get(), _resolver); } else { _o->type = std::unique_ptr<IPC::MoveInput_TypeT>(_e->UnPack(_resolver)); } } else if (_o->type) { _o->type.reset(); } }
}

inline ::flatbuffers::Offset<Request_Move_JB_ADD> Request_Move_JB_ADD::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Move_JB_ADDT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_Move_JB_ADD(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Request_Move_JB_ADD> CreateRequest_Move_JB_ADD(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Move_JB_ADDT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const Request_Move_JB_ADDT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _target = _o->target ? CreateMoveInput_Target(_fbb, _o->target.get(), _rehasher) : 0;
  auto _speed = _o->speed ? CreateMoveInput_Speed(_fbb, _o->speed.get(), _rehasher) : 0;
  auto _type = _o->type ? CreateMoveInput_Type(_fbb, _o->type.get(), _rehasher) : 0;
  return IPC::CreateRequest_Move_JB_ADD(
      _fbb,
      _target,
      _speed,
      _type);
}

inline Request_Move_JB_RUNT *Request_Move_JB_RUN::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Request_Move_JB_RUNT>(new Request_Move_JB_RUNT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Request_Move_JB_RUN::UnPackTo(Request_Move_JB_RUNT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<Request_Move_JB_RUN> Request_Move_JB_RUN::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Move_JB_RUNT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_Move_JB_RUN(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Request_Move_JB_RUN> CreateRequest_Move_JB_RUN(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Move_JB_RUNT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const Request_Move_JB_RUNT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return IPC::CreateRequest_Move_JB_RUN(
      _fbb);
}

inline Request_Move_LB_CLRT *Request_Move_LB_CLR::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Request_Move_LB_CLRT>(new Request_Move_LB_CLRT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Request_Move_LB_CLR::UnPackTo(Request_Move_LB_CLRT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<Request_Move_LB_CLR> Request_Move_LB_CLR::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Move_LB_CLRT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_Move_LB_CLR(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Request_Move_LB_CLR> CreateRequest_Move_LB_CLR(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Move_LB_CLRT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const Request_Move_LB_CLRT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return IPC::CreateRequest_Move_LB_CLR(
      _fbb);
}

inline Request_Move_LB_ADDT::Request_Move_LB_ADDT(const Request_Move_LB_ADDT &o)
      : target((o.target) ? new IPC::MoveInput_TargetT(*o.target) : nullptr),
        speed((o.speed) ? new IPC::MoveInput_SpeedT(*o.speed) : nullptr),
        type((o.type) ? new IPC::MoveInput_TypeT(*o.type) : nullptr) {
}

inline Request_Move_LB_ADDT &Request_Move_LB_ADDT::operator=(Request_Move_LB_ADDT o) FLATBUFFERS_NOEXCEPT {
  std::swap(target, o.target);
  std::swap(speed, o.speed);
  std::swap(type, o.type);
  return *this;
}

inline Request_Move_LB_ADDT *Request_Move_LB_ADD::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Request_Move_LB_ADDT>(new Request_Move_LB_ADDT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Request_Move_LB_ADD::UnPackTo(Request_Move_LB_ADDT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = target(); if (_e) { if(_o->target) { _e->UnPackTo(_o->target.get(), _resolver); } else { _o->target = std::unique_ptr<IPC::MoveInput_TargetT>(_e->UnPack(_resolver)); } } else if (_o->target) { _o->target.reset(); } }
  { auto _e = speed(); if (_e) { if(_o->speed) { _e->UnPackTo(_o->speed.get(), _resolver); } else { _o->speed = std::unique_ptr<IPC::MoveInput_SpeedT>(_e->UnPack(_resolver)); } } else if (_o->speed) { _o->speed.reset(); } }
  { auto _e = type(); if (_e) { if(_o->type) { _e->UnPackTo(_o->type.get(), _resolver); } else { _o->type = std::unique_ptr<IPC::MoveInput_TypeT>(_e->UnPack(_resolver)); } } else if (_o->type) { _o->type.reset(); } }
}

inline ::flatbuffers::Offset<Request_Move_LB_ADD> Request_Move_LB_ADD::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Move_LB_ADDT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_Move_LB_ADD(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Request_Move_LB_ADD> CreateRequest_Move_LB_ADD(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Move_LB_ADDT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const Request_Move_LB_ADDT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _target = _o->target ? CreateMoveInput_Target(_fbb, _o->target.get(), _rehasher) : 0;
  auto _speed = _o->speed ? CreateMoveInput_Speed(_fbb, _o->speed.get(), _rehasher) : 0;
  auto _type = _o->type ? CreateMoveInput_Type(_fbb, _o->type.get(), _rehasher) : 0;
  return IPC::CreateRequest_Move_LB_ADD(
      _fbb,
      _target,
      _speed,
      _type);
}

inline Request_Move_LB_RUNT *Request_Move_LB_RUN::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Request_Move_LB_RUNT>(new Request_Move_LB_RUNT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Request_Move_LB_RUN::UnPackTo(Request_Move_LB_RUNT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = orientation(); _o->orientation = _e; }
}

inline ::flatbuffers::Offset<Request_Move_LB_RUN> Request_Move_LB_RUN::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Move_LB_RUNT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_Move_LB_RUN(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Request_Move_LB_RUN> CreateRequest_Move_LB_RUN(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Move_LB_RUNT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const Request_Move_LB_RUNT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _orientation = _o->orientation;
  return IPC::CreateRequest_Move_LB_RUN(
      _fbb,
      _orientation);
}

inline Request_Move_XB_CLRT *Request_Move_XB_CLR::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Request_Move_XB_CLRT>(new Request_Move_XB_CLRT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Request_Move_XB_CLR::UnPackTo(Request_Move_XB_CLRT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<Request_Move_XB_CLR> Request_Move_XB_CLR::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Move_XB_CLRT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_Move_XB_CLR(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Request_Move_XB_CLR> CreateRequest_Move_XB_CLR(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Move_XB_CLRT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const Request_Move_XB_CLRT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return IPC::CreateRequest_Move_XB_CLR(
      _fbb);
}

inline Request_Move_XB_ADDT::Request_Move_XB_ADDT(const Request_Move_XB_ADDT &o)
      : target((o.target) ? new IPC::MoveInput_TargetT(*o.target) : nullptr),
        speed((o.speed) ? new IPC::MoveInput_SpeedT(*o.speed) : nullptr),
        type((o.type) ? new IPC::MoveInput_TypeT(*o.type) : nullptr),
        method(o.method) {
}

inline Request_Move_XB_ADDT &Request_Move_XB_ADDT::operator=(Request_Move_XB_ADDT o) FLATBUFFERS_NOEXCEPT {
  std::swap(target, o.target);
  std::swap(speed, o.speed);
  std::swap(type, o.type);
  std::swap(method, o.method);
  return *this;
}

inline Request_Move_XB_ADDT *Request_Move_XB_ADD::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Request_Move_XB_ADDT>(new Request_Move_XB_ADDT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Request_Move_XB_ADD::UnPackTo(Request_Move_XB_ADDT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = target(); if (_e) { if(_o->target) { _e->UnPackTo(_o->target.get(), _resolver); } else { _o->target = std::unique_ptr<IPC::MoveInput_TargetT>(_e->UnPack(_resolver)); } } else if (_o->target) { _o->target.reset(); } }
  { auto _e = speed(); if (_e) { if(_o->speed) { _e->UnPackTo(_o->speed.get(), _resolver); } else { _o->speed = std::unique_ptr<IPC::MoveInput_SpeedT>(_e->UnPack(_resolver)); } } else if (_o->speed) { _o->speed.reset(); } }
  { auto _e = type(); if (_e) { if(_o->type) { _e->UnPackTo(_o->type.get(), _resolver); } else { _o->type = std::unique_ptr<IPC::MoveInput_TypeT>(_e->UnPack(_resolver)); } } else if (_o->type) { _o->type.reset(); } }
  { auto _e = method(); _o->method = _e; }
}

inline ::flatbuffers::Offset<Request_Move_XB_ADD> Request_Move_XB_ADD::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Move_XB_ADDT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_Move_XB_ADD(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Request_Move_XB_ADD> CreateRequest_Move_XB_ADD(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Move_XB_ADDT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const Request_Move_XB_ADDT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _target = _o->target ? CreateMoveInput_Target(_fbb, _o->target.get(), _rehasher) : 0;
  auto _speed = _o->speed ? CreateMoveInput_Speed(_fbb, _o->speed.get(), _rehasher) : 0;
  auto _type = _o->type ? CreateMoveInput_Type(_fbb, _o->type.get(), _rehasher) : 0;
  auto _method = _o->method;
  return IPC::CreateRequest_Move_XB_ADD(
      _fbb,
      _target,
      _speed,
      _type,
      _method);
}

inline Request_Move_XB_RUNT *Request_Move_XB_RUN::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Request_Move_XB_RUNT>(new Request_Move_XB_RUNT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Request_Move_XB_RUN::UnPackTo(Request_Move_XB_RUNT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = running_mode(); _o->running_mode = _e; }
}

inline ::flatbuffers::Offset<Request_Move_XB_RUN> Request_Move_XB_RUN::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Move_XB_RUNT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_Move_XB_RUN(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Request_Move_XB_RUN> CreateRequest_Move_XB_RUN(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Move_XB_RUNT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const Request_Move_XB_RUNT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _running_mode = _o->running_mode;
  return IPC::CreateRequest_Move_XB_RUN(
      _fbb,
      _running_mode);
}

}  // namespace IPC

#endif  // FLATBUFFERS_GENERATED_FUNCMOVE_IPC_H_
