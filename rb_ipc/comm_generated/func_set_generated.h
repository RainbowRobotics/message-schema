// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_FUNCSET_IPC_H_
#define FLATBUFFERS_GENERATED_FUNCSET_IPC_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

#include "common_struct_generated.h"
#include "func_return_generated.h"

namespace IPC {

struct Request_Set_Tool_List;
struct Request_Set_Tool_ListBuilder;
struct Request_Set_Tool_ListT;

struct Request_Set_User_Frame;
struct Request_Set_User_FrameBuilder;
struct Request_Set_User_FrameT;

struct Request_Set_Shift;
struct Request_Set_ShiftBuilder;
struct Request_Set_ShiftT;

struct Request_Set_Out_Collision_Para;
struct Request_Set_Out_Collision_ParaBuilder;
struct Request_Set_Out_Collision_ParaT;

struct Request_Set_Self_Collision_Para;
struct Request_Set_Self_Collision_ParaBuilder;
struct Request_Set_Self_Collision_ParaT;

struct Request_Set_Tool_ListT : public ::flatbuffers::NativeTable {
  typedef Request_Set_Tool_List TableType;
  int32_t target_tool_num = 0;
};

struct Request_Set_Tool_List FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Request_Set_Tool_ListT NativeTableType;
  typedef Request_Set_Tool_ListBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TARGET_TOOL_NUM = 4
  };
  int32_t target_tool_num() const {
    return GetField<int32_t>(VT_TARGET_TOOL_NUM, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TARGET_TOOL_NUM, 4) &&
           verifier.EndTable();
  }
  Request_Set_Tool_ListT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_Set_Tool_ListT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Request_Set_Tool_List> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Set_Tool_ListT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_Set_Tool_ListBuilder {
  typedef Request_Set_Tool_List Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_target_tool_num(int32_t target_tool_num) {
    fbb_.AddElement<int32_t>(Request_Set_Tool_List::VT_TARGET_TOOL_NUM, target_tool_num, 0);
  }
  explicit Request_Set_Tool_ListBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Request_Set_Tool_List> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Request_Set_Tool_List>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Request_Set_Tool_List> CreateRequest_Set_Tool_List(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t target_tool_num = 0) {
  Request_Set_Tool_ListBuilder builder_(_fbb);
  builder_.add_target_tool_num(target_tool_num);
  return builder_.Finish();
}

::flatbuffers::Offset<Request_Set_Tool_List> CreateRequest_Set_Tool_List(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Set_Tool_ListT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Request_Set_User_FrameT : public ::flatbuffers::NativeTable {
  typedef Request_Set_User_Frame TableType;
  int32_t user_frame_num = 0;
};

struct Request_Set_User_Frame FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Request_Set_User_FrameT NativeTableType;
  typedef Request_Set_User_FrameBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_USER_FRAME_NUM = 4
  };
  int32_t user_frame_num() const {
    return GetField<int32_t>(VT_USER_FRAME_NUM, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_USER_FRAME_NUM, 4) &&
           verifier.EndTable();
  }
  Request_Set_User_FrameT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_Set_User_FrameT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Request_Set_User_Frame> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Set_User_FrameT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_Set_User_FrameBuilder {
  typedef Request_Set_User_Frame Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_user_frame_num(int32_t user_frame_num) {
    fbb_.AddElement<int32_t>(Request_Set_User_Frame::VT_USER_FRAME_NUM, user_frame_num, 0);
  }
  explicit Request_Set_User_FrameBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Request_Set_User_Frame> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Request_Set_User_Frame>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Request_Set_User_Frame> CreateRequest_Set_User_Frame(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t user_frame_num = 0) {
  Request_Set_User_FrameBuilder builder_(_fbb);
  builder_.add_user_frame_num(user_frame_num);
  return builder_.Finish();
}

::flatbuffers::Offset<Request_Set_User_Frame> CreateRequest_Set_User_Frame(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Set_User_FrameT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Request_Set_ShiftT : public ::flatbuffers::NativeTable {
  typedef Request_Set_Shift TableType;
  int32_t shift_no = 0;
  int32_t shift_mode = 0;
  std::unique_ptr<IPC::MoveInput_TargetT> target{};
  Request_Set_ShiftT() = default;
  Request_Set_ShiftT(const Request_Set_ShiftT &o);
  Request_Set_ShiftT(Request_Set_ShiftT&&) FLATBUFFERS_NOEXCEPT = default;
  Request_Set_ShiftT &operator=(Request_Set_ShiftT o) FLATBUFFERS_NOEXCEPT;
};

struct Request_Set_Shift FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Request_Set_ShiftT NativeTableType;
  typedef Request_Set_ShiftBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHIFT_NO = 4,
    VT_SHIFT_MODE = 6,
    VT_TARGET = 8
  };
  int32_t shift_no() const {
    return GetField<int32_t>(VT_SHIFT_NO, 0);
  }
  int32_t shift_mode() const {
    return GetField<int32_t>(VT_SHIFT_MODE, 0);
  }
  const IPC::MoveInput_Target *target() const {
    return GetPointer<const IPC::MoveInput_Target *>(VT_TARGET);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SHIFT_NO, 4) &&
           VerifyField<int32_t>(verifier, VT_SHIFT_MODE, 4) &&
           VerifyOffset(verifier, VT_TARGET) &&
           verifier.VerifyTable(target()) &&
           verifier.EndTable();
  }
  Request_Set_ShiftT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_Set_ShiftT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Request_Set_Shift> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Set_ShiftT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_Set_ShiftBuilder {
  typedef Request_Set_Shift Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_shift_no(int32_t shift_no) {
    fbb_.AddElement<int32_t>(Request_Set_Shift::VT_SHIFT_NO, shift_no, 0);
  }
  void add_shift_mode(int32_t shift_mode) {
    fbb_.AddElement<int32_t>(Request_Set_Shift::VT_SHIFT_MODE, shift_mode, 0);
  }
  void add_target(::flatbuffers::Offset<IPC::MoveInput_Target> target) {
    fbb_.AddOffset(Request_Set_Shift::VT_TARGET, target);
  }
  explicit Request_Set_ShiftBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Request_Set_Shift> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Request_Set_Shift>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Request_Set_Shift> CreateRequest_Set_Shift(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t shift_no = 0,
    int32_t shift_mode = 0,
    ::flatbuffers::Offset<IPC::MoveInput_Target> target = 0) {
  Request_Set_ShiftBuilder builder_(_fbb);
  builder_.add_target(target);
  builder_.add_shift_mode(shift_mode);
  builder_.add_shift_no(shift_no);
  return builder_.Finish();
}

::flatbuffers::Offset<Request_Set_Shift> CreateRequest_Set_Shift(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Set_ShiftT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Request_Set_Out_Collision_ParaT : public ::flatbuffers::NativeTable {
  typedef Request_Set_Out_Collision_Para TableType;
  int32_t onoff = 0;
  int32_t react_mode = 0;
  float threshold = 0.0f;
};

struct Request_Set_Out_Collision_Para FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Request_Set_Out_Collision_ParaT NativeTableType;
  typedef Request_Set_Out_Collision_ParaBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ONOFF = 4,
    VT_REACT_MODE = 6,
    VT_THRESHOLD = 8
  };
  int32_t onoff() const {
    return GetField<int32_t>(VT_ONOFF, 0);
  }
  int32_t react_mode() const {
    return GetField<int32_t>(VT_REACT_MODE, 0);
  }
  float threshold() const {
    return GetField<float>(VT_THRESHOLD, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ONOFF, 4) &&
           VerifyField<int32_t>(verifier, VT_REACT_MODE, 4) &&
           VerifyField<float>(verifier, VT_THRESHOLD, 4) &&
           verifier.EndTable();
  }
  Request_Set_Out_Collision_ParaT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_Set_Out_Collision_ParaT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Request_Set_Out_Collision_Para> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Set_Out_Collision_ParaT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_Set_Out_Collision_ParaBuilder {
  typedef Request_Set_Out_Collision_Para Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_onoff(int32_t onoff) {
    fbb_.AddElement<int32_t>(Request_Set_Out_Collision_Para::VT_ONOFF, onoff, 0);
  }
  void add_react_mode(int32_t react_mode) {
    fbb_.AddElement<int32_t>(Request_Set_Out_Collision_Para::VT_REACT_MODE, react_mode, 0);
  }
  void add_threshold(float threshold) {
    fbb_.AddElement<float>(Request_Set_Out_Collision_Para::VT_THRESHOLD, threshold, 0.0f);
  }
  explicit Request_Set_Out_Collision_ParaBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Request_Set_Out_Collision_Para> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Request_Set_Out_Collision_Para>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Request_Set_Out_Collision_Para> CreateRequest_Set_Out_Collision_Para(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t onoff = 0,
    int32_t react_mode = 0,
    float threshold = 0.0f) {
  Request_Set_Out_Collision_ParaBuilder builder_(_fbb);
  builder_.add_threshold(threshold);
  builder_.add_react_mode(react_mode);
  builder_.add_onoff(onoff);
  return builder_.Finish();
}

::flatbuffers::Offset<Request_Set_Out_Collision_Para> CreateRequest_Set_Out_Collision_Para(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Set_Out_Collision_ParaT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Request_Set_Self_Collision_ParaT : public ::flatbuffers::NativeTable {
  typedef Request_Set_Self_Collision_Para TableType;
  int32_t mode = 0;
  float dist_int = 0.0f;
  float dist_ext = 0.0f;
};

struct Request_Set_Self_Collision_Para FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Request_Set_Self_Collision_ParaT NativeTableType;
  typedef Request_Set_Self_Collision_ParaBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MODE = 4,
    VT_DIST_INT = 6,
    VT_DIST_EXT = 8
  };
  int32_t mode() const {
    return GetField<int32_t>(VT_MODE, 0);
  }
  float dist_int() const {
    return GetField<float>(VT_DIST_INT, 0.0f);
  }
  float dist_ext() const {
    return GetField<float>(VT_DIST_EXT, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_MODE, 4) &&
           VerifyField<float>(verifier, VT_DIST_INT, 4) &&
           VerifyField<float>(verifier, VT_DIST_EXT, 4) &&
           verifier.EndTable();
  }
  Request_Set_Self_Collision_ParaT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_Set_Self_Collision_ParaT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Request_Set_Self_Collision_Para> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Set_Self_Collision_ParaT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_Set_Self_Collision_ParaBuilder {
  typedef Request_Set_Self_Collision_Para Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_mode(int32_t mode) {
    fbb_.AddElement<int32_t>(Request_Set_Self_Collision_Para::VT_MODE, mode, 0);
  }
  void add_dist_int(float dist_int) {
    fbb_.AddElement<float>(Request_Set_Self_Collision_Para::VT_DIST_INT, dist_int, 0.0f);
  }
  void add_dist_ext(float dist_ext) {
    fbb_.AddElement<float>(Request_Set_Self_Collision_Para::VT_DIST_EXT, dist_ext, 0.0f);
  }
  explicit Request_Set_Self_Collision_ParaBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Request_Set_Self_Collision_Para> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Request_Set_Self_Collision_Para>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Request_Set_Self_Collision_Para> CreateRequest_Set_Self_Collision_Para(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t mode = 0,
    float dist_int = 0.0f,
    float dist_ext = 0.0f) {
  Request_Set_Self_Collision_ParaBuilder builder_(_fbb);
  builder_.add_dist_ext(dist_ext);
  builder_.add_dist_int(dist_int);
  builder_.add_mode(mode);
  return builder_.Finish();
}

::flatbuffers::Offset<Request_Set_Self_Collision_Para> CreateRequest_Set_Self_Collision_Para(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Set_Self_Collision_ParaT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline Request_Set_Tool_ListT *Request_Set_Tool_List::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Request_Set_Tool_ListT>(new Request_Set_Tool_ListT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Request_Set_Tool_List::UnPackTo(Request_Set_Tool_ListT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = target_tool_num(); _o->target_tool_num = _e; }
}

inline ::flatbuffers::Offset<Request_Set_Tool_List> Request_Set_Tool_List::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Set_Tool_ListT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_Set_Tool_List(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Request_Set_Tool_List> CreateRequest_Set_Tool_List(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Set_Tool_ListT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const Request_Set_Tool_ListT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _target_tool_num = _o->target_tool_num;
  return IPC::CreateRequest_Set_Tool_List(
      _fbb,
      _target_tool_num);
}

inline Request_Set_User_FrameT *Request_Set_User_Frame::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Request_Set_User_FrameT>(new Request_Set_User_FrameT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Request_Set_User_Frame::UnPackTo(Request_Set_User_FrameT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = user_frame_num(); _o->user_frame_num = _e; }
}

inline ::flatbuffers::Offset<Request_Set_User_Frame> Request_Set_User_Frame::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Set_User_FrameT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_Set_User_Frame(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Request_Set_User_Frame> CreateRequest_Set_User_Frame(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Set_User_FrameT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const Request_Set_User_FrameT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _user_frame_num = _o->user_frame_num;
  return IPC::CreateRequest_Set_User_Frame(
      _fbb,
      _user_frame_num);
}

inline Request_Set_ShiftT::Request_Set_ShiftT(const Request_Set_ShiftT &o)
      : shift_no(o.shift_no),
        shift_mode(o.shift_mode),
        target((o.target) ? new IPC::MoveInput_TargetT(*o.target) : nullptr) {
}

inline Request_Set_ShiftT &Request_Set_ShiftT::operator=(Request_Set_ShiftT o) FLATBUFFERS_NOEXCEPT {
  std::swap(shift_no, o.shift_no);
  std::swap(shift_mode, o.shift_mode);
  std::swap(target, o.target);
  return *this;
}

inline Request_Set_ShiftT *Request_Set_Shift::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Request_Set_ShiftT>(new Request_Set_ShiftT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Request_Set_Shift::UnPackTo(Request_Set_ShiftT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = shift_no(); _o->shift_no = _e; }
  { auto _e = shift_mode(); _o->shift_mode = _e; }
  { auto _e = target(); if (_e) { if(_o->target) { _e->UnPackTo(_o->target.get(), _resolver); } else { _o->target = std::unique_ptr<IPC::MoveInput_TargetT>(_e->UnPack(_resolver)); } } else if (_o->target) { _o->target.reset(); } }
}

inline ::flatbuffers::Offset<Request_Set_Shift> Request_Set_Shift::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Set_ShiftT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_Set_Shift(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Request_Set_Shift> CreateRequest_Set_Shift(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Set_ShiftT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const Request_Set_ShiftT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _shift_no = _o->shift_no;
  auto _shift_mode = _o->shift_mode;
  auto _target = _o->target ? CreateMoveInput_Target(_fbb, _o->target.get(), _rehasher) : 0;
  return IPC::CreateRequest_Set_Shift(
      _fbb,
      _shift_no,
      _shift_mode,
      _target);
}

inline Request_Set_Out_Collision_ParaT *Request_Set_Out_Collision_Para::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Request_Set_Out_Collision_ParaT>(new Request_Set_Out_Collision_ParaT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Request_Set_Out_Collision_Para::UnPackTo(Request_Set_Out_Collision_ParaT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = onoff(); _o->onoff = _e; }
  { auto _e = react_mode(); _o->react_mode = _e; }
  { auto _e = threshold(); _o->threshold = _e; }
}

inline ::flatbuffers::Offset<Request_Set_Out_Collision_Para> Request_Set_Out_Collision_Para::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Set_Out_Collision_ParaT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_Set_Out_Collision_Para(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Request_Set_Out_Collision_Para> CreateRequest_Set_Out_Collision_Para(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Set_Out_Collision_ParaT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const Request_Set_Out_Collision_ParaT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _onoff = _o->onoff;
  auto _react_mode = _o->react_mode;
  auto _threshold = _o->threshold;
  return IPC::CreateRequest_Set_Out_Collision_Para(
      _fbb,
      _onoff,
      _react_mode,
      _threshold);
}

inline Request_Set_Self_Collision_ParaT *Request_Set_Self_Collision_Para::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Request_Set_Self_Collision_ParaT>(new Request_Set_Self_Collision_ParaT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Request_Set_Self_Collision_Para::UnPackTo(Request_Set_Self_Collision_ParaT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = mode(); _o->mode = _e; }
  { auto _e = dist_int(); _o->dist_int = _e; }
  { auto _e = dist_ext(); _o->dist_ext = _e; }
}

inline ::flatbuffers::Offset<Request_Set_Self_Collision_Para> Request_Set_Self_Collision_Para::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Set_Self_Collision_ParaT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_Set_Self_Collision_Para(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Request_Set_Self_Collision_Para> CreateRequest_Set_Self_Collision_Para(::flatbuffers::FlatBufferBuilder &_fbb, const Request_Set_Self_Collision_ParaT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const Request_Set_Self_Collision_ParaT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _mode = _o->mode;
  auto _dist_int = _o->dist_int;
  auto _dist_ext = _o->dist_ext;
  return IPC::CreateRequest_Set_Self_Collision_Para(
      _fbb,
      _mode,
      _dist_int,
      _dist_ext);
}

}  // namespace IPC

#endif  // FLATBUFFERS_GENERATED_FUNCSET_IPC_H_
