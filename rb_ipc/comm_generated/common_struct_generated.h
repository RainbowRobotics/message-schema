// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_COMMONSTRUCT_IPC_H_
#define FLATBUFFERS_GENERATED_COMMONSTRUCT_IPC_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

namespace IPC {

struct N_INPUT_f;

struct N_JOINT_f;

struct N_CARTE_f;

struct N_DIN_u;

struct N_DOUT_u;

struct N_AIN_f;

struct N_AOUT_f;

struct Vec3f;

struct Mat3f;

struct MoveInput_Target;
struct MoveInput_TargetBuilder;
struct MoveInput_TargetT;

struct MoveInput_Type;
struct MoveInput_TypeBuilder;
struct MoveInput_TypeT;

struct MoveInput_Speed;
struct MoveInput_SpeedBuilder;
struct MoveInput_SpeedT;

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) N_INPUT_f FLATBUFFERS_FINAL_CLASS {
 private:
  float f_[7];

 public:
  N_INPUT_f()
      : f_() {
  }
  N_INPUT_f(::flatbuffers::span<const float, 7> _f) {
    ::flatbuffers::CastToArray(f_).CopyFromSpan(_f);
  }
  const ::flatbuffers::Array<float, 7> *f() const {
    return &::flatbuffers::CastToArray(f_);
  }
};
FLATBUFFERS_STRUCT_END(N_INPUT_f, 28);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) N_JOINT_f FLATBUFFERS_FINAL_CLASS {
 private:
  float f_[7];

 public:
  N_JOINT_f()
      : f_() {
  }
  N_JOINT_f(::flatbuffers::span<const float, 7> _f) {
    ::flatbuffers::CastToArray(f_).CopyFromSpan(_f);
  }
  const ::flatbuffers::Array<float, 7> *f() const {
    return &::flatbuffers::CastToArray(f_);
  }
};
FLATBUFFERS_STRUCT_END(N_JOINT_f, 28);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) N_CARTE_f FLATBUFFERS_FINAL_CLASS {
 private:
  float f_[7];

 public:
  N_CARTE_f()
      : f_() {
  }
  N_CARTE_f(::flatbuffers::span<const float, 7> _f) {
    ::flatbuffers::CastToArray(f_).CopyFromSpan(_f);
  }
  const ::flatbuffers::Array<float, 7> *f() const {
    return &::flatbuffers::CastToArray(f_);
  }
};
FLATBUFFERS_STRUCT_END(N_CARTE_f, 28);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) N_DIN_u FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t u_[16];

 public:
  N_DIN_u()
      : u_() {
  }
  N_DIN_u(::flatbuffers::span<const uint8_t, 16> _u) {
    ::flatbuffers::CastToArray(u_).CopyFromSpan(_u);
  }
  const ::flatbuffers::Array<uint8_t, 16> *u() const {
    return &::flatbuffers::CastToArray(u_);
  }
};
FLATBUFFERS_STRUCT_END(N_DIN_u, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) N_DOUT_u FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t u_[16];

 public:
  N_DOUT_u()
      : u_() {
  }
  N_DOUT_u(::flatbuffers::span<const uint8_t, 16> _u) {
    ::flatbuffers::CastToArray(u_).CopyFromSpan(_u);
  }
  const ::flatbuffers::Array<uint8_t, 16> *u() const {
    return &::flatbuffers::CastToArray(u_);
  }
};
FLATBUFFERS_STRUCT_END(N_DOUT_u, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) N_AIN_f FLATBUFFERS_FINAL_CLASS {
 private:
  float f_[4];

 public:
  N_AIN_f()
      : f_() {
  }
  N_AIN_f(::flatbuffers::span<const float, 4> _f) {
    ::flatbuffers::CastToArray(f_).CopyFromSpan(_f);
  }
  const ::flatbuffers::Array<float, 4> *f() const {
    return &::flatbuffers::CastToArray(f_);
  }
};
FLATBUFFERS_STRUCT_END(N_AIN_f, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) N_AOUT_f FLATBUFFERS_FINAL_CLASS {
 private:
  float f_[4];

 public:
  N_AOUT_f()
      : f_() {
  }
  N_AOUT_f(::flatbuffers::span<const float, 4> _f) {
    ::flatbuffers::CastToArray(f_).CopyFromSpan(_f);
  }
  const ::flatbuffers::Array<float, 4> *f() const {
    return &::flatbuffers::CastToArray(f_);
  }
};
FLATBUFFERS_STRUCT_END(N_AOUT_f, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec3f FLATBUFFERS_FINAL_CLASS {
 private:
  float v_[3];

 public:
  Vec3f()
      : v_() {
  }
  Vec3f(::flatbuffers::span<const float, 3> _v) {
    ::flatbuffers::CastToArray(v_).CopyFromSpan(_v);
  }
  const ::flatbuffers::Array<float, 3> *v() const {
    return &::flatbuffers::CastToArray(v_);
  }
};
FLATBUFFERS_STRUCT_END(Vec3f, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Mat3f FLATBUFFERS_FINAL_CLASS {
 private:
  float m_[9];

 public:
  Mat3f()
      : m_() {
  }
  Mat3f(::flatbuffers::span<const float, 9> _m) {
    ::flatbuffers::CastToArray(m_).CopyFromSpan(_m);
  }
  const ::flatbuffers::Array<float, 9> *m() const {
    return &::flatbuffers::CastToArray(m_);
  }
};
FLATBUFFERS_STRUCT_END(Mat3f, 36);

struct MoveInput_TargetT : public ::flatbuffers::NativeTable {
  typedef MoveInput_Target TableType;
  std::unique_ptr<IPC::N_INPUT_f> tar_values{};
  int32_t tar_frame = 0;
  int32_t tar_unit = 0;
  MoveInput_TargetT() = default;
  MoveInput_TargetT(const MoveInput_TargetT &o);
  MoveInput_TargetT(MoveInput_TargetT&&) FLATBUFFERS_NOEXCEPT = default;
  MoveInput_TargetT &operator=(MoveInput_TargetT o) FLATBUFFERS_NOEXCEPT;
};

struct MoveInput_Target FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MoveInput_TargetT NativeTableType;
  typedef MoveInput_TargetBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TAR_VALUES = 4,
    VT_TAR_FRAME = 6,
    VT_TAR_UNIT = 8
  };
  const IPC::N_INPUT_f *tar_values() const {
    return GetStruct<const IPC::N_INPUT_f *>(VT_TAR_VALUES);
  }
  int32_t tar_frame() const {
    return GetField<int32_t>(VT_TAR_FRAME, 0);
  }
  int32_t tar_unit() const {
    return GetField<int32_t>(VT_TAR_UNIT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<IPC::N_INPUT_f>(verifier, VT_TAR_VALUES, 4) &&
           VerifyField<int32_t>(verifier, VT_TAR_FRAME, 4) &&
           VerifyField<int32_t>(verifier, VT_TAR_UNIT, 4) &&
           verifier.EndTable();
  }
  MoveInput_TargetT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MoveInput_TargetT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<MoveInput_Target> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MoveInput_TargetT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MoveInput_TargetBuilder {
  typedef MoveInput_Target Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_tar_values(const IPC::N_INPUT_f *tar_values) {
    fbb_.AddStruct(MoveInput_Target::VT_TAR_VALUES, tar_values);
  }
  void add_tar_frame(int32_t tar_frame) {
    fbb_.AddElement<int32_t>(MoveInput_Target::VT_TAR_FRAME, tar_frame, 0);
  }
  void add_tar_unit(int32_t tar_unit) {
    fbb_.AddElement<int32_t>(MoveInput_Target::VT_TAR_UNIT, tar_unit, 0);
  }
  explicit MoveInput_TargetBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MoveInput_Target> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MoveInput_Target>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MoveInput_Target> CreateMoveInput_Target(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const IPC::N_INPUT_f *tar_values = nullptr,
    int32_t tar_frame = 0,
    int32_t tar_unit = 0) {
  MoveInput_TargetBuilder builder_(_fbb);
  builder_.add_tar_unit(tar_unit);
  builder_.add_tar_frame(tar_frame);
  builder_.add_tar_values(tar_values);
  return builder_.Finish();
}

::flatbuffers::Offset<MoveInput_Target> CreateMoveInput_Target(::flatbuffers::FlatBufferBuilder &_fbb, const MoveInput_TargetT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MoveInput_TypeT : public ::flatbuffers::NativeTable {
  typedef MoveInput_Type TableType;
  int32_t pnt_type = 0;
  float pnt_para = 0.0f;
};

struct MoveInput_Type FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MoveInput_TypeT NativeTableType;
  typedef MoveInput_TypeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PNT_TYPE = 4,
    VT_PNT_PARA = 6
  };
  int32_t pnt_type() const {
    return GetField<int32_t>(VT_PNT_TYPE, 0);
  }
  float pnt_para() const {
    return GetField<float>(VT_PNT_PARA, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PNT_TYPE, 4) &&
           VerifyField<float>(verifier, VT_PNT_PARA, 4) &&
           verifier.EndTable();
  }
  MoveInput_TypeT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MoveInput_TypeT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<MoveInput_Type> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MoveInput_TypeT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MoveInput_TypeBuilder {
  typedef MoveInput_Type Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_pnt_type(int32_t pnt_type) {
    fbb_.AddElement<int32_t>(MoveInput_Type::VT_PNT_TYPE, pnt_type, 0);
  }
  void add_pnt_para(float pnt_para) {
    fbb_.AddElement<float>(MoveInput_Type::VT_PNT_PARA, pnt_para, 0.0f);
  }
  explicit MoveInput_TypeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MoveInput_Type> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MoveInput_Type>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MoveInput_Type> CreateMoveInput_Type(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t pnt_type = 0,
    float pnt_para = 0.0f) {
  MoveInput_TypeBuilder builder_(_fbb);
  builder_.add_pnt_para(pnt_para);
  builder_.add_pnt_type(pnt_type);
  return builder_.Finish();
}

::flatbuffers::Offset<MoveInput_Type> CreateMoveInput_Type(::flatbuffers::FlatBufferBuilder &_fbb, const MoveInput_TypeT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MoveInput_SpeedT : public ::flatbuffers::NativeTable {
  typedef MoveInput_Speed TableType;
  int32_t spd_mode = 0;
  float spd_vel_para = 0.0f;
  float spd_acc_para = 0.0f;
};

struct MoveInput_Speed FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MoveInput_SpeedT NativeTableType;
  typedef MoveInput_SpeedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SPD_MODE = 4,
    VT_SPD_VEL_PARA = 6,
    VT_SPD_ACC_PARA = 8
  };
  int32_t spd_mode() const {
    return GetField<int32_t>(VT_SPD_MODE, 0);
  }
  float spd_vel_para() const {
    return GetField<float>(VT_SPD_VEL_PARA, 0.0f);
  }
  float spd_acc_para() const {
    return GetField<float>(VT_SPD_ACC_PARA, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SPD_MODE, 4) &&
           VerifyField<float>(verifier, VT_SPD_VEL_PARA, 4) &&
           VerifyField<float>(verifier, VT_SPD_ACC_PARA, 4) &&
           verifier.EndTable();
  }
  MoveInput_SpeedT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MoveInput_SpeedT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<MoveInput_Speed> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MoveInput_SpeedT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MoveInput_SpeedBuilder {
  typedef MoveInput_Speed Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_spd_mode(int32_t spd_mode) {
    fbb_.AddElement<int32_t>(MoveInput_Speed::VT_SPD_MODE, spd_mode, 0);
  }
  void add_spd_vel_para(float spd_vel_para) {
    fbb_.AddElement<float>(MoveInput_Speed::VT_SPD_VEL_PARA, spd_vel_para, 0.0f);
  }
  void add_spd_acc_para(float spd_acc_para) {
    fbb_.AddElement<float>(MoveInput_Speed::VT_SPD_ACC_PARA, spd_acc_para, 0.0f);
  }
  explicit MoveInput_SpeedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MoveInput_Speed> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MoveInput_Speed>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MoveInput_Speed> CreateMoveInput_Speed(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t spd_mode = 0,
    float spd_vel_para = 0.0f,
    float spd_acc_para = 0.0f) {
  MoveInput_SpeedBuilder builder_(_fbb);
  builder_.add_spd_acc_para(spd_acc_para);
  builder_.add_spd_vel_para(spd_vel_para);
  builder_.add_spd_mode(spd_mode);
  return builder_.Finish();
}

::flatbuffers::Offset<MoveInput_Speed> CreateMoveInput_Speed(::flatbuffers::FlatBufferBuilder &_fbb, const MoveInput_SpeedT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline MoveInput_TargetT::MoveInput_TargetT(const MoveInput_TargetT &o)
      : tar_values((o.tar_values) ? new IPC::N_INPUT_f(*o.tar_values) : nullptr),
        tar_frame(o.tar_frame),
        tar_unit(o.tar_unit) {
}

inline MoveInput_TargetT &MoveInput_TargetT::operator=(MoveInput_TargetT o) FLATBUFFERS_NOEXCEPT {
  std::swap(tar_values, o.tar_values);
  std::swap(tar_frame, o.tar_frame);
  std::swap(tar_unit, o.tar_unit);
  return *this;
}

inline MoveInput_TargetT *MoveInput_Target::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MoveInput_TargetT>(new MoveInput_TargetT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MoveInput_Target::UnPackTo(MoveInput_TargetT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = tar_values(); if (_e) _o->tar_values = std::unique_ptr<IPC::N_INPUT_f>(new IPC::N_INPUT_f(*_e)); }
  { auto _e = tar_frame(); _o->tar_frame = _e; }
  { auto _e = tar_unit(); _o->tar_unit = _e; }
}

inline ::flatbuffers::Offset<MoveInput_Target> MoveInput_Target::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MoveInput_TargetT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMoveInput_Target(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<MoveInput_Target> CreateMoveInput_Target(::flatbuffers::FlatBufferBuilder &_fbb, const MoveInput_TargetT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const MoveInput_TargetT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _tar_values = _o->tar_values ? _o->tar_values.get() : nullptr;
  auto _tar_frame = _o->tar_frame;
  auto _tar_unit = _o->tar_unit;
  return IPC::CreateMoveInput_Target(
      _fbb,
      _tar_values,
      _tar_frame,
      _tar_unit);
}

inline MoveInput_TypeT *MoveInput_Type::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MoveInput_TypeT>(new MoveInput_TypeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MoveInput_Type::UnPackTo(MoveInput_TypeT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = pnt_type(); _o->pnt_type = _e; }
  { auto _e = pnt_para(); _o->pnt_para = _e; }
}

inline ::flatbuffers::Offset<MoveInput_Type> MoveInput_Type::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MoveInput_TypeT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMoveInput_Type(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<MoveInput_Type> CreateMoveInput_Type(::flatbuffers::FlatBufferBuilder &_fbb, const MoveInput_TypeT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const MoveInput_TypeT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _pnt_type = _o->pnt_type;
  auto _pnt_para = _o->pnt_para;
  return IPC::CreateMoveInput_Type(
      _fbb,
      _pnt_type,
      _pnt_para);
}

inline MoveInput_SpeedT *MoveInput_Speed::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MoveInput_SpeedT>(new MoveInput_SpeedT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MoveInput_Speed::UnPackTo(MoveInput_SpeedT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = spd_mode(); _o->spd_mode = _e; }
  { auto _e = spd_vel_para(); _o->spd_vel_para = _e; }
  { auto _e = spd_acc_para(); _o->spd_acc_para = _e; }
}

inline ::flatbuffers::Offset<MoveInput_Speed> MoveInput_Speed::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MoveInput_SpeedT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMoveInput_Speed(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<MoveInput_Speed> CreateMoveInput_Speed(::flatbuffers::FlatBufferBuilder &_fbb, const MoveInput_SpeedT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const MoveInput_SpeedT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _spd_mode = _o->spd_mode;
  auto _spd_vel_para = _o->spd_vel_para;
  auto _spd_acc_para = _o->spd_acc_para;
  return IPC::CreateMoveInput_Speed(
      _fbb,
      _spd_mode,
      _spd_vel_para,
      _spd_acc_para);
}

}  // namespace IPC

#endif  // FLATBUFFERS_GENERATED_COMMONSTRUCT_IPC_H_
