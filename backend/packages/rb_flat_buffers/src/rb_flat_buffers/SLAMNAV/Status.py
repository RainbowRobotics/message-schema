# automatically generated by the FlatBuffers compiler, do not modify

# namespace: SLAMNAV

import flatbuffers
from flatbuffers.compat import import_numpy
from typing import Any
from rb_flat_buffers.SLAMNAV.Status_Condition import Status_Condition, Status_ConditionT
from rb_flat_buffers.SLAMNAV.Status_Imu import Status_Imu, Status_ImuT
from rb_flat_buffers.SLAMNAV.Status_Map import Status_Map, Status_MapT
from rb_flat_buffers.SLAMNAV.Status_Motor import Status_Motor, Status_MotorT
from rb_flat_buffers.SLAMNAV.Status_Power import Status_Power, Status_PowerT
from rb_flat_buffers.SLAMNAV.Status_Robot_Safety_Io_State import Status_Robot_Safety_Io_State, Status_Robot_Safety_Io_StateT
from rb_flat_buffers.SLAMNAV.Status_Robot_State import Status_Robot_State, Status_Robot_StateT
from rb_flat_buffers.SLAMNAV.Status_Setting import Status_Setting, Status_SettingT
from typing import Optional
np = import_numpy()

class Status(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Status()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsStatus(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # Status
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Status
    def Imu(self) -> Optional[Status_Imu]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            obj = Status_Imu()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Status
    def Motor0(self) -> Optional[Status_Motor]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            obj = Status_Motor()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Status
    def Motor1(self) -> Optional[Status_Motor]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            obj = Status_Motor()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Status
    def Condition(self) -> Optional[Status_Condition]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            obj = Status_Condition()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Status
    def RobotState(self) -> Optional[Status_Robot_State]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            obj = Status_Robot_State()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Status
    def RobotSafetyIoState(self) -> Optional[Status_Robot_Safety_Io_State]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            obj = Status_Robot_Safety_Io_State()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Status
    def Power(self) -> Optional[Status_Power]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            obj = Status_Power()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Status
    def Setting(self) -> Optional[Status_Setting]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            obj = Status_Setting()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Status
    def Map(self) -> Optional[Status_Map]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            obj = Status_Map()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

def StatusStart(builder: flatbuffers.Builder):
    builder.StartObject(9)

def Start(builder: flatbuffers.Builder):
    StatusStart(builder)

def StatusAddImu(builder: flatbuffers.Builder, imu: int):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(imu), 0)

def AddImu(builder: flatbuffers.Builder, imu: int):
    StatusAddImu(builder, imu)

def StatusAddMotor0(builder: flatbuffers.Builder, motor0: int):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(motor0), 0)

def AddMotor0(builder: flatbuffers.Builder, motor0: int):
    StatusAddMotor0(builder, motor0)

def StatusAddMotor1(builder: flatbuffers.Builder, motor1: int):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(motor1), 0)

def AddMotor1(builder: flatbuffers.Builder, motor1: int):
    StatusAddMotor1(builder, motor1)

def StatusAddCondition(builder: flatbuffers.Builder, condition: int):
    builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(condition), 0)

def AddCondition(builder: flatbuffers.Builder, condition: int):
    StatusAddCondition(builder, condition)

def StatusAddRobotState(builder: flatbuffers.Builder, robotState: int):
    builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(robotState), 0)

def AddRobotState(builder: flatbuffers.Builder, robotState: int):
    StatusAddRobotState(builder, robotState)

def StatusAddRobotSafetyIoState(builder: flatbuffers.Builder, robotSafetyIoState: int):
    builder.PrependUOffsetTRelativeSlot(5, flatbuffers.number_types.UOffsetTFlags.py_type(robotSafetyIoState), 0)

def AddRobotSafetyIoState(builder: flatbuffers.Builder, robotSafetyIoState: int):
    StatusAddRobotSafetyIoState(builder, robotSafetyIoState)

def StatusAddPower(builder: flatbuffers.Builder, power: int):
    builder.PrependUOffsetTRelativeSlot(6, flatbuffers.number_types.UOffsetTFlags.py_type(power), 0)

def AddPower(builder: flatbuffers.Builder, power: int):
    StatusAddPower(builder, power)

def StatusAddSetting(builder: flatbuffers.Builder, setting: int):
    builder.PrependUOffsetTRelativeSlot(7, flatbuffers.number_types.UOffsetTFlags.py_type(setting), 0)

def AddSetting(builder: flatbuffers.Builder, setting: int):
    StatusAddSetting(builder, setting)

def StatusAddMap(builder: flatbuffers.Builder, map: int):
    builder.PrependUOffsetTRelativeSlot(8, flatbuffers.number_types.UOffsetTFlags.py_type(map), 0)

def AddMap(builder: flatbuffers.Builder, map: int):
    StatusAddMap(builder, map)

def StatusEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()

def End(builder: flatbuffers.Builder) -> int:
    return StatusEnd(builder)

try:
    from typing import Optional
except:
    pass

class StatusT(object):

    # StatusT
    def __init__(self):
        self.imu = None  # type: Optional[Status_ImuT]
        self.motor0 = None  # type: Optional[Status_MotorT]
        self.motor1 = None  # type: Optional[Status_MotorT]
        self.condition = None  # type: Optional[Status_ConditionT]
        self.robotState = None  # type: Optional[Status_Robot_StateT]
        self.robotSafetyIoState = None  # type: Optional[Status_Robot_Safety_Io_StateT]
        self.power = None  # type: Optional[Status_PowerT]
        self.setting = None  # type: Optional[Status_SettingT]
        self.map = None  # type: Optional[Status_MapT]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        status = Status()
        status.Init(buf, pos)
        return cls.InitFromObj(status)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, status):
        x = StatusT()
        x._UnPack(status)
        return x

    # StatusT
    def _UnPack(self, status):
        if status is None:
            return
        if status.Imu() is not None:
            self.imu = Status_ImuT.InitFromObj(status.Imu())
        if status.Motor0() is not None:
            self.motor0 = Status_MotorT.InitFromObj(status.Motor0())
        if status.Motor1() is not None:
            self.motor1 = Status_MotorT.InitFromObj(status.Motor1())
        if status.Condition() is not None:
            self.condition = Status_ConditionT.InitFromObj(status.Condition())
        if status.RobotState() is not None:
            self.robotState = Status_Robot_StateT.InitFromObj(status.RobotState())
        if status.RobotSafetyIoState() is not None:
            self.robotSafetyIoState = Status_Robot_Safety_Io_StateT.InitFromObj(status.RobotSafetyIoState())
        if status.Power() is not None:
            self.power = Status_PowerT.InitFromObj(status.Power())
        if status.Setting() is not None:
            self.setting = Status_SettingT.InitFromObj(status.Setting())
        if status.Map() is not None:
            self.map = Status_MapT.InitFromObj(status.Map())

    # StatusT
    def Pack(self, builder):
        if self.imu is not None:
            imu = self.imu.Pack(builder)
        if self.motor0 is not None:
            motor0 = self.motor0.Pack(builder)
        if self.motor1 is not None:
            motor1 = self.motor1.Pack(builder)
        if self.condition is not None:
            condition = self.condition.Pack(builder)
        if self.robotState is not None:
            robotState = self.robotState.Pack(builder)
        if self.robotSafetyIoState is not None:
            robotSafetyIoState = self.robotSafetyIoState.Pack(builder)
        if self.power is not None:
            power = self.power.Pack(builder)
        if self.setting is not None:
            setting = self.setting.Pack(builder)
        if self.map is not None:
            map = self.map.Pack(builder)
        StatusStart(builder)
        if self.imu is not None:
            StatusAddImu(builder, imu)
        if self.motor0 is not None:
            StatusAddMotor0(builder, motor0)
        if self.motor1 is not None:
            StatusAddMotor1(builder, motor1)
        if self.condition is not None:
            StatusAddCondition(builder, condition)
        if self.robotState is not None:
            StatusAddRobotState(builder, robotState)
        if self.robotSafetyIoState is not None:
            StatusAddRobotSafetyIoState(builder, robotSafetyIoState)
        if self.power is not None:
            StatusAddPower(builder, power)
        if self.setting is not None:
            StatusAddSetting(builder, setting)
        if self.map is not None:
            StatusAddMap(builder, map)
        status = StatusEnd(builder)
        return status
