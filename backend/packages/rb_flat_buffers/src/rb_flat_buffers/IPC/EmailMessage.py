# automatically generated by the FlatBuffers compiler, do not modify

# namespace: IPC

import flatbuffers
from flatbuffers.compat import import_numpy
from typing import Any
from rb_flat_buffers.IPC.FileMessage import FileMessage, FileMessageT
from typing import Optional
np = import_numpy()

class EmailMessage(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = EmailMessage()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsEmailMessage(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # EmailMessage
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # EmailMessage
    def FromEmail(self) -> Optional[str]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # EmailMessage
    def ToEmail(self) -> Optional[str]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # EmailMessage
    def Subject(self) -> Optional[str]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # EmailMessage
    def Body(self) -> Optional[str]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # EmailMessage
    def Attachment(self, j: int) -> Optional[FileMessage]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = FileMessage()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # EmailMessage
    def AttachmentLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # EmailMessage
    def AttachmentIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        return o == 0

def EmailMessageStart(builder: flatbuffers.Builder):
    builder.StartObject(5)

def Start(builder: flatbuffers.Builder):
    EmailMessageStart(builder)

def EmailMessageAddFromEmail(builder: flatbuffers.Builder, fromEmail: int):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(fromEmail), 0)

def AddFromEmail(builder: flatbuffers.Builder, fromEmail: int):
    EmailMessageAddFromEmail(builder, fromEmail)

def EmailMessageAddToEmail(builder: flatbuffers.Builder, toEmail: int):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(toEmail), 0)

def AddToEmail(builder: flatbuffers.Builder, toEmail: int):
    EmailMessageAddToEmail(builder, toEmail)

def EmailMessageAddSubject(builder: flatbuffers.Builder, subject: int):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(subject), 0)

def AddSubject(builder: flatbuffers.Builder, subject: int):
    EmailMessageAddSubject(builder, subject)

def EmailMessageAddBody(builder: flatbuffers.Builder, body: int):
    builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(body), 0)

def AddBody(builder: flatbuffers.Builder, body: int):
    EmailMessageAddBody(builder, body)

def EmailMessageAddAttachment(builder: flatbuffers.Builder, attachment: int):
    builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(attachment), 0)

def AddAttachment(builder: flatbuffers.Builder, attachment: int):
    EmailMessageAddAttachment(builder, attachment)

def EmailMessageStartAttachmentVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def StartAttachmentVector(builder, numElems: int) -> int:
    return EmailMessageStartAttachmentVector(builder, numElems)

def EmailMessageEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()

def End(builder: flatbuffers.Builder) -> int:
    return EmailMessageEnd(builder)

try:
    from typing import List
except:
    pass

class EmailMessageT(object):

    # EmailMessageT
    def __init__(self):
        self.fromEmail = None  # type: str
        self.toEmail = None  # type: str
        self.subject = None  # type: str
        self.body = None  # type: str
        self.attachment = None  # type: List[FileMessageT]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        emailMessage = EmailMessage()
        emailMessage.Init(buf, pos)
        return cls.InitFromObj(emailMessage)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, emailMessage):
        x = EmailMessageT()
        x._UnPack(emailMessage)
        return x

    # EmailMessageT
    def _UnPack(self, emailMessage):
        if emailMessage is None:
            return
        self.fromEmail = emailMessage.FromEmail()
        self.toEmail = emailMessage.ToEmail()
        self.subject = emailMessage.Subject()
        self.body = emailMessage.Body()
        if not emailMessage.AttachmentIsNone():
            self.attachment = []
            for i in range(emailMessage.AttachmentLength()):
                if emailMessage.Attachment(i) is None:
                    self.attachment.append(None)
                else:
                    fileMessage_ = FileMessageT.InitFromObj(emailMessage.Attachment(i))
                    self.attachment.append(fileMessage_)

    # EmailMessageT
    def Pack(self, builder):
        if self.fromEmail is not None:
            fromEmail = builder.CreateString(self.fromEmail)
        if self.toEmail is not None:
            toEmail = builder.CreateString(self.toEmail)
        if self.subject is not None:
            subject = builder.CreateString(self.subject)
        if self.body is not None:
            body = builder.CreateString(self.body)
        if self.attachment is not None:
            attachmentlist = []
            for i in range(len(self.attachment)):
                attachmentlist.append(self.attachment[i].Pack(builder))
            EmailMessageStartAttachmentVector(builder, len(self.attachment))
            for i in reversed(range(len(self.attachment))):
                builder.PrependUOffsetTRelative(attachmentlist[i])
            attachment = builder.EndVector()
        EmailMessageStart(builder)
        if self.fromEmail is not None:
            EmailMessageAddFromEmail(builder, fromEmail)
        if self.toEmail is not None:
            EmailMessageAddToEmail(builder, toEmail)
        if self.subject is not None:
            EmailMessageAddSubject(builder, subject)
        if self.body is not None:
            EmailMessageAddBody(builder, body)
        if self.attachment is not None:
            EmailMessageAddAttachment(builder, attachment)
        emailMessage = EmailMessageEnd(builder)
        return emailMessage
