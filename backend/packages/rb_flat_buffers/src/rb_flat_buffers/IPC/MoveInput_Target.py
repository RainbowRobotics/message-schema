# automatically generated by the FlatBuffers compiler, do not modify

# namespace: IPC

import flatbuffers
from flatbuffers.compat import import_numpy
from typing import Any
from rb_flat_buffers.IPC.N_INPUT_f import N_INPUT_f, N_INPUT_fT
from typing import Optional
np = import_numpy()

class MoveInput_Target(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = MoveInput_Target()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsMoveInput_Target(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # MoveInput_Target
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # MoveInput_Target
    def TarValues(self) -> Optional[N_INPUT_f]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            x = o + self._tab.Pos
            obj = N_INPUT_f()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # MoveInput_Target
    def TarFrame(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

    # MoveInput_Target
    def TarUnit(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

def MoveInput_TargetStart(builder: flatbuffers.Builder):
    builder.StartObject(3)

def Start(builder: flatbuffers.Builder):
    MoveInput_TargetStart(builder)

def MoveInput_TargetAddTarValues(builder: flatbuffers.Builder, tarValues: Any):
    builder.PrependStructSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(tarValues), 0)

def AddTarValues(builder: flatbuffers.Builder, tarValues: Any):
    MoveInput_TargetAddTarValues(builder, tarValues)

def MoveInput_TargetAddTarFrame(builder: flatbuffers.Builder, tarFrame: int):
    builder.PrependInt32Slot(1, tarFrame, 0)

def AddTarFrame(builder: flatbuffers.Builder, tarFrame: int):
    MoveInput_TargetAddTarFrame(builder, tarFrame)

def MoveInput_TargetAddTarUnit(builder: flatbuffers.Builder, tarUnit: int):
    builder.PrependInt32Slot(2, tarUnit, 0)

def AddTarUnit(builder: flatbuffers.Builder, tarUnit: int):
    MoveInput_TargetAddTarUnit(builder, tarUnit)

def MoveInput_TargetEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()

def End(builder: flatbuffers.Builder) -> int:
    return MoveInput_TargetEnd(builder)

try:
    from typing import Optional
except:
    pass

class MoveInput_TargetT(object):

    # MoveInput_TargetT
    def __init__(self):
        self.tarValues = None  # type: Optional[N_INPUT_fT]
        self.tarFrame = 0  # type: int
        self.tarUnit = 0  # type: int

    @classmethod
    def InitFromBuf(cls, buf, pos):
        moveInputTarget = MoveInput_Target()
        moveInputTarget.Init(buf, pos)
        return cls.InitFromObj(moveInputTarget)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, moveInputTarget):
        x = MoveInput_TargetT()
        x._UnPack(moveInputTarget)
        return x

    # MoveInput_TargetT
    def _UnPack(self, moveInputTarget):
        if moveInputTarget is None:
            return
        if moveInputTarget.TarValues() is not None:
            self.tarValues = N_INPUT_fT.InitFromObj(moveInputTarget.TarValues())
        self.tarFrame = moveInputTarget.TarFrame()
        self.tarUnit = moveInputTarget.TarUnit()

    # MoveInput_TargetT
    def Pack(self, builder):
        MoveInput_TargetStart(builder)
        if self.tarValues is not None:
            tarValues = self.tarValues.Pack(builder)
            MoveInput_TargetAddTarValues(builder, tarValues)
        MoveInput_TargetAddTarFrame(builder, self.tarFrame)
        MoveInput_TargetAddTarUnit(builder, self.tarUnit)
        moveInputTarget = MoveInput_TargetEnd(builder)
        return moveInputTarget
