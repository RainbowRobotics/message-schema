#include "config.h"

CONFIG* CONFIG::instance(QObject* parent)
{
    static CONFIG* inst = nullptr;
    if(!inst && parent)
    {
        inst = new CONFIG(parent);
    }
    else if(inst && parent && inst->parent() == nullptr)
    {
        inst->setParent(parent);
    }
    return inst;
}

CONFIG::CONFIG(QObject *parent)
    : QObject{parent}
{

}

CONFIG::~CONFIG()
{

}

bool CONFIG::load_common(QString path)
{
    QFile common_file(path);
    if(!common_file.open(QIODevice::ReadOnly | QIODevice::Text))
    {
        qWarning() << "[CONFIG] Failed to open common file:" << config_path;
        return false;
    }

    QByteArray data = common_file.readAll();
    common_file.close();

    QJsonParseError parseError;
    QJsonDocument doc = QJsonDocument::fromJson(data, &parseError);
    if(parseError.error != QJsonParseError::NoError)
    {
        qWarning() << "[CONFIG] common JSON parse error:" << parseError.errorString();
        return false;
    }

    QJsonObject obj = doc.object();

    if(obj.contains("PLATFORM_NAME"))
    {
        PLATFORM_NAME = obj["PLATFORM_NAME"].toString();
    }

    // complete
    common_file.close();
    return true;
}

void CONFIG::set_config_path(const QString &path)
{
    std::lock_guard<std::mutex> lock(mtx);
    config_path = path;
}

void CONFIG::load()
{
    // 누락된 변수 리스트 초기화
    missing_variables.clear();
    
    QFile config_file(config_path);
    if(!config_file.open(QIODevice::ReadOnly | QIODevice::Text))
    {
        qWarning() << "[CONFIG] Failed to open config file:" << config_path;
        return;
    }

    QByteArray data = config_file.readAll();
    config_file.close();

    QJsonParseError parseError;
    QJsonDocument doc = QJsonDocument::fromJson(data, &parseError);
    if(parseError.error != QJsonParseError::NoError)
    {
        qWarning() << "[CONFIG] JSON parse error:" << parseError.errorString();
        return;
    }

    QJsonObject obj = doc.object();

    // 각 섹션별로 설정 로드
    load_robot_config(obj);
    load_sensors_config(obj);
    load_localization_config(obj);
    load_network_config(obj);
    load_debug_config(obj);
    load_motor_config(obj);
    load_mapping_config(obj);
    load_obstacle_config(obj);
    load_control_config(obj);
    load_docking_config(obj);
    load_map_config(obj);
    load_lidar_configs(obj);
    load_camera_configs(obj);
    load_sensor_specific_configs(obj);

    // complete
    is_load = true;
    config_file.close();
    printf("[CONFIG] %s, load successed\n", qUtf8Printable(config_path));
    
    // 누락된 변수들이 있으면 경고 표시
    if(has_missing_variables())
    {
        show_missing_variables_dialog();
    }
}

// 헬퍼 함수들 구현
void CONFIG::add_missing_variable(const QString& section, const QString& variable)
{
    missing_variables.append(section + "." + variable);
}

void CONFIG::check_and_set_string(const QJsonObject& obj, const QString& key, QString& target, const QString& section)
{
    if(obj.contains(key) && !obj[key].toString().isEmpty())
    {
        target = obj[key].toString();
        printf("[CONFIG] %s, %s\n", qUtf8Printable(key), qUtf8Printable(target));
    }
    else
    {
        add_missing_variable(section, key);
    }
}

void CONFIG::check_and_set_bool(const QJsonObject& obj, const QString& key, bool& target, const QString& section)
{
    if(obj.contains(key))
    {
        target = obj[key].toBool();
        printf("[CONFIG] %s, %s\n", qUtf8Printable(key), target ? "true" : "false");
    }
    else
    {
        add_missing_variable(section, key);
    }
}

void CONFIG::check_and_set_int(const QJsonObject& obj, const QString& key, int& target, const QString& section)
{
    if(obj.contains(key))
    {
        target = obj[key].toString().toInt();
        printf("[CONFIG] %s, %s\n", qUtf8Printable(key), obj[key].toString().toLocal8Bit().data());
    }
    else
    {
        add_missing_variable(section, key);
    }
}

void CONFIG::check_and_set_double(const QJsonObject& obj, const QString& key, double& target, const QString& section)
{
    if(obj.contains(key))
    {
        target = obj[key].toString().toDouble();
        printf("[CONFIG] %s, %s\n", qUtf8Printable(key), obj[key].toString().toLocal8Bit().data());
    }
    else
    {
        add_missing_variable(section, key);
    }
}

void CONFIG::load_robot_config(const QJsonObject& obj)
{
    QJsonObject obj_robot = obj["robot"].toObject();
    
    check_and_set_string(obj_robot, "PLATFORM_NAME", PLATFORM_NAME, "robot");
    check_and_set_string(obj_robot, "PLATFORM_TYPE", PLATFORM_TYPE, "robot");
    check_and_set_double(obj_robot, "ROBOT_SIZE_MIN_X", ROBOT_SIZE_X[0], "robot");
    check_and_set_double(obj_robot, "ROBOT_SIZE_MAX_X", ROBOT_SIZE_X[1], "robot");
    check_and_set_double(obj_robot, "ROBOT_SIZE_MIN_Y", ROBOT_SIZE_Y[0], "robot");
    check_and_set_double(obj_robot, "ROBOT_SIZE_MAX_Y", ROBOT_SIZE_Y[1], "robot");
    check_and_set_double(obj_robot, "ROBOT_SIZE_MIN_Z", ROBOT_SIZE_Z[0], "robot");
    check_and_set_double(obj_robot, "ROBOT_SIZE_MAX_Z", ROBOT_SIZE_Z[1], "robot");
    check_and_set_double(obj_robot, "ROBOT_WHEEL_RADIUS", ROBOT_WHEEL_RADIUS, "robot");
    check_and_set_double(obj_robot, "ROBOT_WHEEL_BASE", ROBOT_WHEEL_BASE, "robot");

    // robot radius calculation
    double lx = std::max<double>(std::abs(ROBOT_SIZE_X[0]), std::abs(ROBOT_SIZE_X[1]));
    double ly = std::max<double>(std::abs(ROBOT_SIZE_Y[0]), std::abs(ROBOT_SIZE_Y[1]));
    ROBOT_RADIUS = std::sqrt(lx*lx + ly*ly);
    printf("[CONFIG] ROBOT_RADIUS(auto calc), %.3f\n", ROBOT_RADIUS);
}

void CONFIG::load_sensors_config(const QJsonObject& obj)
{
    QJsonObject obj_sensors = obj["sensors"].toObject();
    
    check_and_set_bool(obj_sensors, "USE_LIDAR_2D", USE_LIDAR_2D, "sensors");
    check_and_set_string(obj_sensors, "LIDAR_2D_TYPE", LIDAR_2D_TYPE, "sensors");
    check_and_set_int(obj_sensors, "LIDAR_2D_NUM", LIDAR_2D_NUM, "sensors");
    check_and_set_bool(obj_sensors, "USE_LIDAR_3D", USE_LIDAR_3D, "sensors");
    check_and_set_string(obj_sensors, "LIDAR_3D_TYPE", LIDAR_3D_TYPE, "sensors");
    check_and_set_int(obj_sensors, "LIDAR_3D_NUM", LIDAR_3D_NUM, "sensors");
    check_and_set_bool(obj_sensors, "USE_CAM", USE_CAM, "sensors");
    check_and_set_int(obj_sensors, "CAM_NUM", CAM_NUM, "sensors");
    check_and_set_bool(obj_sensors, "USE_BQR", USE_BQR, "sensors");
    check_and_set_bool(obj_sensors, "USE_IMU", USE_IMU, "sensors");
}

void CONFIG::load_localization_config(const QJsonObject& obj)
{
    QJsonObject obj_loc = obj["localization"].toObject();
    
    check_and_set_string(obj_loc, "MODE", LOC_MODE, "localization");
    check_and_set_bool(obj_loc, "USE_ARUCO", USE_ARUCO, "localization");

    // localization mode에 따른 추가 설정 로드
    if(LOC_MODE == "2D")
    {
        load_localization_2d_config(obj);
    }
    else if(LOC_MODE == "3D")
    {
        load_localization_3d_config(obj);
    }
}

void CONFIG::load_network_config(const QJsonObject& obj)
{
    QJsonObject obj_net = obj["network"].toObject();
    
    check_and_set_bool(obj_net, "USE_MULTI", USE_MULTI, "network");
    check_and_set_bool(obj_net, "USE_COOP", USE_COMM_COOP, "network");
    check_and_set_bool(obj_net, "USE_RTSP", USE_COMM_RTSP, "network");
    check_and_set_bool(obj_net, "USE_RRS", USE_COMM_RRS, "network");
    check_and_set_bool(obj_net, "USE_FMS", USE_COMM_FMS, "network");
}

void CONFIG::load_debug_config(const QJsonObject& obj)
{
    QJsonObject obj_debug = obj["debug"].toObject();
    
    check_and_set_bool(obj_debug, "USE_SIM", USE_SIM, "debug");
    check_and_set_bool(obj_debug, "USE_BEEP", USE_BEEP, "debug");
}

void CONFIG::load_motor_config(const QJsonObject& obj)
{
    QJsonObject obj_motor = obj["motor"].toObject();
    
    check_and_set_int(obj_motor, "MOTOR_ID_L", MOTOR_ID_L, "motor");
    check_and_set_int(obj_motor, "MOTOR_ID_R", MOTOR_ID_R, "motor");
    check_and_set_double(obj_motor, "MOTOR_DIR", MOTOR_DIR, "motor");
    check_and_set_double(obj_motor, "MOTOR_GEAR_RATIO", MOTOR_GEAR_RATIO, "motor");
    check_and_set_double(obj_motor, "MOTOR_LIMIT_V", MOTOR_LIMIT_V, "motor");
    check_and_set_double(obj_motor, "MOTOR_LIMIT_V_ACC", MOTOR_LIMIT_V_ACC, "motor");
    check_and_set_double(obj_motor, "MOTOR_LIMIT_W", MOTOR_LIMIT_W, "motor");
        if(obj_robot.contains("PLATFORM_NAME") && !obj_robot["PLATFORM_NAME"].toString().isEmpty())
        {
            PLATFORM_NAME = obj_robot["PLATFORM_NAME"].toString();
            printf("[CONFIG] PLATFORM_NAME, %s\n", obj_robot["PLATFORM_NAME"].toString().toLocal8Bit().data());
        }
        else
        {
            missing_variables.append("robot.PLATFORM_NAME");
        }

        if(obj_robot.contains("PLATFORM_TYPE") && !obj_robot["PLATFORM_TYPE"].toString().isEmpty())
        {
            PLATFORM_TYPE = obj_robot["PLATFORM_TYPE"].toString();
            printf("[CONFIG] PLATFORM_TYPE, %s\n", obj_robot["PLATFORM_TYPE"].toString().toLocal8Bit().data());
        }
        else
        {
            missing_variables.append("robot.PLATFORM_TYPE");
        }

        if(obj_robot.contains("ROBOT_SIZE_MIN_X"))
        {
            ROBOT_SIZE_X[0] = obj_robot["ROBOT_SIZE_MIN_X"].toString().toDouble();
            printf("[CONFIG] ROBOT_SIZE_MIN_X, %s\n", obj_robot["ROBOT_SIZE_MIN_X"].toString().toLocal8Bit().data());
        }
        else
        {
            missing_variables.append("robot.ROBOT_SIZE_MIN_X");
        }

        if(obj_robot.contains("ROBOT_SIZE_MAX_X"))
        {
            ROBOT_SIZE_X[1] = obj_robot["ROBOT_SIZE_MAX_X"].toString().toDouble();
            printf("[CONFIG] ROBOT_SIZE_MAX_X, %s\n", obj_robot["ROBOT_SIZE_MAX_X"].toString().toLocal8Bit().data());
        }
        else
        {
            missing_variables.append("robot.ROBOT_SIZE_MAX_X");
        }

        if(obj_robot.contains("ROBOT_SIZE_MIN_Y"))
        {
            ROBOT_SIZE_Y[0] = obj_robot["ROBOT_SIZE_MIN_Y"].toString().toDouble();
            printf("[CONFIG] ROBOT_SIZE_MIN_Y, %s\n", obj_robot["ROBOT_SIZE_MIN_Y"].toString().toLocal8Bit().data());
        }
        else
        {
            missing_variables.append("robot.ROBOT_SIZE_MIN_Y");
        }

        if(obj_robot.contains("ROBOT_SIZE_MAX_Y"))
        {
            ROBOT_SIZE_Y[1] = obj_robot["ROBOT_SIZE_MAX_Y"].toString().toDouble();
            printf("[CONFIG] ROBOT_SIZE_MAX_Y, %s\n", obj_robot["ROBOT_SIZE_MAX_Y"].toString().toLocal8Bit().data());
        }
        else
        {
            missing_variables.append("robot.ROBOT_SIZE_MAX_Y");
        }

        if(obj_robot.contains("ROBOT_SIZE_MIN_Z"))
        {
            ROBOT_SIZE_Z[0] = obj_robot["ROBOT_SIZE_MIN_Z"].toString().toDouble();
            printf("[CONFIG] ROBOT_SIZE_MIN_Z, %s\n", obj_robot["ROBOT_SIZE_MIN_Z"].toString().toLocal8Bit().data());
        }
        else
        {
            missing_variables.append("robot.ROBOT_SIZE_MIN_Z");
        }

        if(obj_robot.contains("ROBOT_SIZE_MAX_Z"))
        {
            ROBOT_SIZE_Z[1] = obj_robot["ROBOT_SIZE_MAX_Z"].toString().toDouble();
            printf("[CONFIG] ROBOT_SIZE_MAX_Z, %s\n", obj_robot["ROBOT_SIZE_MAX_Z"].toString().toLocal8Bit().data());
        }
        else
        {
            missing_variables.append("robot.ROBOT_SIZE_MAX_Z");
        }

        // robot radius calculation
        double lx = std::max<double>(std::abs(ROBOT_SIZE_X[0]), std::abs(ROBOT_SIZE_X[1]));
        double ly = std::max<double>(std::abs(ROBOT_SIZE_Y[0]), std::abs(ROBOT_SIZE_Y[1]));
        ROBOT_RADIUS = std::sqrt(lx*lx + ly*ly);
        printf("[CONFIG] ROBOT_RADIUS(auto calc), %.3f\n", ROBOT_RADIUS);

        if(obj_robot.contains("ROBOT_WHEEL_RADIUS"))
        {
            ROBOT_WHEEL_RADIUS = obj_robot["ROBOT_WHEEL_RADIUS"].toString().toDouble();
            printf("[CONFIG] ROBOT_WHEEL_RADIUS, %s\n", obj_robot["ROBOT_WHEEL_RADIUS"].toString().toLocal8Bit().data());
        }
        else
        {
            missing_variables.append("robot.ROBOT_WHEEL_RADIUS");
        }

        if(obj_robot.contains("ROBOT_WHEEL_BASE"))
        {
            ROBOT_WHEEL_BASE = obj_robot["ROBOT_WHEEL_BASE"].toString().toDouble();
            printf("[CONFIG] ROBOT_WHEEL_BASE, %s\n", obj_robot["ROBOT_WHEEL_BASE"].toString().toLocal8Bit().data());
        }
        else
        {
            missing_variables.append("robot.ROBOT_WHEEL_BASE");
        }
    }

    QJsonObject obj_sensors = obj["sensors"].toObject();
    {
        if(obj_sensors.contains("USE_LIDAR_2D"))
        {
            USE_LIDAR_2D = obj_sensors["USE_LIDAR_2D"].toBool();
            printf("[CONFIG] USE_LIDAR_2D, %s\n", USE_LIDAR_2D ? "true" : "false");
        }
        else
        {
            missing_variables.append("sensors.USE_LIDAR_2D");
        }

        if(obj_sensors.contains("LIDAR_2D_TYPE") && !obj_sensors["LIDAR_2D_TYPE"].toString().isEmpty())
        {
            LIDAR_2D_TYPE = obj_sensors["LIDAR_2D_TYPE"].toString();
            printf("[CONFIG] LIDAR_2D_TYPE, %s\n", LIDAR_2D_TYPE.toLocal8Bit().data());
        }
        else
        {
            missing_variables.append("sensors.LIDAR_2D_TYPE");
        }

        if(obj_sensors.contains("LIDAR_2D_NUM"))
        {
            LIDAR_2D_NUM = obj_sensors["LIDAR_2D_NUM"].toString().toDouble();
            printf("[CONFIG] LIDAR_2D_NUM, %s\n", obj_sensors["LIDAR_2D_NUM"].toString().toLocal8Bit().data());
        }
        else
        {
            missing_variables.append("sensors.LIDAR_2D_NUM");
        }

        if(obj_sensors.contains("USE_LIDAR_3D"))
        {
            USE_LIDAR_3D = obj_sensors["USE_LIDAR_3D"].toBool();
            printf("[CONFIG] USE_LIDAR_3D, %s\n", USE_LIDAR_3D ? "true" : "false");
        }
        else
        {
            missing_variables.append("sensors.USE_LIDAR_3D");
        }

        if(obj_sensors.contains("LIDAR_3D_TYPE") && !obj_sensors["LIDAR_3D_TYPE"].toString().isEmpty())
        {
            LIDAR_3D_TYPE = obj_sensors["LIDAR_3D_TYPE"].toString();
            printf("[CONFIG] LIDAR_3D_TYPE, %s\n", LIDAR_3D_TYPE.toLocal8Bit().data());
        }
        else
        {
            missing_variables.append("sensors.LIDAR_3D_TYPE");
        }

        if(obj_sensors.contains("LIDAR_3D_NUM"))
        {
            LIDAR_3D_NUM = obj_sensors["LIDAR_3D_NUM"].toString().toDouble();
            printf("[CONFIG] LIDAR_3D_NUM, %s\n", obj_sensors["LIDAR_3D_NUM"].toString().toLocal8Bit().data());
        }
        else
        {
            missing_variables.append("sensors.LIDAR_3D_NUM");
        }

        if(obj_sensors.contains("USE_CAM"))
        {
            USE_CAM = obj_sensors["USE_CAM"].toBool();
            printf("[CONFIG] USE_CAM, %s\n", USE_CAM ? "true" : "false");
        }
        else
        {
            missing_variables.append("sensors.USE_CAM");
        }

        if(obj_sensors.contains("CAM_NUM"))
        {
            CAM_NUM = obj_sensors["CAM_NUM"].toString().toDouble();
            printf("[CONFIG] CAM_NUM, %s\n", obj_sensors["CAM_NUM"].toString().toLocal8Bit().data());
        }
        else
        {
            missing_variables.append("sensors.CAM_NUM");
        }

        if(obj_sensors.contains("USE_BQR"))
        {
            USE_BQR = obj_sensors["USE_BQR"].toBool();
            printf("[CONFIG] USE_BQR, %s\n", obj_sensors["USE_BQR"].toString().toLocal8Bit().data());
        }
        else
        {
            missing_variables.append("sensors.USE_BQR");
        }

        if(obj_sensors.contains("USE_IMU"))
        {
            USE_IMU = obj_sensors["USE_IMU"].toBool();
            printf("[CONFIG] USE_IMU, %s\n", obj_sensors["USE_IMU"].toString().toLocal8Bit().data());
        }
        else
        {
            missing_variables.append("sensors.USE_IMU");
        }
    }

    QJsonObject obj_loc = obj["localization"].toObject();
    {
        if(obj_loc.contains("MODE") && !obj_loc["MODE"].toString().isEmpty())
        {
            LOC_MODE = obj_loc["MODE"].toString();
            printf("[CONFIG] LOC_MODE, %s\n", obj_loc["MODE"].toString().toLocal8Bit().data());
        }
        else
        {
            missing_variables.append("localization.MODE");
        }

        if(obj_loc.contains("USE_ARUCO"))
        {
            USE_ARUCO = obj_loc["USE_ARUCO"].toBool();
            printf("[CONFIG] USE_ARUCO, %s\n", USE_ARUCO ? "true" : "false");
        }
        else
        {
            missing_variables.append("localization.USE_ARUCO");
        }
    }

    QJsonObject obj_net = obj["network"].toObject();
    {
        if(obj_net.contains("USE_MULTI"))
        {
            USE_MULTI = obj_net["USE_MULTI"].toBool();
            printf("[CONFIG] USE_MULTI, %s\n", USE_MULTI ? "true" : "false");
        }
        else
        {
            missing_variables.append("network.USE_MULTI");
        }

        if(obj_net.contains("USE_COOP"))
        {
            USE_COMM_COOP = obj_net["USE_COOP"].toBool();
            printf("[CONFIG] USE_COOP, %s\n", USE_COMM_COOP ? "true" : "false");
        }
        else
        {
            missing_variables.append("network.USE_COOP");
        }

        if(obj_net.contains("USE_RTSP"))
        {
            USE_COMM_RTSP = obj_net["USE_RTSP"].toBool();
            printf("[CONFIG] USE_RTSP, %s\n", USE_COMM_RTSP ? "true" : "false");
        }
        else
        {
            missing_variables.append("network.USE_RTSP");
        }

        if(obj_net.contains("USE_RRS"))
        {
            USE_COMM_RRS = obj_net["USE_RRS"].toBool();
            printf("[CONFIG] USE_RRS, %s\n", USE_COMM_RRS ? "true" : "false");
        }
        else
        {
            missing_variables.append("network.USE_RRS");
        }

        if(obj_net.contains("USE_FMS"))
        {
            USE_COMM_FMS = obj_net["USE_FMS"].toBool();
            printf("[CONFIG] USE_FMS, %s\n", USE_COMM_FMS ? "true" : "false");
        }
        else
        {
            missing_variables.append("network.USE_FMS");
        }
    }

    QJsonObject obj_debug = obj["debug"].toObject();
    {
        if(obj_debug.contains("USE_SIM"))
        {
            USE_SIM = obj_debug["USE_SIM"].toBool();
            printf("[CONFIG] USE_SIM, %s\n", USE_SIM ? "true" : "false");
        }
        else
        {
            missing_variables.append("debug.USE_SIM");
        }

        if(obj_debug.contains("USE_BEEP"))
        {
            USE_BEEP = obj_debug["USE_BEEP"].toBool();
            printf("[CONFIG] USE_BEEP, %s\n", USE_BEEP ? "true" : "false");
        }
        else
        {
            missing_variables.append("debug.USE_BEEP");
        }
    }

    QJsonObject obj_path = obj["map"].toObject();
    {
        if(obj_path.contains("MAP_PATH") && !obj_path["MAP_PATH"].toString().isEmpty())
        {
            MAP_PATH = obj_path["MAP_PATH"].toString();
            printf("[CONFIG] MAP_PATH, %s\n", obj_path["MAP_PATH"].toString().toLocal8Bit().data());
        }
        else
        {
            missing_variables.append("map.MAP_PATH");
        }
    }

    if(USE_LIDAR_2D)
    {
        QJsonArray lidar_arr = obj["lidar_2d_config"].toArray();
        for(int i = 0; i < LIDAR_2D_NUM; i++)
        {
            QJsonObject obj_lidar_2d = lidar_arr[i].toObject();
            LIDAR_2D_IP[i] = obj_lidar_2d["IP"].toString();
            LIDAR_2D_TF[i] = obj_lidar_2d["TF"].toString();
            printf("[CONFIG] LIDAR_2D[%d] IP: %s, TF: %s\n",i, qUtf8Printable(LIDAR_2D_IP[i]), qUtf8Printable(LIDAR_2D_TF[i]));
        }
    }

    if(USE_LIDAR_3D)
    {
        QJsonArray lidar_arr = obj["lidar_3d_config"].toArray();
        for(int i = 0; i < LIDAR_3D_NUM; i++)
        {
            QJsonObject obj_lidar_3d = lidar_arr[i].toObject();
            LIDAR_3D_IP[i] = obj_lidar_3d["IP"].toString();
            LIDAR_3D_TF[i] = obj_lidar_3d["TF"].toString();
            printf("[CONFIG] LIDAR_3D[%d] IP: %s, TF: %s\n",i, qUtf8Printable(LIDAR_3D_IP[i]), qUtf8Printable(LIDAR_3D_TF[i]));
        }
    }

    if(USE_CAM)
    {
        QJsonArray cam_arr = obj["cam_config"].toArray();
        for(int i = 0; i < cam_arr.size(); i++)
        {
            QJsonObject obj_cam = cam_arr[i].toObject();
            CAM_SERIAL_NUMBER[i] = obj_cam["SERIAL_NUMBER"].toString();
            CAM_TF[i] = obj_cam["TF"].toString();
            printf("[CONFIG] CAM[%d] Serial: %s, TF: %s\n", i, qUtf8Printable(CAM_SERIAL_NUMBER[i]), qUtf8Printable(CAM_TF[i]));
        }
    }

    if(LIDAR_2D_TYPE == "SICK" && obj.contains("SICK"))
    {
        QJsonObject obj_sick = obj["SICK"].toObject();

        LIDAR_2D_MIN_RANGE = obj_sick["LIDAR_2D_MIN_RANGE"].toString().toDouble();
        printf("[CONFIG] LIDAR_2D_MIN_RANGE(SICK), %s\n", obj_sick["LIDAR_2D_MIN_RANGE"].toString().toLocal8Bit().data());

        LIDAR_2D_MAX_RANGE = obj_sick["LIDAR_2D_MAX_RANGE"].toString().toDouble();
        printf("[CONFIG] LIDAR_2D_MAX_RANGE(SICK), %s\n", obj_sick["LIDAR_2D_MAX_RANGE"].toString().toLocal8Bit().data());
    }
    else if(LIDAR_2D_TYPE == "LAKI" && obj.contains("LAKI"))
    {
        QJsonObject obj_laki = obj["LAKI"].toObject();

        LIDAR_2D_MIN_RANGE = obj_laki["LIDAR_2D_MIN_RANGE"].toString().toDouble();
        printf("[CONFIG] LIDAR_2D_MIN_RANGE(LAKI), %s\n", obj_laki["LIDAR_2D_MIN_RANGE"].toString().toLocal8Bit().data());

        LIDAR_2D_MAX_RANGE = obj_laki["LIDAR_2D_MAX_RANGE"].toString().toDouble();
        printf("[CONFIG] LIDAR_2D_MAX_RANGE(LAKI), %s\n", obj_laki["LIDAR_2D_MAX_RANGE"].toString().toLocal8Bit().data());
    }
    else if(LIDAR_2D_TYPE == "RPLIDAR" && obj.contains("RPLIDAR"))
    {
        QJsonObject obj_rplidar = obj["RPLIDAR"].toObject();

        LIDAR_2D_MIN_RANGE = obj_rplidar["LIDAR_2D_MIN_RANGE"].toString().toDouble();
        printf("[CONFIG] LIDAR_2D_MIN_RANGE(RPLIDAR), %s\n", obj_rplidar["LIDAR_2D_MIN_RANGE"].toString().toLocal8Bit().data());

        LIDAR_2D_MAX_RANGE = obj_rplidar["LIDAR_2D_MAX_RANGE"].toString().toDouble();
        printf("[CONFIG] LIDAR_2D_MAX_RANGE(RPLIDAR), %s\n", obj_rplidar["LIDAR_2D_MAX_RANGE"].toString().toLocal8Bit().data());
    }

    if(LIDAR_3D_TYPE == "LIVOX" && obj.contains("LIVOX"))
    {
        QJsonObject obj_lvx = obj["LIVOX"].toObject();

        LIDAR_3D_MIN_RANGE = obj_lvx["LIDAR_3D_MIN_RANGE"].toString().toDouble();
        printf("[CONFIG] LIDAR_3D_MIN_RANGE(LIVOX), %s\n", obj_lvx["LIDAR_3D_MIN_RANGE"].toString().toLocal8Bit().data());

        LIDAR_3D_MAX_RANGE = obj_lvx["LIDAR_3D_MAX_RANGE"].toString().toDouble();
        printf("[CONFIG] LIDAR_3D_MAX_RANGE(LIVOX), %s\n", obj_lvx["LIDAR_3D_MAX_RANGE"].toString().toLocal8Bit().data());
    }

    if(CAM_TYPE == "ORBBEC" && obj.contains("ORBBEC"))
    {
        QJsonObject obj_cam = obj["ORBBEC"].toObject();

        CAM_HEIGHT_MAX = obj_cam["CAM_HEIGHT_MAX"].toString().toDouble();
        printf("[CONFIG] CAM_HEIGHT_MAX(ORBBEC), %s\n", obj_cam["CAM_HEIGHT_MAX"].toString().toLocal8Bit().data());

        CAM_HEIGHT_MIN = obj_cam["CAM_HEIGHT_MIN"].toString().toDouble();
        printf("[CONFIG] CAM_HEIGHT_MIN(ORBBEC), %s\n", obj_cam["CAM_HEIGHT_MIN"].toString().toLocal8Bit().data());
    }

    QJsonObject obj_motor = obj["motor"].toObject();
    {
        if(obj_motor.contains("MOTOR_ID_L"))
        {
            MOTOR_ID_L = obj_motor["MOTOR_ID_L"].toString().toInt();
            printf("[CONFIG] MOTOR_ID_L, %s\n", obj_motor["MOTOR_ID_L"].toString().toLocal8Bit().data());
        }
        else
        {
            missing_variables.append("motor.MOTOR_ID_L");
        }

        if(obj_motor.contains("MOTOR_ID_R"))
        {
            MOTOR_ID_R = obj_motor["MOTOR_ID_R"].toString().toInt();
            printf("[CONFIG] MOTOR_ID_R, %s\n", obj_motor["MOTOR_ID_R"].toString().toLocal8Bit().data());
        }
        else
        {
            missing_variables.append("motor.MOTOR_ID_R");
        }

        if(obj_motor.contains("MOTOR_DIR"))
        {
            MOTOR_DIR = obj_motor["MOTOR_DIR"].toString().toDouble();
            printf("[CONFIG] MOTOR_DIR, %s\n", obj_motor["MOTOR_DIR"].toString().toLocal8Bit().data());
        }
        else
        {
            missing_variables.append("motor.MOTOR_DIR");
        }

        if(obj_motor.contains("MOTOR_GEAR_RATIO"))
        {
            MOTOR_GEAR_RATIO = obj_motor["MOTOR_GEAR_RATIO"].toString().toDouble();
            printf("[CONFIG] MOTOR_GEAR_RATIO, %s\n", obj_motor["MOTOR_GEAR_RATIO"].toString().toLocal8Bit().data());
        }
        else
        {
            missing_variables.append("motor.MOTOR_GEAR_RATIO");
        }

        if(obj_motor.contains("MOTOR_LIMIT_V"))
        {
            MOTOR_LIMIT_V = obj_motor["MOTOR_LIMIT_V"].toString().toDouble();
            printf("[CONFIG] MOTOR_LIMIT_V, %s\n", obj_motor["MOTOR_LIMIT_V"].toString().toLocal8Bit().data());
        }
        else
        {
            missing_variables.append("motor.MOTOR_LIMIT_V");
        }

        if(obj_motor.contains("MOTOR_LIMIT_V_ACC"))
        {
            MOTOR_LIMIT_V_ACC = obj_motor["MOTOR_LIMIT_V_ACC"].toString().toDouble();
            printf("[CONFIG] MOTOR_LIMIT_V_ACC, %s\n", obj_motor["MOTOR_LIMIT_V_ACC"].toString().toLocal8Bit().data());
        }
        else
        {
            missing_variables.append("motor.MOTOR_LIMIT_V_ACC");
        }

        if(obj_motor.contains("MOTOR_LIMIT_W"))
        {
            MOTOR_LIMIT_W = obj_motor["MOTOR_LIMIT_W"].toString().toDouble();
            printf("[CONFIG] MOTOR_LIMIT_W, %s\n", obj_motor["MOTOR_LIMIT_W"].toString().toLocal8Bit().data());
        }
        else
        {
            missing_variables.append("motor.MOTOR_LIMIT_W");
        }

        if(obj_motor.contains("MOTOR_LIMIT_W_ACC"))
        {
            MOTOR_LIMIT_W_ACC = obj_motor["MOTOR_LIMIT_W_ACC"].toString().toDouble();
            printf("[CONFIG] MOTOR_LIMIT_W_ACC, %s\n", obj_motor["MOTOR_LIMIT_W_ACC"].toString().toLocal8Bit().data());
        }
        else
        {
            missing_variables.append("motor.MOTOR_LIMIT_W_ACC");
        }

        if(obj_motor.contains("MOTOR_GAIN_KP"))
        {
            MOTOR_GAIN_KP = obj_motor["MOTOR_GAIN_KP"].toString().toDouble();
            printf("[CONFIG] MOTOR_GAIN_KP, %s\n", obj_motor["MOTOR_GAIN_KP"].toString().toLocal8Bit().data());
        }
        else
        {
            missing_variables.append("motor.MOTOR_GAIN_KP");
        }

        if(obj_motor.contains("MOTOR_GAIN_KI"))
        {
            MOTOR_GAIN_KI = obj_motor["MOTOR_GAIN_KI"].toString().toDouble();
            printf("[CONFIG] MOTOR_GAIN_KI, %s\n", obj_motor["MOTOR_GAIN_KI"].toString().toLocal8Bit().data());
        }
        else
        {
            missing_variables.append("motor.MOTOR_GAIN_KI");
        }

        if(obj_motor.contains("MOTOR_GAIN_KD"))
        {
            MOTOR_GAIN_KD = obj_motor["MOTOR_GAIN_KD"].toString().toDouble();
            printf("[CONFIG] MOTOR_GAIN_KD, %s\n", obj_motor["MOTOR_GAIN_KD"].toString().toLocal8Bit().data());
        }
        else
        {
            missing_variables.append("motor.MOTOR_GAIN_KD");
        }
    }

    if(LOC_MODE == "2D")
    {
        QJsonObject obj_loc_2d = obj["loc_2d"].toObject();
        {
            if(obj_loc_2d.contains("LOC_SURFEL_NUM"))
            {
                LOC_2D_SURFEL_NUM = obj_loc_2d["LOC_SURFEL_NUM"].toString().toInt();
                printf("[CONFIG] LOC_SURFEL_NUM, %s\n", obj_loc_2d["LOC_SURFEL_NUM"].toString().toLocal8Bit().data());
            }
            else
            {
                missing_variables.append("loc_2d.LOC_SURFEL_NUM");
            }

            if(obj_loc_2d.contains("LOC_SURFEL_RANGE"))
            {
                LOC_2D_SURFEL_RANGE = obj_loc_2d["LOC_SURFEL_RANGE"].toString().toDouble();
                printf("[CONFIG] LOC_SURFEL_RANGE, %s\n", obj_loc_2d["LOC_SURFEL_RANGE"].toString().toLocal8Bit().data());
            }
            else
            {
                missing_variables.append("loc_2d.LOC_SURFEL_RANGE");
            }

            if(obj_loc_2d.contains("LOC_ICP_COST_THRESHOLD_0"))
            {
                LOC_2D_ICP_COST_THRESHOLD_0 = obj_loc_2d["LOC_ICP_COST_THRESHOLD_0"].toString().toDouble();
                printf("[CONFIG] LOC_ICP_COST_THRESHOLD_0, %s\n", obj_loc_2d["LOC_ICP_COST_THRESHOLD_0"].toString().toLocal8Bit().data());
            }
            else
            {
                missing_variables.append("loc_2d.LOC_ICP_COST_THRESHOLD_0");
            }

            if(obj_loc_2d.contains("LOC_ICP_COST_THRESHOLD"))
            {
                LOC_2D_ICP_COST_THRESHOLD = obj_loc_2d["LOC_ICP_COST_THRESHOLD"].toString().toDouble();
                printf("[CONFIG] LOC_ICP_COST_THRESHOLD, %s\n", obj_loc_2d["LOC_ICP_COST_THRESHOLD"].toString().toLocal8Bit().data());
            }
            else
            {
                missing_variables.append("loc_2d.LOC_ICP_COST_THRESHOLD");
            }

            if(obj_loc_2d.contains("LOC_ICP_ERROR_THRESHOLD"))
            {
                LOC_2D_ICP_ERROR_THRESHOLD = obj_loc_2d["LOC_ICP_ERROR_THRESHOLD"].toString().toDouble();
                printf("[CONFIG] LOC_ICP_ERROR_THRESHOLD, %s\n", obj_loc_2d["LOC_ICP_ERROR_THRESHOLD"].toString().toLocal8Bit().data());
            }
            else
            {
                missing_variables.append("loc_2d.LOC_ICP_ERROR_THRESHOLD");
            }

            if(obj_loc_2d.contains("LOC_ICP_MAX_FEATURE_NUM"))
            {
                LOC_2D_ICP_MAX_FEATURE_NUM = obj_loc_2d["LOC_ICP_MAX_FEATURE_NUM"].toString().toInt();
                printf("[CONFIG] LOC_ICP_MAX_FEATURE_NUM, %s\n", obj_loc_2d["LOC_ICP_MAX_FEATURE_NUM"].toString().toLocal8Bit().data());
            }
            else
            {
                missing_variables.append("loc_2d.LOC_ICP_MAX_FEATURE_NUM");
            }

            if(obj_loc_2d.contains("LOC_CHECK_DIST"))
            {
                LOC_2D_CHECK_DIST = obj_loc_2d["LOC_CHECK_DIST"].toString().toDouble();
                printf("[CONFIG] LOC_CHECK_DIST, %s\n", obj_loc_2d["LOC_CHECK_DIST"].toString().toLocal8Bit().data());
            }
            else
            {
                missing_variables.append("loc_2d.LOC_CHECK_DIST");
            }

            if(obj_loc_2d.contains("LOC_CHECK_IE"))
            {
                LOC_2D_CHECK_IE = obj_loc_2d["LOC_CHECK_IE"].toString().toDouble();
                printf("[CONFIG] LOC_CHECK_IE, %s\n", obj_loc_2d["LOC_CHECK_IE"].toString().toLocal8Bit().data());
            }
            else
            {
                missing_variables.append("loc_2d.LOC_CHECK_IE");
            }

            if(obj_loc_2d.contains("LOC_CHECK_IR"))
            {
                LOC_2D_CHECK_IR = obj_loc_2d["LOC_CHECK_IR"].toString().toDouble();
                printf("[CONFIG] LOC_CHECK_IR, %s\n", obj_loc_2d["LOC_CHECK_IR"].toString().toLocal8Bit().data());
            }
            else
            {
                missing_variables.append("loc_2d.LOC_CHECK_IR");
            }

            if(obj_loc_2d.contains("LOC_ICP_ODO_FUSION_RATIO"))
            {
                LOC_2D_ICP_ODO_FUSION_RATIO = obj_loc_2d["LOC_ICP_ODO_FUSION_RATIO"].toString().toDouble();
                printf("[CONFIG] LOC_ICP_ODO_FUSION_RATIO, %s\n", obj_loc_2d["LOC_ICP_ODO_FUSION_RATIO"].toString().toLocal8Bit().data());
            }
            else
            {
                missing_variables.append("loc_2d.LOC_ICP_ODO_FUSION_RATIO");
            }

            if(obj_loc_2d.contains("LOC_ARUCO_ODO_FUSION_RATIO"))
            {
                LOC_2D_ARUCO_ODO_FUSION_RATIO = obj_loc_2d["LOC_ARUCO_ODO_FUSION_RATIO"].toString().toDouble();
                printf("[CONFIG] LOC_ARUCO_ODO_FUSION_RATIO, %s\n", obj_loc_2d["LOC_ARUCO_ODO_FUSION_RATIO"].toString().toLocal8Bit().data());
            }
            else
            {
                missing_variables.append("loc_2d.LOC_ARUCO_ODO_FUSION_RATIO");
            }

            if(obj_loc_2d.contains("LOC_ARUCO_ODO_FUSION_DIST"))
            {
                LOC_2D_ARUCO_ODO_FUSION_DIST = obj_loc_2d["LOC_ARUCO_ODO_FUSION_DIST"].toString().toDouble();
                printf("[CONFIG] LOC_ARUCO_ODO_FUSION_DIST, %s\n", obj_loc_2d["LOC_ARUCO_ODO_FUSION_DIST"].toString().toLocal8Bit().data());
            }
            else
            {
                missing_variables.append("loc_2d.LOC_ARUCO_ODO_FUSION_DIST");
            }
        }
    }
    else if(LOC_MODE == "3D")
    {
        QJsonObject obj_loc_3d = obj["loc_3d"].toObject();
        {
            if(obj_loc_3d.contains("LOC_MAX_FEATURE_NUM"))
            {
                LOC_MAX_FEATURE_NUM = obj_loc_3d["LOC_MAX_FEATURE_NUM"].toString().toInt();
                printf("[CONFIG] LOC_MAX_FEATURE_NUM, %s\n", obj_loc_3d["LOC_MAX_FEATURE_NUM"].toString().toLocal8Bit().data());
            }
            else
            {
                missing_variables.append("loc_3d.LOC_MAX_FEATURE_NUM");
            }

            if(obj_loc_3d.contains("LOC_SURFEL_NN_NUM"))
            {
                LOC_SURFEL_NN_NUM = obj_loc_3d["LOC_SURFEL_NN_NUM"].toString().toInt();
                printf("[CONFIG] LOC_SURFEL_NN_NUM, %s\n", obj_loc_3d["LOC_SURFEL_NN_NUM"].toString().toLocal8Bit().data());
            }
            else
            {
                missing_variables.append("loc_3d.LOC_SURFEL_NN_NUM");
            }

            if(obj_loc_3d.contains("LOC_SURFEL_RANGE"))
            {
                LOC_2D_SURFEL_RANGE = obj_loc_3d["LOC_SURFEL_RANGE"].toString().toDouble();
                printf("[CONFIG] LOC_SURFEL_RANGE, %s\n", obj_loc_3d["LOC_SURFEL_RANGE"].toString().toLocal8Bit().data());
            }
            else
            {
                missing_variables.append("loc_3d.LOC_SURFEL_RANGE");
            }

            if(obj_loc_3d.contains("LOC_SURFEL_BALANCE"))
            {
                LOC_SURFEL_BALANCE = obj_loc_3d["LOC_SURFEL_BALANCE"].toString().toDouble();
                printf("[CONFIG] LOC_SURFEL_BALANCE, %s\n", obj_loc_3d["LOC_SURFEL_BALANCE"].toString().toLocal8Bit().data());
            }
            else
            {
                missing_variables.append("loc_3d.LOC_SURFEL_BALANCE");
            }

            if(obj_loc_3d.contains("LOC_COST_THRESHOLD"))
            {
                LOC_COST_THRESHOLD = obj_loc_3d["LOC_COST_THRESHOLD"].toString().toDouble();
                printf("[CONFIG] LOC_COST_THRESHOLD, %s\n", obj_loc_3d["LOC_COST_THRESHOLD"].toString().toLocal8Bit().data());
            }
            else
            {
                missing_variables.append("loc_3d.LOC_COST_THRESHOLD");
            }

            if(obj_loc_3d.contains("LOC_INLIER_CHECK_DIST"))
            {
                LOC_INLIER_CHECK_DIST = obj_loc_3d["LOC_INLIER_CHECK_DIST"].toString().toDouble();
                printf("[CONFIG] LOC_INLIER_CHECK_DIST, %s\n", obj_loc_3d["LOC_INLIER_CHECK_DIST"].toString().toLocal8Bit().data());
            }
            else
            {
                missing_variables.append("loc_3d.LOC_INLIER_CHECK_DIST");
            }

            if(obj_loc_3d.contains("LOC_ICP_ODO_FUSION_RATIO"))
            {
                LOC_2D_ICP_ODO_FUSION_RATIO = obj_loc_3d["LOC_ICP_ODO_FUSION_RATIO"].toString().toDouble();
                printf("[CONFIG] LOC_ICP_ODO_FUSION_RATIO, %s\n", obj_loc_3d["LOC_ICP_ODO_FUSION_RATIO"].toString().toLocal8Bit().data());
            }
            else
            {
                missing_variables.append("loc_3d.LOC_ICP_ODO_FUSION_RATIO");
            }
        }
    }

    QJsonObject obj_mapping = obj["mapping"].toObject();
    {
        if(obj_mapping.contains("SLAM_WINDOW_SIZE"))
        {
            MAPPING_WINDOW_SIZE = obj_mapping["SLAM_WINDOW_SIZE"].toString().toInt();
            printf("[CONFIG] SLAM_WINDOW_SIZE, %s\n", obj_mapping["SLAM_WINDOW_SIZE"].toString().toLocal8Bit().data());
        }
        else
        {
            missing_variables.append("mapping.SLAM_WINDOW_SIZE");
        }

        if(obj_mapping.contains("SLAM_VOXEL_SIZE"))
        {
            MAPPING_VOXEL_SIZE = obj_mapping["SLAM_VOXEL_SIZE"].toString().toDouble();
            printf("[CONFIG] SLAM_VOXEL_SIZE, %s\n", obj_mapping["SLAM_VOXEL_SIZE"].toString().toLocal8Bit().data());
        }
        else
        {
            missing_variables.append("mapping.SLAM_VOXEL_SIZE");
        }

        if(obj_mapping.contains("SLAM_ICP_COST_THRESHOLD"))
        {
            MAPPING_ICP_COST_THRESHOLD = obj_mapping["SLAM_ICP_COST_THRESHOLD"].toString().toDouble();
            printf("[CONFIG] SLAM_ICP_COST_THRESHOLD, %s\n", obj_mapping["SLAM_ICP_COST_THRESHOLD"].toString().toLocal8Bit().data());
        }
        else
        {
            missing_variables.append("mapping.SLAM_ICP_COST_THRESHOLD");
        }

        if(obj_mapping.contains("SLAM_ICP_ERROR_THRESHOLD"))
        {
            MAPPING_ICP_ERROR_THRESHOLD = obj_mapping["SLAM_ICP_ERROR_THRESHOLD"].toString().toDouble();
            printf("[CONFIG] SLAM_ICP_ERROR_THRESHOLD, %s\n", obj_mapping["SLAM_ICP_ERROR_THRESHOLD"].toString().toLocal8Bit().data());
        }
        else
        {
            missing_variables.append("mapping.SLAM_ICP_ERROR_THRESHOLD");
        }

        if(obj_mapping.contains("SLAM_ICP_MAX_FEATURE_NUM"))
        {
            MAPPING_ICP_MAX_FEATURE_NUM = obj_mapping["SLAM_ICP_MAX_FEATURE_NUM"].toString().toInt();
            printf("[CONFIG] SLAM_ICP_MAX_FEATURE_NUM, %s\n", obj_mapping["SLAM_ICP_MAX_FEATURE_NUM"].toString().toLocal8Bit().data());
        }
        else
        {
            missing_variables.append("mapping.SLAM_ICP_MAX_FEATURE_NUM");
        }

        if(obj_mapping.contains("SLAM_ICP_DO_ERASE_GAP"))
        {
            MAPPING_ICP_DO_ERASE_GAP = obj_mapping["SLAM_ICP_DO_ERASE_GAP"].toString().toInt();
            printf("[CONFIG] SLAM_ICP_DO_ERASE_GAP, %s\n", obj_mapping["SLAM_ICP_DO_ERASE_GAP"].toString().toLocal8Bit().data());
        }
        else
        {
            missing_variables.append("mapping.SLAM_ICP_DO_ERASE_GAP");
        }

        if(obj_mapping.contains("SLAM_ICP_DO_ACCUM_NUM"))
        {
            MAPPING_ICP_DO_ACCUM_NUM = obj_mapping["SLAM_ICP_DO_ACCUM_NUM"].toString().toInt();
            printf("[CONFIG] SLAM_ICP_DO_ACCUM_NUM, %s\n", obj_mapping["SLAM_ICP_DO_ACCUM_NUM"].toString().toLocal8Bit().data());
        }
        else
        {
            missing_variables.append("mapping.SLAM_ICP_DO_ACCUM_NUM");
        }

        if(obj_mapping.contains("SLAM_ICP_VIEW_THRESHOLD"))
        {
            MAPPING_ICP_VIEW_THRESHOLD = obj_mapping["SLAM_ICP_VIEW_THRESHOLD"].toString().toDouble();
            printf("[CONFIG] SLAM_ICP_VIEW_THRESHOLD, %s\n", obj_mapping["SLAM_ICP_VIEW_THRESHOLD"].toString().toLocal8Bit().data());
        }
        else
        {
            missing_variables.append("mapping.SLAM_ICP_VIEW_THRESHOLD");
        }

        if(obj_mapping.contains("SLAM_KFRM_UPDATE_NUM"))
        {
            MAPPING_KFRM_UPDATE_NUM = obj_mapping["SLAM_KFRM_UPDATE_NUM"].toString().toInt();
            printf("[CONFIG] SLAM_KFRM_UPDATE_NUM, %s\n", obj_mapping["SLAM_KFRM_UPDATE_NUM"].toString().toLocal8Bit().data());
        }
        else
        {
            missing_variables.append("mapping.SLAM_KFRM_UPDATE_NUM");
        }

        if(obj_mapping.contains("SLAM_KFRM_LC_TRY_DIST"))
        {
            MAPPING_KFRM_LC_TRY_DIST = obj_mapping["SLAM_KFRM_LC_TRY_DIST"].toString().toDouble();
            printf("[CONFIG] SLAM_KFRM_LC_TRY_DIST, %s\n", obj_mapping["SLAM_KFRM_LC_TRY_DIST"].toString().toLocal8Bit().data());
        }
        else
        {
            missing_variables.append("mapping.SLAM_KFRM_LC_TRY_DIST");
        }

        if(obj_mapping.contains("SLAM_KFRM_LC_TRY_OVERLAP"))
        {
            MAPPING_KFRM_LC_TRY_OVERLAP = obj_mapping["SLAM_KFRM_LC_TRY_OVERLAP"].toString().toDouble();
            printf("[CONFIG] SLAM_KFRM_LC_TRY_OVERLAP, %s\n", obj_mapping["SLAM_KFRM_LC_TRY_OVERLAP"].toString().toLocal8Bit().data());
        }
        else
        {
            missing_variables.append("mapping.SLAM_KFRM_LC_TRY_OVERLAP");
        }
    }

    QJsonObject obj_obs = obj["obs"].toObject();
    {
        if(obj_obs.contains("OBS_AVOID"))
        {
            OBS_AVOID = obj_obs["OBS_AVOID"].toString().toInt();
            printf("[CONFIG] OBS_AVOID, %s\n", obj_obs["OBS_AVOID"].toString().toLocal8Bit().data());
        }
        else
        {
            missing_variables.append("obs.OBS_AVOID");
        }

        if(obj_obs.contains("OBS_DEADZONE"))
        {
            OBS_DEADZONE = obj_obs["OBS_DEADZONE"].toString().toDouble();
            printf("[CONFIG] OBS_DEADZONE, %s\n", obj_obs["OBS_DEADZONE"].toString().toLocal8Bit().data());
        }
        else
        {
            missing_variables.append("obs.OBS_DEADZONE");
        }

        if(obj_obs.contains("OBS_LOCAL_GOAL_D"))
        {
            OBS_LOCAL_GOAL_D = obj_obs["OBS_LOCAL_GOAL_D"].toString().toDouble();
            printf("[CONFIG] OBS_LOCAL_GOAL_D, %s\n", obj_obs["OBS_LOCAL_GOAL_D"].toString().toLocal8Bit().data());
        }
        else
        {
            missing_variables.append("obs.OBS_LOCAL_GOAL_D");
        }

        if(obj_obs.contains("OBS_SAFE_MARGIN_X"))
        {
            OBS_SAFE_MARGIN_X = obj_obs["OBS_SAFE_MARGIN_X"].toString().toDouble();
            printf("[CONFIG] OBS_SAFE_MARGIN_X, %s\n", obj_obs["OBS_SAFE_MARGIN_X"].toString().toLocal8Bit().data());
        }
        else
        {
            missing_variables.append("obs.OBS_SAFE_MARGIN_X");
        }

        if(obj_obs.contains("OBS_SAFE_MARGIN_Y"))
        {
            OBS_SAFE_MARGIN_Y = obj_obs["OBS_SAFE_MARGIN_Y"].toString().toDouble();
            printf("[CONFIG] OBS_SAFE_MARGIN_Y, %s\n", obj_obs["OBS_SAFE_MARGIN_Y"].toString().toLocal8Bit().data());
        }
        else
        {
            missing_variables.append("obs.OBS_SAFE_MARGIN_Y");
        }

        if(obj_obs.contains("OBS_PATH_MARGIN_X"))
        {
            OBS_PATH_MARGIN_X = obj_obs["OBS_PATH_MARGIN_X"].toString().toDouble();
            printf("[CONFIG] OBS_PATH_MARGIN_X, %s\n", obj_obs["OBS_PATH_MARGIN_X"].toString().toLocal8Bit().data());
        }
        else
        {
            missing_variables.append("obs.OBS_PATH_MARGIN_X");
        }

        if(obj_obs.contains("OBS_PATH_MARGIN_Y"))
        {
            OBS_PATH_MARGIN_Y = obj_obs["OBS_PATH_MARGIN_Y"].toString().toDouble();
            printf("[CONFIG] OBS_PATH_MARGIN_Y, %s\n", obj_obs["OBS_PATH_MARGIN_Y"].toString().toLocal8Bit().data());
        }
        else
        {
            missing_variables.append("obs.OBS_PATH_MARGIN_Y");
        }

        if(obj_obs.contains("OBS_MAP_GRID_SIZE"))
        {
            OBS_MAP_GRID_SIZE = obj_obs["OBS_MAP_GRID_SIZE"].toString().toDouble();
            printf("[CONFIG] OBS_MAP_GRID_SIZE, %s\n", obj_obs["OBS_MAP_GRID_SIZE"].toString().toLocal8Bit().data());
        }
        else
        {
            missing_variables.append("obs.OBS_MAP_GRID_SIZE");
        }

        if(obj_obs.contains("OBS_MAP_RANGE"))
        {
            OBS_MAP_RANGE = obj_obs["OBS_MAP_RANGE"].toString().toDouble();
            printf("[CONFIG] OBS_MAP_RANGE, %s\n", obj_obs["OBS_MAP_RANGE"].toString().toLocal8Bit().data());
        }
        else
        {
            missing_variables.append("obs.OBS_MAP_RANGE");
        }

        if(obj_obs.contains("OBS_MAP_MIN_V"))
        {
            OBS_MAP_MIN_V = obj_obs["OBS_MAP_MIN_V"].toString().toDouble();
            printf("[CONFIG] OBS_MAP_MIN_V, %s\n", obj_obs["OBS_MAP_MIN_V"].toString().toLocal8Bit().data());
        }
        else
        {
            missing_variables.append("obs.OBS_MAP_MIN_V");
        }

        if(obj_obs.contains("OBS_MAP_MIN_Z"))
        {
            OBS_MAP_MIN_Z = obj_obs["OBS_MAP_MIN_Z"].toString().toDouble();
            printf("[CONFIG] OBS_MAP_MIN_Z, %s\n", obj_obs["OBS_MAP_MIN_Z"].toString().toLocal8Bit().data());
        }
        else
        {
            missing_variables.append("obs.OBS_MAP_MIN_Z");
        }

        if(obj_obs.contains("OBS_MAP_MAX_Z"))
        {
            OBS_MAP_MAX_Z = obj_obs["OBS_MAP_MAX_Z"].toString().toDouble();
            printf("[CONFIG] OBS_MAP_MAX_Z, %s\n", obj_obs["OBS_MAP_MAX_Z"].toString().toLocal8Bit().data());
        }
        else
        {
            missing_variables.append("obs.OBS_MAP_MAX_Z");
        }

        if(obj_obs.contains("OBS_PREDICT_TIME"))
        {
            OBS_PREDICT_TIME = obj_obs["OBS_PREDICT_TIME"].toString().toDouble();
            printf("[CONFIG] OBS_PREDICT_TIME, %s\n", obj_obs["OBS_PREDICT_TIME"].toString().toLocal8Bit().data());
        }
        else
        {
            missing_variables.append("obs.OBS_PREDICT_TIME");
        }
    }

    QJsonObject obj_control = obj["control"].toObject();
    {
        if(obj_control.contains("DRIVE_GOAL_APPROACH_GAIN"))
        {
            DRIVE_GOAL_APPROACH_GAIN = obj_control["DRIVE_GOAL_APPROACH_GAIN"].toString().toDouble();
            printf("[CONFIG] DRIVE_GOAL_APPROACH_GAIN, %s\n", obj_control["DRIVE_GOAL_APPROACH_GAIN"].toString().toLocal8Bit().data());
        }
        else
        {
            missing_variables.append("control.DRIVE_GOAL_APPROACH_GAIN");
        }

        if(obj_control.contains("DRIVE_GOAL_D"))
        {
            DRIVE_GOAL_D = obj_control["DRIVE_GOAL_D"].toString().toDouble();
            printf("[CONFIG] DRIVE_GOAL_D, %s\n", obj_control["DRIVE_GOAL_D"].toString().toLocal8Bit().data());
        }
        else
        {
            missing_variables.append("control.DRIVE_GOAL_D");
        }

        if(obj_control.contains("DRIVE_GOAL_TH"))
        {
            DRIVE_GOAL_TH = obj_control["DRIVE_GOAL_TH"].toString().toDouble();
            printf("[CONFIG] DRIVE_GOAL_TH, %s\n", obj_control["DRIVE_GOAL_TH"].toString().toLocal8Bit().data());
        }
        else
        {
            missing_variables.append("control.DRIVE_GOAL_TH");
        }

        if(obj_control.contains("DRIVE_EXTENDED_CONTROL_TIME"))
        {
            DRIVE_EXTENDED_CONTROL_TIME = obj_control["DRIVE_EXTENDED_CONTROL_TIME"].toString().toDouble();
            printf("[CONFIG] DRIVE_EXTENDED_CONTROL_TIME, %s\n", obj_control["DRIVE_EXTENDED_CONTROL_TIME"].toString().toLocal8Bit().data());
        }
        else
        {
            missing_variables.append("control.DRIVE_EXTENDED_CONTROL_TIME");
        }

        if(obj_control.contains("DRIVE_V_DEADZONE"))
        {
            DRIVE_V_DEADZONE = obj_control["DRIVE_V_DEADZONE"].toString().toDouble();
            printf("[CONFIG] DRIVE_V_DEADZONE, %s\n", obj_control["DRIVE_V_DEADZONE"].toString().toLocal8Bit().data());
        }
        else
        {
            missing_variables.append("control.DRIVE_V_DEADZONE");
        }

        if(obj_control.contains("DRIVE_W_DEADZONE"))
        {
            DRIVE_W_DEADZONE = obj_control["DRIVE_W_DEADZONE"].toString().toDouble();
            printf("[CONFIG] DRIVE_W_DEADZONE, %s\n", obj_control["DRIVE_W_DEADZONE"].toString().toLocal8Bit().data());
        }
        else
        {
            missing_variables.append("control.DRIVE_W_DEADZONE");
        }
    }

    QJsonObject obj_dock = obj["docking"].toObject();
    {
        if(obj_dock.contains("DOCKING_GOAL_D"))
        {
            DOCKING_GOAL_D = obj_dock["DOCKING_GOAL_D"].toString().toDouble();
            printf("[CONFIG] DOCKING_GOAL_D, %s\n", obj_dock["DOCKING_GOAL_D"].toString().toLocal8Bit().data());
        }
        else
        {
            missing_variables.append("docking.DOCKING_GOAL_D");
        }

        if(obj_dock.contains("DOCKING_GOAL_TH"))
        {
            DOCKING_GOAL_TH = obj_dock["DOCKING_GOAL_TH"].toString().toDouble();
            printf("[CONFIG] DOCKING_GOAL_TH, %s\n", obj_dock["DOCKING_GOAL_TH"].toString().toLocal8Bit().data());
        }
        else
        {
            missing_variables.append("docking.DOCKING_GOAL_TH");
        }

        if(obj_dock.contains("DOCKING_EXTENDED_CONTROL_TIME"))
        {
            DOCKING_EXTENDED_CONTROL_TIME = obj_dock["DOCKING_EXTENDED_CONTROL_TIME"].toString().toDouble();
            printf("[CONFIG] DOCKING_EXTENDED_CONTROL_TIME, %s\n", obj_dock["DOCKING_EXTENDED_CONTROL_TIME"].toString().toLocal8Bit().data());
        }
        else
        {
            missing_variables.append("docking.DOCKING_EXTENDED_CONTROL_TIME");
        }

        if(obj_dock.contains("DOCKING_POINTDOCK_MARGIN"))
        {
            DOCKING_POINTDOCK_MARGIN = obj_dock["DOCKING_POINTDOCK_MARGIN"].toString().toDouble();
            printf("[CONFIG] DOCKING_POINTDOCK_MARGIN, %s\n", obj_dock["DOCKING_POINTDOCK_MARGIN"].toString().toLocal8Bit().data());
        }
        else
        {
            missing_variables.append("docking.DOCKING_POINTDOCK_MARGIN");
        }

        if(obj_dock.contains("DOCKING_TYPE"))
        {
            DOCKING_TYPE = obj_dock["DOCKING_TYPE"].toString().toInt();
            printf("[CONFIG] DOCKING_TYPE, %s\n", obj_dock["DOCKING_TYPE"].toString().toLocal8Bit().data());
        }
        else
        {
            missing_variables.append("docking.DOCKING_TYPE");
        }
    }

    QJsonObject obj_map = obj["map"].toObject();
    {
        if(obj_map.contains("MAP_PATH") && !obj_map["MAP_PATH"].toString().isEmpty())
        {
            MAP_PATH = obj_map["MAP_PATH"].toString();
            printf("[CONFIG] MAP_PATH, %s\n", obj_map["MAP_PATH"].toString().toLocal8Bit().data());
        }
        else
        {
            missing_variables.append("map.MAP_PATH");
        }
    }

    // complete
    is_load = true;
    config_file.close();
    printf("[CONFIG] %s, load successed\n", qUtf8Printable(config_path));
    
    // 누락된 변수들이 있으면 경고 표시
    if(has_missing_variables())
    {
        show_missing_variables_dialog();
    }
}

void CONFIG::set_map_path(const QString& path)
{
    if(config_path.isEmpty())
    {
        return;
    }

    MAP_PATH = path;

    std::lock_guard<std::mutex> lock(mtx);
    QFile config_file(config_path);
    if(!config_file.open(QIODevice::ReadWrite))
    {
        printf("[config] failed to open config file for reading and writing.\n");
        return;
    }

    QString data;
    {
        QTextStream in(&config_file);
        data = in.readAll();
        config_file.close();
    }

    QString pattern = R"("MAP_PATH"\s*:\s*".*?")";
    QRegularExpression re(pattern);
    QRegularExpressionMatch match = re.match(data);

    if(match.hasMatch())
    {
        data.replace(re, R"("MAP_PATH": ")" + path + R"(")");
    }
    else
    {
        QRegularExpression mapRe(R"("map"\s*:\s*\{)");
        QRegularExpressionMatch map_match = mapRe.match(data);
        if (map_match.hasMatch())
        {
            int insertPos = mapMatch.capturedEnd();
            data.insert(insertPos, QString(R"(
            "MAP_PATH": ")") + path + R"(",)");
        }
    }

    if(!config_file.open(QIODevice::WriteOnly | QIODevice::Text | QIODevice::Truncate))
    {
        printf("[config] failed to open config file for writing.\n");
        return;
    }

    QTextStream out(&config_file);
    out << data;
    config_file.close();
}

QString CONFIG::get_robot_serial_number()
{
    std::lock_guard<std::mutex> robot_mtx;
    QString res = ROBOT_SERIAL_NUMBER;
    return res;
}

QString CONFIG::get_platform_name()
{
    std::lock_guard<std::mutex> robot_mtx;
    QString res = PLATFORM_NAME;
    return res;
}

QString CONFIG::get_platform_type()
{
    std::lock_guard<std::mutex> robot_mtx;
    QString res = PLATFORM_TYPE;
    return res;
}

double CONFIG::get_robot_size_x_min()
{
    std::lock_guard<std::mutex> robot_mtx;
    double res = ROBOT_SIZE_X[0];
    return res;
}

double CONFIG::get_robot_size_x_max()
{
    std::lock_guard<std::mutex> robot_mtx;
    double res = ROBOT_SIZE_X[1];
    return res;
}

double CONFIG::get_robot_size_y_min()
{
    std::lock_guard<std::mutex> robot_mtx;
    double res = ROBOT_SIZE_Y[0];
    return res;
}

double CONFIG::get_robot_size_y_max()
{
    std::lock_guard<std::mutex> robot_mtx;
    double res = ROBOT_SIZE_Y[1];
    return res;
}

double CONFIG::get_robot_size_z_min()
{
    std::lock_guard<std::mutex> robot_mtx;
    double res = ROBOT_SIZE_Z[0];
    return res;
}

double CONFIG::get_robot_size_z_max()
{
    std::lock_guard<std::mutex> robot_mtx;
    double res = ROBOT_SIZE_Z[1];
    return res;
}

double CONFIG::get_robot_wheel_base()
{
    std::lock_guard<std::mutex> robot_mtx;
    double res = ROBOT_WHEEL_BASE;
    return res;
}

double CONFIG::get_robot_wheel_radius()
{
    std::lock_guard<std::mutex> robot_mtx;
    double res = ROBOT_WHEEL_RADIUS;
    return res;
}

double CONFIG::get_robot_radius()
{
    std::lock_guard<std::mutex> robot_mtx;
    double res = ROBOT_RADIUS;
    return res;
}

bool CONFIG::get_use_lidar_2d()
{
    std::lock_guard<std::mutex> sensor_mtx;
    bool res = USE_LIDAR_2D;
    return res;
}

QString CONFIG::get_lidar_2d_type()
{
    std::lock_guard<std::mutex> sensor_mtx;
    QString res = LIDAR_2D_TYPE;
    return res;
}

int CONFIG::get_lidar_2d_num()
{
    std::lock_guard<std::mutex> sensor_mtx;
    int res = LIDAR_2D_NUM;
    return res;
}

bool CONFIG::get_use_lidar_3d()
{
    std::lock_guard<std::mutex> sensor_mtx;
    bool res = USE_LIDAR_3D;
    return res;
}

QString CONFIG::get_lidar_3d_type()
{
    std::lock_guard<std::mutex> sensor_mtx;
    QString res = LIDAR_3D_TYPE;
    return res;
}

int CONFIG::get_lidar_3d_num()
{
    std::lock_guard<std::mutex> sensor_mtx;
    int res = LIDAR_3D_NUM;
    return res;
}

bool CONFIG::get_use_cam()
{
    std::lock_guard<std::mutex> sensor_mtx;
    bool res = USE_CAM;
    return res;
}

QString CONFIG::get_cam_type()
{
    std::lock_guard<std::mutex> sensor_mtx;
    QString res = CAM_TYPE;
    return res;
}

int CONFIG::get_cam_num()
{
    std::lock_guard<std::mutex> sensor_mtx;
    int res = CAM_NUM;
    return res;
}

bool CONFIG::get_use_bqr()
{
    std::lock_guard<std::mutex> sensor_mtx;
    bool res = USE_BQR;
    return res;
}

bool CONFIG::get_use_imu()
{
    std::lock_guard<std::mutex> sensor_mtx;
    bool res = USE_IMU;
    return res;
}

bool CONFIG::get_use_aruco()
{
    std::lock_guard<std::mutex> sensor_mtx;
    bool res = USE_ARUCO;
    return res;
}

QString CONFIG::get_loc_mode()
{
    std::lock_guard<std::mutex> loc_mtx;
    QString res = LOC_MODE;
    return res;
}

bool CONFIG::get_use_multi()
{
    std::lock_guard<std::mutex> network_mtx;
    bool res = USE_MULTI;
    return res;
}

bool CONFIG::get_use_coop()
{
    std::lock_guard<std::mutex> network_mtx;
    bool res = USE_COOP;
    return res;
}

bool CONFIG::get_use_rtsp()
{
    std::lock_guard<std::mutex> network_mtx;
    bool res = USE_RTSP;
    return res;
}

bool CONFIG::get_use_rrs()
{
    std::lock_guard<std::mutex> network_mtx;
    bool res = USE_RRS;
    return res;
}

bool CONFIG::get_use_fms()
{
    std::lock_guard<std::mutex> network_mtx;
    bool res = USE_FMS;
    return res;
}

bool CONFIG::get_use_sim()
{
    std::lock_guard<std::mutex> debug_mtx;
    bool res = USE_SIM;
    return res;
}

bool CONFIG::get_use_beep()
{
    std::lock_guard<std::mutex> debug_mtx;
    bool res = USE_BEEP;
    return res;
}

QString CONFIG::get_server_ip()
{
    std::lock_guard<std::mutex> debug_mtx;
    QString res = SERVER_IP;
    return res;
}

QString CONFIG::get_server_id()
{
    std::lock_guard<std::mutex> debug_mtx;
    QString res = SERVER_ID;
    return res;
}

QString CONFIG::get_server_pw()
{
    std::lock_guard<std::mutex> debug_mtx;
    QString res = SERVER_PW;
    return res;
}

double CONFIG::get_lidar_2d_min_range()
{
    std::lock_guard<std::mutex> sensor_mtx;
    double res = LIDAR_2D_MIN_RANGE;
    return res;
}

double CONFIG::get_lidar_2d_max_range()
{
    std::lock_guard<std::mutex> sensor_mtx;
    double res = LIDAR_2D_MAX_RANGE;
    return res;
}

QString CONFIG::get_lidar_2d_ip(int idx)
{
    std::lock_guard<std::mutex> sensor_mtx;
    QString res = LIDAR_2D_IP[idx];
    return res;
}

QString CONFIG::get_lidar_2d_tf(int idx)
{
    std::lock_guard<std::mutex> sensor_mtx;
    QString res = LIDAR_2D_TF[idx];
    return res;
}

double CONFIG::get_lidar_3d_min_range()
{
    std::lock_guard<std::mutex> sensor_mtx;
    double res = LIDAR_3D_MIN_RANGE;
    return res;
}

double CONFIG::get_lidar_3d_max_range()
{
    std::lock_guard<std::mutex> sensor_mtx;
    double res = LIDAR_3D_MAX_RANGE;
    return res;
}

QString CONFIG::get_lidar_3d_ip(int idx)
{
    std::lock_guard<std::mutex> sensor_mtx;
    QString res = LIDAR_3D_IP[idx];
    return res;
}

QString CONFIG::get_lidar_3d_tf(int idx)
{
    std::lock_guard<std::mutex> sensor_mtx;
    QString res = LIDAR_3D_TF[idx];
    return res;
}

double CONFIG::get_cam_height_min()
{
    std::lock_guard<std::mutex> sensor_mtx;
    double res = CAM_HEIGHT_MIN;
    return res;
}

double CONFIG::get_cam_height_max()
{
    std::lock_guard<std::mutex> sensor_mtx;
    double res = CAM_HEIGHT_MAX;
    return res;
}

QString CONFIG::get_cam_serial_number(int idx)
{
    std::lock_guard<std::mutex> sensor_mtx;
    QString res = CAM_SERIAL_NUMBER[idx];
    return res;
}

QString CONFIG::get_cam_tf(int idx)
{
    std::lock_guard<std::mutex> sensor_mtx;
    QString res = CAM_TF[idx];
    return res;
}

int CONFIG::get_motor_id_left()
{
    std::lock_guard<std::mutex> motor_mtx;
    int res = MOTOR_ID_L;
    return res;
}

int CONFIG::get_motor_id_right()
{
    std::lock_guard<std::mutex> motor_mtx;
    int res = MOTOR_ID_R;
    return res;
}

double CONFIG::get_motor_direction()
{
    std::lock_guard<std::mutex> motor_mtx;
    double res = MOTOR_DIR;
    return res;
}

double CONFIG::get_motor_gear_ratio()
{
    std::lock_guard<std::mutex> motor_mtx;
    double res = MOTOR_GEAR_RATIO;
    return res;
}

double CONFIG::get_motor_limit_v()
{
    std::lock_guard<std::mutex> motor_mtx;
    double res = MOTOR_LIMIT_V;
    return res;
}

double CONFIG::get_motor_limit_v_acc()
{
    std::lock_guard<std::mutex> motor_mtx;
    double res = MOTOR_LIMIT_V_ACC;
    return res;
}

double CONFIG::get_motor_limit_w()
{
    std::lock_guard<std::mutex> motor_mtx;
    double res = MOTOR_LIMIT_W;
    return res;
}

double CONFIG::get_motor_limit_w_acc()
{
    std::lock_guard<std::mutex> motor_mtx;
    double res = MOTOR_LIMIT_W_ACC;
    return res;
}

double CONFIG::get_motor_gain_kp()
{
    std::lock_guard<std::mutex> motor_mtx;
    double res = MOTOR_GAIN_KP;
    return res;
}

double CONFIG::get_motor_gain_ki()
{
    std::lock_guard<std::mutex> motor_mtx;
    double res = MOTOR_GAIN_KI;
    return res;
}

double CONFIG::get_motor_gain_kd()
{
    std::lock_guard<std::mutex> motor_mtx;
    double res = MOTOR_GAIN_KD;
    return res;
}

int CONFIG::get_mapping_icp_max_feature_num()
{
    std::lock_guard<std::mutex> mapping_mtx;
    int res = MAPPING_ICP_MAX_FEATURE_NUM;
    return res;
}

int CONFIG::get_mapping_icp_do_erase_gap()
{
    std::lock_guard<std::mutex> mapping_mtx;
    int res = MAPPING_ICP_DO_ERASE_GAP;
    return res;
}

int CONFIG::get_mapping_icp_do_accum_num()
{
    std::lock_guard<std::mutex> mapping_mtx;
    int res = MAPPING_ICP_DO_ACCUM_NUM;
    return res;
}

int CONFIG::get_mapping_kfrm_update_num()
{
    std::lock_guard<std::mutex> mapping_mtx;
    int res = MAPPING_KFRM_UPDATE_NUM;
    return res;
}

int CONFIG::get_mapping_window_size()
{
    std::lock_guard<std::mutex> mapping_mtx;
    int res = MAPPING_WINDOW_SIZE;
    return res;
}

double CONFIG::get_mapping_icp_cost_threashold()
{
    std::lock_guard<std::mutex> mapping_mtx;
    double res = MAPPING_ICP_COST_THRESHOLD;
    return res;
}

double CONFIG::get_mapping_icp_error_threshold()
{
    std::lock_guard<std::mutex> mapping_mtx;
    double res = MAPPING_ICP_ERROR_THRESHOLD;
    return res;
}

double CONFIG::get_mapping_icp_view_threashold()
{
    std::lock_guard<std::mutex> mapping_mtx;
    double res = MAPPING_ICP_VIEW_THRESHOLD;
    return res;
}

double CONFIG::get_mapping_kfrm_lc_try_dist()
{
    std::lock_guard<std::mutex> mapping_mtx;
    double res = MAPPING_KFRM_LC_TRY_DIST;
    return res;
}

double CONFIG::get_mapping_kfrm_lc_try_overlap()
{
    std::lock_guard<std::mutex> mapping_mtx;
    double res = MAPPING_KFRM_LC_TRY_OVERLAP;
    return res;
}

double CONFIG::get_mapping_voxel_size()
{
    std::lock_guard<std::mutex> mapping_mtx;
    double res = MAPPING_VOXEL_SIZE;
    return res;
}

int CONFIG::get_loc_2d_icp_max_feature_num()
{
    std::lock_guard<std::mutex> loc_mtx;
    int res = LOC_2D_ICP_MAX_FEATURE_NUM;
    return res;
}

int CONFIG::get_loc_2d_surfel_num()
{
    std::lock_guard<std::mutex> loc_mtx;
    int res = LOC_2D_SURFEL_NUM;
    return res;
}

double CONFIG::get_loc_2d_icp_odometry_fusion_ratio()
{
    std::lock_guard<std::mutex> loc_mtx;
    double res = LOC_2D_ICP_ODO_FUSION_RATIO;
    return res;
}

double CONFIG::get_loc_2d_icp_cost_threshold()
{
    std::lock_guard<std::mutex> loc_mtx;
    double res = LOC_2D_ICP_COST_THRESHOLD;
    return res;
}

double CONFIG::get_loc_2d_icp_cost_threshold0()
{
    std::lock_guard<std::mutex> loc_mtx;
    double res = LOC_2D_ICP_COST_THRESHOLD_0;
    return res;
}

double CONFIG::get_loc_2d_icp_error_threshold()
{
    std::lock_guard<std::mutex> loc_mtx;
    double res = LOC_2D_ICP_ERROR_THRESHOLD;
    return res;
}

double CONFIG::get_loc_2d_aruco_odometry_fusion_ratio()
{
    std::lock_guard<std::mutex> loc_mtx;
    double res = LOC_2D_ARUCO_ODO_FUSION_RATIO;
    return res;
}

double CONFIG::get_loc_2d_aruco_odometry_fusion_dist()
{
    std::lock_guard<std::mutex> loc_mtx;
    double res = LOC_2D_ARUCO_ODO_FUSION_DIST;
    return res;
}

double CONFIG::get_loc_2d_surfel_range()
{
    std::lock_guard<std::mutex> loc_mtx;
    double res = LOC_2D_SURFEL_RANGE;
    return res;
}

double CONFIG::get_loc_2d_check_dist()
{
    std::lock_guard<std::mutex> loc_mtx;
    double res = LOC_2D_CHECK_DIST;
    return res;
}

double CONFIG::get_loc_2d_check_inlier_ratio()
{
    std::lock_guard<std::mutex> loc_mtx;
    double res = LOC_2D_CHECK_IE;
    return res;
}

double CONFIG::get_loc_2d_check_inlier_error()
{
    std::lock_guard<std::mutex> loc_mtx;
    double res = LOC_2D_CHECK_IR;
    return res;
}

int CONFIG::get_loc_3d_icp_max_feature_num()
{
    std::lock_guard<std::mutex> loc_mtx;
    int res = LOC_MAX_FEATURE_NUM;
    return res;
}

int CONFIG::get_loc_3d_surfel_nn_num()
{
    std::lock_guard<std::mutex> loc_mtx;
    int res = LOC_SURFEL_NN_NUM;
    return res;
}

double CONFIG::get_loc_3d_surfel_balance()
{
    std::lock_guard<std::mutex> loc_mtx;
    double res = LOC_SURFEL_BALANCE;
    return res;
}

double CONFIG::get_loc_3d_cost_threshold()
{
    std::lock_guard<std::mutex> loc_mtx;
    double res = LOC_COST_THRESHOLD;
    return res;
}

double CONFIG::get_loc_3d_inlier_check_dist()
{
    std::lock_guard<std::mutex> loc_mtx;
    double res = LOC_INLIER_CHECK_DIST;
    return res;
}

int CONFIG::get_obs_avoid_mode()
{
    std::lock_guard<std::mutex> obs_mtx;
    int res = OBS_AVOID;
    return res;
}

double CONFIG::get_obs_deadzone()
{
    std::lock_guard<std::mutex> obs_mtx;
    double res = OBS_DEADZONE;
    return res;
}

double CONFIG::get_obs_local_goal_dist()
{
    std::lock_guard<std::mutex> obs_mtx;
    double res = OBS_LOCAL_GOAL_D;
    return res;
}

double CONFIG::get_obs_safe_margin_x()
{
    std::lock_guard<std::mutex> obs_mtx;
    double res = OBS_SAFE_MARGIN_X;
    return res;
}

double CONFIG::get_obs_safe_margin_y()
{
    std::lock_guard<std::mutex> obs_mtx;
    double res = OBS_SAFE_MARGIN_Y;
    return res;
}

double CONFIG::get_obs_path_margin_x()
{
    std::lock_guard<std::mutex> obs_mtx;
    double res = OBS_PATH_MARGIN_X;
    return res;
}

double CONFIG::get_obs_path_margin_y()
{
    std::lock_guard<std::mutex> obs_mtx;
    double res = OBS_PATH_MARGIN_Y;
    return res;
}

double CONFIG::get_obs_map_grid_size()
{
    std::lock_guard<std::mutex> obs_mtx;
    double res = OBS_MAP_GRID_SIZE;
    return res;
}

double CONFIG::get_obs_map_range()
{
    std::lock_guard<std::mutex> obs_mtx;
    double res = OBS_MAP_RANGE;
    return res;
}

double CONFIG::get_obs_map_min_v()
{
    std::lock_guard<std::mutex> obs_mtx;
    double res = OBS_MAP_MIN_V;
    return res;
}

double CONFIG::get_obs_map_min_z()
{
    std::lock_guard<std::mutex> obs_mtx;
    double res = OBS_MAP_MIN_Z;
    return res;
}

double CONFIG::get_obs_map_max_z()
{
    std::lock_guard<std::mutex> obs_mtx;
    double res = OBS_MAP_MAX_Z;
    return res;
}

double CONFIG::get_obs_predict_time()
{
    std::lock_guard<std::mutex> obs_mtx;
    double res = OBS_PREDICT_TIME;
    return res;
}

double CONFIG::get_drive_goal_approach_gain()
{
    std::lock_guard<std::mutex> ctrl_mtx;
    double res = DRIVE_GOAL_APPROACH_GAIN;
    return res;
}

double CONFIG::get_drive_goal_dist()
{
    std::lock_guard<std::mutex> ctrl_mtx;
    double res = DRIVE_GOAL_D;
    return res;
}

double CONFIG::get_drive_goal_th()
{
    std::lock_guard<std::mutex> ctrl_mtx;
    double res = DRIVE_GOAL_TH;
    return res;
}

double CONFIG::get_drive_extended_control_time()
{
    std::lock_guard<std::mutex> ctrl_mtx;
    double res = DRIVE_EXTENDED_CONTROL_TIME;
    return res;
}

double CONFIG::get_drive_v_deadzone()
{
    std::lock_guard<std::mutex> ctrl_mtx;
    double res = DRIVE_V_DEADZONE;
    return res;
}

double CONFIG::get_drive_w_deadzone()
{
    std::lock_guard<std::mutex> ctrl_mtx;
    double res = DRIVE_W_DEADZONE;
    return res;
}

int CONFIG::get_docking_type()
{
    std::lock_guard<std::mutex> dctrl_mtx;
    int res = DOCKING_TYPE;
    return res;
}

int CONFIG::get_docking_map_size()
{
    std::lock_guard<std::mutex> dctrl_mtx;
    int res = DOCKING_MAP_SIZE;
    return res;
}

double CONFIG::get_docking_pointdock_margin()
{
    std::lock_guard<std::mutex> dctrl_mtx;
    double res = DOCKING_POINTDOCK_MARGIN;
    return res;
}

double CONFIG::get_docking_goal_dist()
{
    std::lock_guard<std::mutex> dctrl_mtx;
    double res = DOCKING_GOAL_D;
    return res;
}

double CONFIG::get_docking_goal_th()
{
    std::lock_guard<std::mutex> dctrl_mtx;
    double res = DOCKING_GOAL_TH;
    return res;
}

double CONFIG::get_docking_extended_control_time()
{
    std::lock_guard<std::mutex> dctrl_mtx;
    double res = DOCKING_EXTENDED_CONTROL_TIME;
    return res;
}

double CONFIG::get_docking_undock_reversing_distance()
{
    std::lock_guard<std::mutex> dctrl_mtx;
    double res = DOCK_UNDOCK_REVERSING_DISTANCE;
    return res;
}

double CONFIG::get_docking_kp_dist()
{
    std::lock_guard<std::mutex> dctrl_mtx;
    double res = DOCKING_KP_d;
    return res;
}

double CONFIG::get_docking_kd_dist()
{
    std::lock_guard<std::mutex> dctrl_mtx;
    double res = DOCKING_KD_d;
    return res;
}

double CONFIG::get_docking_kp_th()
{
    std::lock_guard<std::mutex> dctrl_mtx;
    double res = DOCKING_KP_th;
    return res;
}

double CONFIG::get_docking_kd_th()
{
    std::lock_guard<std::mutex> dctrl_mtx;
    double res = DOCKING_KD_th;
    return res;
}

double CONFIG::get_docking_clust_dist_threshold()
{
    std::lock_guard<std::mutex> dctrl_mtx;
    double res = DOCKING_CLUST_D_THRESHOLD;
    return res;
}

double CONFIG::get_docking_clust_dist_threshold_min()
{
    std::lock_guard<std::mutex> dctrl_mtx;
    double res = DOCKING_CLUST_DIST_THRESHOLD_MIN;
    return res;
}

double CONFIG::get_docking_clust_dist_threshold_max()
{
    std::lock_guard<std::mutex> dctrl_mtx;
    double res = DOCKING_CLUST_DIST_THRESHOLD_MAX;
    return res;
}

double CONFIG::get_docking_clust_angle_threshold()
{
    std::lock_guard<std::mutex> dctrl_mtx;
    double res = DOCKING_CLUST_ANGLE_THRESHOLD;
    return res;
}

double CONFIG::get_docking_size_x_min()
{
    std::lock_guard<std::mutex> dctrl_mtx;
    double res = DOCKING_DOCK_SIZE_X[0];
    return res;
}

double CONFIG::get_docking_size_x_max()
{
    std::lock_guard<std::mutex> dctrl_mtx;
    double res = DOCKING_DOCK_SIZE_X[1];
    return res;
}

double CONFIG::get_docking_icp_cost_threshold()
{
    std::lock_guard<std::mutex> dctrl_mtx;
    double res = DOCKING_ICP_COST_THRESHOLD;
    return res;
}

double CONFIG::get_docking_icp_max_feature_num()
{
    std::lock_guard<std::mutex> dctrl_mtx;
    double res = DOCKING_ICP_MAX_FEATURE_NUM;
    return res;
}

double CONFIG::get_docking_grid_size()
{
    std::lock_guard<std::mutex> dctrl_mtx;
    double res = DOCKING_GRID_SIZE;
    return res;
}

QString CONFIG::get_map_path()
{
    std::lock_guard<std::mutex> map_mtx;
    QString res = MAP_PATH;
    return res;
}

QStringList CONFIG::get_missing_variables()
{
    std::lock_guard<std::mutex> file_mtx;
    return missing_variables;
}

bool CONFIG::has_missing_variables()
{
    std::lock_guard<std::mutex> file_mtx;
    return !missing_variables.isEmpty();
}

void CONFIG::show_missing_variables_dialog()
{
    if(!has_missing_variables())
    {
        return;
    }

    QStringList missing = get_missing_variables();
    QString message = "다음 변수들이 JSON 파일에서 누락되었습니다:\n\n";
    
    for(const QString& var : missing)
    {
        message += "• " + var + "\n";
    }
    
    message += "\n기본값이 사용됩니다.";
    
    // Qt 메시지박스 사용
    #ifdef Q_OS_WIN
        QMessageBox::warning(nullptr, "Config Warning", message);
    #else
        printf("[CONFIG WARNING] %s\n", qUtf8Printable(message));
    #endif
}
