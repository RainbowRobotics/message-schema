/**
 * @file comm_zenoh_path.cpp
 * @brief Multi-robot Path 도메인 Zenoh 통신 구현
 *
 * RPC (Queryable):
 *   - multi/path
 *   - multi/vobs
 *
 * Publisher:
 *   - globalPath
 *   - localPath
 */

#include "comm_zenoh.h"
// #include "global_defines.h"
#include "slamnav_multi_generated.h"
#include "slamnav_socket_generated.h"

#include <QDebug>
#include <chrono>
#include <functional>

namespace
{
    const char* MODULE_NAME = "COMM_ZENOH_PATH";

    // =========================================================================
    // Helper: Build Response FlatBuffers
    // =========================================================================

    // Response_Path
    std::vector<uint8_t> build_response_path(
        const QString& id,
        const std::vector<QString>& path,
        const QString& result,
        const QString& message)
    {
        flatbuffers::FlatBufferBuilder fbb(1024);

        std::vector<flatbuffers::Offset<flatbuffers::String>> path_vec;
        for (const auto& p : path)
        {
            path_vec.push_back(fbb.CreateString(p.toStdString()));
        }

        auto resp = SLAMNAV::CreateResponse_Path(
            fbb,
            fbb.CreateString(id.toStdString()),
            fbb.CreateVector(path_vec),
            fbb.CreateString(result.toStdString()),
            fbb.CreateString(message.toStdString())
        );
        fbb.Finish(resp);

        const uint8_t* buf = fbb.GetBufferPointer();
        return std::vector<uint8_t>(buf, buf + fbb.GetSize());
    }

    // Response_Vobs
    std::vector<uint8_t> build_response_vobs(
        const QString& id,
        const std::vector<QString>& vobs_robots,
        const std::vector<QString>& vobs_closures,
        const QString& is_vobs_closures_change,
        const QString& result,
        const QString& message)
    {
        flatbuffers::FlatBufferBuilder fbb(2048);

        std::vector<flatbuffers::Offset<flatbuffers::String>> vobs_r_vec;
        for (const auto& v : vobs_robots)
        {
            vobs_r_vec.push_back(fbb.CreateString(v.toStdString()));
        }

        std::vector<flatbuffers::Offset<flatbuffers::String>> vobs_c_vec;
        for (const auto& v : vobs_closures)
        {
            vobs_c_vec.push_back(fbb.CreateString(v.toStdString()));
        }

        auto resp = SLAMNAV::CreateResponse_Vobs(
            fbb,
            fbb.CreateString(id.toStdString()),
            fbb.CreateVector(vobs_r_vec),
            fbb.CreateVector(vobs_c_vec),
            fbb.CreateString(is_vobs_closures_change.toStdString()),
            fbb.CreateString(result.toStdString()),
            fbb.CreateString(message.toStdString())
        );
        fbb.Finish(resp);

        const uint8_t* buf = fbb.GetBufferPointer();
        return std::vector<uint8_t>(buf, buf + fbb.GetSize());
    }

    // Global_Path
    std::vector<uint8_t> build_global_path(
        const QString& id,
        const std::vector<QString>& path)
    {
        flatbuffers::FlatBufferBuilder fbb(4096);

        std::vector<flatbuffers::Offset<flatbuffers::String>> path_vec;
        for (const auto& p : path)
        {
            path_vec.push_back(fbb.CreateString(p.toStdString()));
        }

        auto msg = SLAMNAV::CreateGlobal_Path(
            fbb,
            fbb.CreateString(id.toStdString()),
            fbb.CreateVector(path_vec)
        );
        fbb.Finish(msg);

        const uint8_t* buf = fbb.GetBufferPointer();
        return std::vector<uint8_t>(buf, buf + fbb.GetSize());
    }

    // Local_Path
    std::vector<uint8_t> build_local_path(
        const QString& id,
        const std::vector<QString>& path)
    {
        flatbuffers::FlatBufferBuilder fbb(4096);

        std::vector<flatbuffers::Offset<flatbuffers::String>> path_vec;
        for (const auto& p : path)
        {
            path_vec.push_back(fbb.CreateString(p.toStdString()));
        }

        auto msg = SLAMNAV::CreateLocal_Path(
            fbb,
            fbb.CreateString(id.toStdString()),
            fbb.CreateVector(path_vec)
        );
        fbb.Finish(msg);

        const uint8_t* buf = fbb.GetBufferPointer();
        return std::vector<uint8_t>(buf, buf + fbb.GetSize());
    }

} // anonymous namespace

// =============================================================================
// path_loop
// =============================================================================
void COMM_ZENOH::path_loop()
{
    qDebug() << "[" << MODULE_NAME << "] path_loop started";

    // 1. robotType 대기
    while (is_path_running_.load() && get_robot_type().empty())
    {
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }

    if (!is_path_running_.load())
    {
        qDebug() << "[" << MODULE_NAME << "] path_loop aborted (not running)";
        return;
    }

    // 2. Session 유효성 확인
    if (!is_session_valid())
    {
        qDebug() << "[" << MODULE_NAME << "] path_loop aborted (session invalid)";
        return;
    }

    try
    {
        zenoh::Session& session = get_session();

        // 3. Topic 생성
        std::string topic_path        = make_topic(ZENOH_TOPIC::MULTI_PATH);
        std::string topic_vobs        = make_topic(ZENOH_TOPIC::MULTI_VOBS);
        std::string topic_global_path = make_topic(ZENOH_TOPIC::GLOBAL_PATH);
        std::string topic_local_path  = make_topic(ZENOH_TOPIC::LOCAL_PATH);

        qDebug() << "[" << MODULE_NAME << "] Registering topics with prefix:" << QString::fromStdString(get_robot_type());

        // 4. Path Publishers 등록
        auto pub_global_path = session.declare_publisher(zenoh::KeyExpr(topic_global_path));
        auto pub_local_path = session.declare_publisher(zenoh::KeyExpr(topic_local_path));

        // =====================================================================
        // 5. Queryable: path (멀티로봇 경로 설정)
        // =====================================================================
        auto q_path = session.declare_queryable(
            zenoh::KeyExpr(topic_path),
            [this](const zenoh::Query& query)
            {
                QString id = "";
                std::vector<QString> path;
                QString result_str = "reject";
                QString message = "";

                const auto& payload = query.get_payload();
                if (!payload.has_value())
                {
                    message = "no payload";
                }
                else
                {
                    auto bytes = payload->as_vector();
                    auto req = SLAMNAV::GetRequest_Path(bytes.data());
                    if (!req || !req->id())
                    {
                        message = "invalid request";
                    }
                    else
                    {
                        id = QString::fromStdString(req->id()->str());

                        // 경로 추출
                        if (req->path())
                        {
                            for (size_t i = 0; i < req->path()->size(); ++i)
                            {
                                auto p = req->path()->Get(i);
                                if (p)
                                {
                                    path.push_back(QString::fromStdString(p->str()));
                                }
                            }
                        }

                        if (!config)
                        {
                            message = "config not available";
                        }
                        else if (!config->get_use_multi())
                        {
                            message = "use only in multi mode";
                        }
                        else if (!ctrl)
                        {
                            message = "controller not available";
                        }
                        else
                        {
                            // 경로 설정 및 이동 시작
                            ctrl->set_path(path, 0, 0.0);
                            ctrl->signal_move_multi();
                            result_str = "accept";
                        }
                    }
                }

                auto resp_buf = build_response_path(id, path, result_str, message);
                query.reply(zenoh::KeyExpr(query.get_keyexpr()), zenoh::Bytes::serialize(resp_buf));
            },
            zenoh::closures::none
        );
        qDebug() << "[" << MODULE_NAME << "] Queryable registered:" << QString::fromStdString(topic_path);

        // =====================================================================
        // 6. Queryable: vobs (가상 장애물 설정)
        // =====================================================================
        auto q_vobs = session.declare_queryable(
            zenoh::KeyExpr(topic_vobs),
            [this](const zenoh::Query& query)
            {
                QString id = "";
                std::vector<QString> vobs_robots;
                std::vector<QString> vobs_closures;
                QString is_vobs_closures_change = "false";
                QString result_str = "reject";
                QString message = "";

                const auto& payload = query.get_payload();
                if (!payload.has_value())
                {
                    message = "no payload";
                }
                else
                {
                    auto bytes = payload->as_vector();
                    auto req = SLAMNAV::GetRequest_Vobs(bytes.data());
                    if (!req || !req->id())
                    {
                        message = "invalid request";
                    }
                    else
                    {
                        id = QString::fromStdString(req->id()->str());

                        // vobs_robots 추출 (각 문자열: "x,y,z")
                        if (req->vobs_robots())
                        {
                            for (size_t i = 0; i < req->vobs_robots()->size(); ++i)
                            {
                                auto v = req->vobs_robots()->Get(i);
                                if (v)
                                {
                                    vobs_robots.push_back(QString::fromStdString(v->str()));
                                }
                            }
                        }

                        // vobs_closures 추출 (각 문자열: 노드 ID)
                        if (req->vobs_closures())
                        {
                            for (size_t i = 0; i < req->vobs_closures()->size(); ++i)
                            {
                                auto v = req->vobs_closures()->Get(i);
                                if (v)
                                {
                                    vobs_closures.push_back(QString::fromStdString(v->str()));
                                }
                            }
                        }

                        is_vobs_closures_change = req->is_vobs_closures_change() ?
                            QString::fromStdString(req->is_vobs_closures_change()->str()) : "false";

                        if (!obsmap)
                        {
                            message = "obsmap not available";
                        }
                        else
                        {
                            // vobs_robots 파싱 및 설정
                            std::vector<Eigen::Vector3d> vobs_r_list;
                            for (const auto& vobs_str : vobs_robots)
                            {
                                QStringList parts = vobs_str.split(",");
                                if (parts.size() == 3)
                                {
                                    Eigen::Vector3d P;
                                    P[0] = parts[0].toDouble();
                                    P[1] = parts[1].toDouble();
                                    P[2] = parts[2].toDouble();
                                    vobs_r_list.push_back(P);
                                }
                            }
                            obsmap->set_vobs_list_robots(vobs_r_list);

                            // vobs_closures 파싱 및 설정 (is_vobs_closures_change가 true인 경우)
                            if (is_vobs_closures_change == "true" && unimap)
                            {
                                std::vector<Eigen::Vector3d> vobs_c_list;
                                for (const auto& node_id : vobs_closures)
                                {
                                    if (!node_id.isEmpty())
                                    {
                                        if (NODE* node = unimap->get_node_by_id(node_id))
                                        {
                                            vobs_c_list.push_back(node->tf.block(0, 3, 3, 1));
                                        }
                                    }
                                }
                                obsmap->set_vobs_list_closures(vobs_c_list);
                            }

                            obsmap->update_vobs_map();
                            result_str = "accept";
                        }
                    }
                }

                auto resp_buf = build_response_vobs(id, vobs_robots, vobs_closures,
                                                    is_vobs_closures_change, result_str, message);
                query.reply(zenoh::KeyExpr(query.get_keyexpr()), zenoh::Bytes::serialize(resp_buf));
            },
            zenoh::closures::none
        );
        qDebug() << "[" << MODULE_NAME << "] Queryable registered:" << QString::fromStdString(topic_vobs);

        // =====================================================================
        // 7. Main loop (keep alive + path publishing)
        // =====================================================================
        PATH last_global_path;
        PATH last_local_path;

        auto last_global_publish = std::chrono::steady_clock::now();
        auto last_local_publish = std::chrono::steady_clock::now();

        while (is_path_running_.load())
        {
            auto now = std::chrono::steady_clock::now();

            // Global Path 발행 (변경 시)
            if (ctrl && now - last_global_publish >= std::chrono::milliseconds(500))
            {
                PATH path = ctrl->get_cur_global_path();
                if (!path.pos.empty())
                {
                    bool changed = (path.pos.size() != last_global_path.pos.size());
                    if (!changed && !path.pos.empty())
                    {
                        // 간단한 비교: 첫 번째와 마지막 점만 비교
                        changed = !path.pos.front().isApprox(last_global_path.pos.front(), 1e-3) ||
                                  !path.pos.back().isApprox(last_global_path.pos.back(), 1e-3);
                    }

                    if (changed)
                    {
                        std::vector<QString> path_strs;
                        for (const auto& P : path.pos)
                        {
                            path_strs.push_back(QString("%1,%2,%3")
                                .arg(P[0], 0, 'f', 4)
                                .arg(P[1], 0, 'f', 4)
                                .arg(P[2], 0, 'f', 4));
                        }

                        auto buf = build_global_path(QString::number(get_time0() * 1000, 'f', 0), path_strs);
                        pub_global_path.put(zenoh::Bytes::serialize(buf));

                        last_global_path = path;
                    }
                }
                last_global_publish = now;
            }

            // Local Path 발행 (변경 시, 10개마다 샘플링)
            if (ctrl && now - last_local_publish >= std::chrono::milliseconds(200))
            {
                PATH path = ctrl->get_cur_local_path();
                if (!path.pos.empty())
                {
                    bool changed = (path.pos.size() != last_local_path.pos.size());
                    if (!changed && !path.pos.empty())
                    {
                        changed = !path.pos.front().isApprox(last_local_path.pos.front(), 1e-3);
                    }

                    if (changed)
                    {
                        std::vector<QString> path_strs;
                        for (size_t i = 0; i < path.pos.size(); ++i)
                        {
                            // 처음, 끝, 10개마다 샘플링
                            if (i == 0 || i == path.pos.size() - 1 || i % 10 == 0)
                            {
                                const auto& P = path.pos[i];
                                path_strs.push_back(QString("%1,%2,%3")
                                    .arg(P[0], 0, 'f', 4)
                                    .arg(P[1], 0, 'f', 4)
                                    .arg(P[2], 0, 'f', 4));
                            }
                        }

                        auto buf = build_local_path(QString::number(get_time0() * 1000, 'f', 0), path_strs);
                        pub_local_path.put(zenoh::Bytes::serialize(buf));

                        last_local_path = path;
                    }
                }
                last_local_publish = now;
            }

            std::this_thread::sleep_for(std::chrono::milliseconds(50));
        }

        qDebug() << "[" << MODULE_NAME << "] path_loop ending, resources will be released";
    }
    catch (const zenoh::ZException& e)
    {
        qDebug() << "[" << MODULE_NAME << "] Zenoh exception:" << e.what();
    }
    catch (const std::exception& e)
    {
        qDebug() << "[" << MODULE_NAME << "] Exception:" << e.what();
    }

    qDebug() << "[" << MODULE_NAME << "] path_loop ended";
}
