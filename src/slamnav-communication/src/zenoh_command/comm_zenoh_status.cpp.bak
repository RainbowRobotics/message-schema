#include "comm_zenoh.h"
// #include "global_defines.h"
#include "flatbuffer/generated/slamnav_status_generated.h"

namespace
{
    constexpr const char* MODULE_NAME = "STATUS";
    constexpr double R2D = 180.0 / M_PI;
    constexpr int STATUS_INTERVAL_MS = 100;  // 100ms
}

void COMM_ZENOH::status_loop()
{
    log_info("status_loop started");

    while (is_status_running_.load() && get_robot_type().empty())
    {
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }

    if (!is_status_running_.load())
    {
        log_info("status_loop ended (stopped before init)");
        return;
    }

    log_info("status_loop initialized with robotType: {}", get_robot_type());

    auto last_status_time = std::chrono::steady_clock::now();
    const auto status_interval = std::chrono::milliseconds(STATUS_INTERVAL_MS);

    while (is_status_running_.load())
    {
        auto now = std::chrono::steady_clock::now();
        if (now - last_status_time >= status_interval)
        {
            publish_status(this);
            last_status_time = now;
        }
        std::this_thread::sleep_for(std::chrono::milliseconds(10));
    }

    log_info("status_loop ended");
}

// check from here
namespace
{
std::string get_charge_state_string(int charge_state, const std::string& robot_model)
{
    if (robot_model == "D400" || robot_model == "MECANUM")
    {
        switch (charge_state)
        {
            case CHARGE_STATE_IDLE:                return "none";
            case CHARGE_STATE_TRIG_TO_CHARGE:      return "ready";
            case CHARGE_STATE_BATTERY_ON:          return "battery_on";
            case CHARGE_STATE_CHARGING:            return "charging";
            case CHARGE_STATE_TRIG_TO_STOP_CHARGE: return "finish";
            case CHARGE_STATE_FAIL:                return "fail";
            default:                               return "none";
        }
    }
    else if (robot_model == "S100")
    {
        return (charge_state == 1) ? "charging" : "none";
    }
    return "none";
}

/**
 * @brief 맵 로드 상태를 문자열로 변환
 */
std::string get_map_status_string(int is_loaded)
{
    switch (is_loaded)
    {
        case MAP_NOT_LOADED: return "none";
        case MAP_LOADING:    return "loading";
        case MAP_LOADED:     return "loaded";
        default:             return "none";
    }
}
} // anonymous namespace

static void publish_status(COMM_ZENOH* zenoh)
{
    if (!zenoh->is_session_valid())
    {
        return;
    }

    MOBILE* mobile = zenoh->get_mobile();
    LOCALIZATION* loc = zenoh->get_localization();
    DOCKCONTROL* dctrl = zenoh->get_dockcontrol();
    CONFIG* config = zenoh->get_config();
    UNIMAP* unimap = zenoh->get_unimap();

    if (!mobile || !loc || !dctrl || !config || !unimap)
    {
        return;
    }

    try
    {
        flatbuffers::FlatBufferBuilder fbb(2048);

        MOBILE_STATUS ms = mobile->get_status();
        Eigen::Vector3d imu_data = mobile->get_imu();
        Eigen::Vector2d ieir = loc->get_cur_ieir();
        QString cur_loc_state = loc->get_cur_loc_state();
        QString robot_model = config->get_robot_model();
        bool is_dock = dctrl->get_dock_state();

        // 1. StatusCondition (struct)
        SLAMNAV::StatusCondition condition(
            static_cast<float>(ieir[0]),  // inlier_error
            static_cast<float>(ieir[1]),  // inlier_ratio
            static_cast<float>(ieir[0]),  // mapping_error
            static_cast<float>(ieir[1])   // mapping_ratio
        );

        // 2. StatusImu (struct)
        SLAMNAV::StatusImu status_imu(
            static_cast<float>(ms.imu_acc_x),
            static_cast<float>(ms.imu_acc_y),
            static_cast<float>(ms.imu_acc_z),
            static_cast<float>(ms.imu_gyr_x * R2D),
            static_cast<float>(ms.imu_gyr_y * R2D),
            static_cast<float>(ms.imu_gyr_z * R2D),
            static_cast<float>(imu_data[0] * R2D),
            static_cast<float>(imu_data[1] * R2D),
            static_cast<float>(imu_data[2] * R2D)
        );

        // 3. StatusMotor (struct) - motor0, motor1
        std::vector<flatbuffers::Offset<SLAMNAV::StatusMotor>> motor_offsets;
        // for(const auto* motor : motors)


        SLAMNAV::StatusMotor motor0(
            ms.connection_m0 == 1,
            ms.status_m0,
            static_cast<float>(ms.temp_m0),
            static_cast<float>(ms.cur_m0) / 10.0f
        );

        // SLAMNAV::StatusMotor motor1(
        //     ms.connection_m1 == 1,
        //     ms.status_m1,
        //     static_cast<float>(ms.temp_m1),
        //     static_cast<float>(ms.cur_m1) / 10.0f
        // );

        // 4. StatusPower (struct)
        float charge_current = 0.0f;
        float contact_voltage = 0.0f;
        if (robot_model == "D400" || robot_model == "MECANUM")
        {
            charge_current = static_cast<float>(ms.charge_current);
            contact_voltage = static_cast<float>(ms.contact_voltage);
        }

        SLAMNAV::StatusPower power(
            static_cast<float>(ms.bat_in),
            static_cast<float>(ms.bat_out),
            static_cast<float>(ms.bat_current),
            static_cast<float>(ms.total_power),
            static_cast<float>(ms.power),
            static_cast<float>(ms.bat_percent),
            static_cast<float>(ms.tabos_voltage),
            static_cast<float>(ms.tabos_current),
            static_cast<float>(ms.tabos_status),
            static_cast<float>(ms.tabos_ttf),
            static_cast<float>(ms.tabos_tte),
            static_cast<float>(ms.tabos_soc),
            static_cast<float>(ms.tabos_soh),
            static_cast<float>(ms.tabos_temperature),
            static_cast<float>(ms.tabos_rc),
            static_cast<float>(ms.tabos_ae),
            charge_current,
            contact_voltage
        );

        // 5. StatusRobotState (table)
        std::string charge_state = get_charge_state_string(
            ms.charge_state, robot_model.toStdString());

        auto robot_state = SLAMNAV::CreateStatusRobotStateDirect(
            fbb,
            charge_state.c_str(),                     // charge
            is_dock,                                  // dock
            ms.motor_stop_state == 1,                 // emo
            cur_loc_state.toStdString().c_str(),      // localization
            ms.power_state == 1,                      // power
            false,  // sss_recovery
            false,  // sw_reset
            false,  // sw_stop
            false,  // sw_start
            false,  // sf_bumper_detect
            false,  // sf_obs_detect
            false   // sf_operational_stop
        );

        // 6. StatusRobotSafetyIoState (table)
        std::vector<uint8_t> mcu0_dio, mcu1_dio, mcu0_din, mcu1_din;
        for (int i = 0; i < 8; i++)
        {
            mcu0_dio.push_back(ms.mcu0_dio[i] ? 1 : 0);
            mcu1_dio.push_back(ms.mcu1_dio[i] ? 1 : 0);
            mcu0_din.push_back(ms.mcu0_din[i] ? 1 : 0);
            mcu1_din.push_back(ms.mcu1_din[i] ? 1 : 0);
        }

        auto safety_io = SLAMNAV::CreateStatusRobotSafetyIoStateDirect(
            fbb,
            &mcu0_dio,
            &mcu1_dio,
            &mcu0_din,
            &mcu1_din
        );

        // 7. StatusSetting (table)
        auto setting = SLAMNAV::CreateStatusSettingDirect(
            fbb,
            config->get_robot_type().toStdString().c_str(),  // platform_type
            ""                                                // platform_name
        );

        // 8. StatusMap (table)
        std::string map_name;
        int is_loaded = static_cast<int>(unimap->get_is_loaded());
        if (is_loaded == MAP_LOADED)
        {
            QString map_path = unimap->get_map_path();
            QStringList parts = map_path.split("/");
            if (!parts.isEmpty())
            {
                map_name = parts.last().toStdString();
            }
        }
        std::string map_status = get_map_status_string(is_loaded);

        auto map_info = SLAMNAV::CreateStatusMapDirect(
            fbb,
            map_name.c_str(),
            map_status.c_str()
        );

        // Status 루트 메시지 생성
        auto status = SLAMNAV::CreateStatus(
            fbb,
            &condition,
            &status_imu,
            &motor0,
            &motor1,
            &power,
            robot_state,
            safety_io,
            setting,
            map_info
        );

        fbb.Finish(status);

        // Zenoh로 발행
        const uint8_t* data = fbb.GetBufferPointer();
        size_t size = fbb.GetSize();
        std::string payload(reinterpret_cast<const char*>(data), size);

        std::string topic = zenoh->make_topic(ZENOH_TOPIC::STATUS);
        zenoh->get_session().put(zenoh::KeyExpr(topic), payload);
    }
    catch (const std::exception& e)
    {
        log_error("publish_status error: {}", e.what());
    }
}


