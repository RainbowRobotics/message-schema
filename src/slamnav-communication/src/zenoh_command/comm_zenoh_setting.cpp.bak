/**
 * @file comm_zenoh_setting.cpp
 * @brief Setting 도메인 Zenoh 통신 구현
 *
 * RPC (Queryable):
 *   - setting/getSensorIndex, setting/setSensorIndex
 *   - setting/setSensorOn, setting/getSensorOff
 *   - setting/getPduParam, setting/setPduParam, setting/getDriveParam
 *
 * Publisher:
 *   - setting/result
 */

#include "comm_zenoh.h"
// #include "global_defines.h"
#include "flatbuffer/generated/slamnav_setting_generated.h"

#include <chrono>

namespace
{
    constexpr const char* MODULE_NAME = "SETTING";
    constexpr double R2D = 180.0 / M_PI;

    // =========================================================================
    // Helper: Setting_Result FlatBuffer
    // =========================================================================
    std::vector<uint8_t> build_setting_result(const std::string& id,
                                               const std::string& result,
                                               const std::string& message)
    {
        flatbuffers::FlatBufferBuilder fbb(256);

        auto fb_result = SLAMNAV::CreateSetting_Result(
            fbb,
            fbb.CreateString(id),
            fbb.CreateString(result),
            fbb.CreateString(message)
        );
        fbb.Finish(fb_result);

        const uint8_t* buf = fbb.GetBufferPointer();
        return std::vector<uint8_t>(buf, buf + fbb.GetSize());
    }

    // =========================================================================
    // Helper: Build Response FlatBuffers
    // =========================================================================

    // Response_Get_Sensor_Index
    std::vector<uint8_t> build_response_get_sensor_index(
        const std::string& id,
        const std::string& target,
        const std::vector<std::pair<int, std::string>>& index,
        const std::string& result,
        const std::string& message)
    {
        flatbuffers::FlatBufferBuilder fbb(512);

        std::vector<flatbuffers::Offset<SLAMNAV::SensorInfo>> index_vec;
        for (const auto& v : index)
        {
            auto si = SLAMNAV::CreateSensorInfo(fbb,
                v.first,
                fbb.CreateString(v.second)
            );
            index_vec.push_back(si);
        }

        auto resp = SLAMNAV::CreateResponse_Get_Sensor_Index(
            fbb,
            fbb.CreateString(id),
            fbb.CreateString(target),
            fbb.CreateVector(index_vec),
            fbb.CreateString(result),
            fbb.CreateString(message)
        );
        fbb.Finish(resp);

        const uint8_t* buf = fbb.GetBufferPointer();
        return std::vector<uint8_t>(buf, buf + fbb.GetSize());
    }

    // Response_Set_Sensor_Index
    std::vector<uint8_t> build_response_set_sensor_index(
        const std::string& id,
        const std::string& target,
        const std::vector<std::pair<int, std::string>>& index,
        const std::string& result,
        const std::string& message)
    {
        flatbuffers::FlatBufferBuilder fbb(512);

        std::vector<flatbuffers::Offset<SLAMNAV::SensorInfo>> index_vec;
        for (const auto& v : index)
        {
            auto si = SLAMNAV::CreateSensorInfo(fbb,
                v.first,
                fbb.CreateString(v.second)
            );
            index_vec.push_back(si);
        }

        auto resp = SLAMNAV::CreateResponse_Set_Sensor_Index(
            fbb,
            fbb.CreateString(id),
            fbb.CreateString(target),
            fbb.CreateVector(index_vec),
            fbb.CreateString(result),
            fbb.CreateString(message)
        );
        fbb.Finish(resp);

        const uint8_t* buf = fbb.GetBufferPointer();
        return std::vector<uint8_t>(buf, buf + fbb.GetSize());
    }

    // Response_Set_Sensor_On
    std::vector<uint8_t> build_response_set_sensor_on(
        const std::string& id,
        const std::string& target,
        const std::vector<std::pair<int, std::string>>& index,
        const std::string& result,
        const std::string& message)
    {
        flatbuffers::FlatBufferBuilder fbb(512);

        std::vector<flatbuffers::Offset<SLAMNAV::SensorInfo>> index_vec;
        for (const auto& v : index)
        {
            auto si = SLAMNAV::CreateSensorInfo(fbb,
                v.first,
                fbb.CreateString(v.second)
            );
            index_vec.push_back(si);
        }

        auto resp = SLAMNAV::CreateResponse_Set_Sensor_On(
            fbb,
            fbb.CreateString(id),
            fbb.CreateString(target),
            fbb.CreateVector(index_vec),
            fbb.CreateString(result),
            fbb.CreateString(message)
        );
        fbb.Finish(resp);

        const uint8_t* buf = fbb.GetBufferPointer();
        return std::vector<uint8_t>(buf, buf + fbb.GetSize());
    }

    // Response_Get_Sensor_Off
    std::vector<uint8_t> build_response_get_sensor_off(
        const std::string& id,
        const std::string& target,
        const std::vector<std::pair<int, std::string>>& index,
        const std::string& result,
        const std::string& message)
    {
        flatbuffers::FlatBufferBuilder fbb(512);

        std::vector<flatbuffers::Offset<SLAMNAV::SensorInfo>> index_vec;
        for (const auto& v : index)
        {
            auto si = SLAMNAV::CreateSensorInfo(fbb,
                v.first,
                fbb.CreateString(v.second)
            );
            index_vec.push_back(si);
        }

        auto resp = SLAMNAV::CreateResponse_Get_Sensor_Off(
            fbb,
            fbb.CreateString(id),
            fbb.CreateString(target),
            fbb.CreateVector(index_vec),
            fbb.CreateString(result),
            fbb.CreateString(message)
        );
        fbb.Finish(resp);

        const uint8_t* buf = fbb.GetBufferPointer();
        return std::vector<uint8_t>(buf, buf + fbb.GetSize());
    }

    // Response_Get_Pdu_Param
    std::vector<uint8_t> build_response_get_pdu_param(
        const std::string& id,
        const std::vector<std::tuple<std::string, std::string, std::string>>& params,
        const std::string& result,
        const std::string& message)
    {
        flatbuffers::FlatBufferBuilder fbb(1024);

        std::vector<flatbuffers::Offset<SLAMNAV::SettingParam>> params_vec;
        for (const auto& p : params)
        {
            params_vec.push_back(SLAMNAV::CreateSettingParam(fbb,
                fbb.CreateString(std::get<0>(p)),
                fbb.CreateString(std::get<1>(p)),
                fbb.CreateString(std::get<2>(p))
            ));
        }

        auto resp = SLAMNAV::CreateResponse_Get_Pdu_Param(
            fbb,
            fbb.CreateString(id),
            fbb.CreateVector(params_vec),
            fbb.CreateString(result),
            fbb.CreateString(message)
        );
        fbb.Finish(resp);

        const uint8_t* buf = fbb.GetBufferPointer();
        return std::vector<uint8_t>(buf, buf + fbb.GetSize());
    }

    // Response_Set_Pdu_Param
    std::vector<uint8_t> build_response_set_pdu_param(
        const std::string& id,
        const std::vector<std::tuple<std::string, std::string, std::string>>& params,
        const std::string& result,
        const std::string& message)
    {
        flatbuffers::FlatBufferBuilder fbb(1024);

        std::vector<flatbuffers::Offset<SLAMNAV::SettingParam>> params_vec;
        for (const auto& p : params)
        {
            params_vec.push_back(SLAMNAV::CreateSettingParam(fbb,
                fbb.CreateString(std::get<0>(p)),
                fbb.CreateString(std::get<1>(p)),
                fbb.CreateString(std::get<2>(p))
            ));
        }

        auto resp = SLAMNAV::CreateResponse_Set_Pdu_Param(
            fbb,
            fbb.CreateString(id),
            fbb.CreateVector(params_vec),
            fbb.CreateString(result),
            fbb.CreateString(message)
        );
        fbb.Finish(resp);

        const uint8_t* buf = fbb.GetBufferPointer();
        return std::vector<uint8_t>(buf, buf + fbb.GetSize());
    }

    // Response_Get_Drive_Param
    std::vector<uint8_t> build_response_get_drive_param(
        const std::string& id,
        const std::vector<std::tuple<std::string, std::string, std::string>>& params,
        const std::string& result,
        const std::string& message)
    {
        flatbuffers::FlatBufferBuilder fbb(1024);

        std::vector<flatbuffers::Offset<SLAMNAV::SettingParam>> params_vec;
        for (const auto& p : params)
        {
            params_vec.push_back(SLAMNAV::CreateSettingParam(fbb,
                fbb.CreateString(std::get<0>(p)),
                fbb.CreateString(std::get<1>(p)),
                fbb.CreateString(std::get<2>(p))
            ));
        }

        auto resp = SLAMNAV::CreateResponse_Get_Drive_Param(
            fbb,
            fbb.CreateString(id),
            fbb.CreateVector(params_vec),
            fbb.CreateString(result),
            fbb.CreateString(message)
        );
        fbb.Finish(resp);

        const uint8_t* buf = fbb.GetBufferPointer();
        return std::vector<uint8_t>(buf, buf + fbb.GetSize());
    }

} // anonymous namespace

// =============================================================================
// setting_loop
// =============================================================================
void COMM_ZENOH::setting_loop()
{
    log_info("setting_loop started");

    // 1. robotType 대기
    while (is_setting_running_.load() && get_robot_type().empty())
    {
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }

    if (!is_setting_running_.load())
    {
        log_info("setting_loop ended (stopped before init)");
        return;
    }

    // 2. Session 유효성 확인
    if (!is_session_valid())
    {
        log_error("setting_loop aborted: session invalid");
        return;
    }

    log_info("setting_loop initialized with robotType: {}", get_robot_type());

    try
    {
        zenoh::Session& session = get_session();

        // 3. Topic 생성
        std::string topic_get_sensor_index = make_topic(ZENOH_TOPIC::SETTING_GET_SENSOR_INDEX);
        std::string topic_set_sensor_index = make_topic(ZENOH_TOPIC::SETTING_SET_SENSOR_INDEX);
        std::string topic_set_sensor_on    = make_topic(ZENOH_TOPIC::SETTING_SET_SENSOR_ON);
        std::string topic_get_sensor_off   = make_topic(ZENOH_TOPIC::SETTING_GET_SENSOR_OFF);
        std::string topic_get_pdu          = make_topic(ZENOH_TOPIC::SETTING_GET_PDU);
        std::string topic_set_pdu          = make_topic(ZENOH_TOPIC::SETTING_SET_PDU);
        std::string topic_get_drive        = make_topic(ZENOH_TOPIC::SETTING_GET_DRIVE);
        std::string topic_result           = make_topic(ZENOH_TOPIC::SETTING_RESULT);

        log_info("setting_loop registering topics with prefix: {}", get_robot_type());

        // 4. Result Publisher 등록
        auto pub_result = session.declare_publisher(zenoh::KeyExpr(topic_result));

        // =========================================================================
        // 5. Queryable: getSensorIndex (카메라 인덱스/시리얼 조회)
        // =========================================================================
        auto q_get_sensor_index = session.declare_queryable(
            zenoh::KeyExpr(topic_get_sensor_index),
            [this, &pub_result](const zenoh::Query& query)
            {
                std::string id;
                std::string target;
                std::vector<std::pair<int, std::string>> index;
                std::string result_str = "reject";
                std::string message;

                const auto& payload = query.get_payload();
                if (!payload.has_value())
                {
                    message = "no payload";
                }
                else
                {
                    auto bytes = payload->as_vector();
                    auto req = SLAMNAV::GetRequest_Get_Sensor_Index(bytes.data());
                    if (!req || !req->id())
                    {
                        message = "invalid request";
                    }
                    else
                    {
                        id = req->id()->str();
                        target = req->target() ? req->target()->str() : "";

                        CONFIG* config_ptr = get_config();
                        if (!config_ptr)
                        {
                            message = "config not available";
                        }
                        else if (target == "cam")
                        {
                            for (int idx = 0; idx < config_ptr->get_cam_num(); ++idx)
                            {
                                auto serial = config_ptr->get_cam_serial_number(idx);
                                index.emplace_back(idx, serial.toStdString());
                            }
                            result_str = "accept";
                        }
                        else if (target == "lidar3d")
                        {
                            for (int idx = 0; idx < config_ptr->get_lidar_3d_num(); ++idx)
                            {
                                index.emplace_back(idx, "lidar3d_" + std::to_string(idx));
                            }
                            result_str = "accept";
                        }
                        else
                        {
                            message = "invalid target";
                        }
                    }
                }

                auto resp_buf = build_response_get_sensor_index(id, target, index, result_str, message);
                query.reply(zenoh::KeyExpr(query.get_keyexpr()), zenoh::Bytes::serialize(resp_buf));

                if (result_str == "accept" && !id.empty())
                {
                    auto result_buf = build_setting_result(id, "success", "");
                    pub_result.put(zenoh::Bytes::serialize(result_buf));
                }
            },
            zenoh::closures::none
        );
        log_info("Queryable registered: {}", topic_get_sensor_index);

        // =========================================================================
        // 6. Queryable: setSensorIndex (카메라 순서 설정)
        // =========================================================================
        auto q_set_sensor_index = session.declare_queryable(
            zenoh::KeyExpr(topic_set_sensor_index),
            [this, &pub_result](const zenoh::Query& query)
            {
                std::string id;
                std::string target;
                std::vector<std::pair<int, std::string>> index;
                std::string result_str = "reject";
                std::string message;

                const auto& payload = query.get_payload();
                if (!payload.has_value())
                {
                    message = "no payload";
                }
                else
                {
                    auto bytes = payload->as_vector();
                    auto req = SLAMNAV::GetRequest_Set_Sensor_Index(bytes.data());
                    if (!req || !req->id())
                    {
                        message = "invalid request";
                    }
                    else
                    {
                        id = req->id()->str();
                        target = req->target() ? req->target()->str() : "";

                        CONFIG* config_ptr = get_config();
                        if (!config_ptr)
                        {
                            message = "config not available";
                        }
                        else if (target == "cam")
                        {
                            if (req->index())
                            {
                                for (size_t i = 0; i < req->index()->size(); ++i)
                                {
                                    auto si = req->index()->Get(i);
                                    if (si)
                                    {
                                        int idx = si->index();
                                        std::string serial = si->serial_number() ?
                                            si->serial_number()->str() : "";
                                        index.emplace_back(idx, serial);
                                    }
                                }
                            }

                            int cam_num = config_ptr->get_cam_num();
                            bool valid = true;
                            for (const auto& v : index)
                            {
                                if (v.first >= cam_num)
                                {
                                    valid = false;
                                    message = "invalid index";
                                    break;
                                }
                            }

                            if (valid)
                            {
                                std::vector<QString> cam_serial_number;
                                cam_serial_number.resize(cam_num);
                                for (int i = 0; i < cam_num; ++i)
                                {
                                    bool found = false;
                                    for (const auto& v : index)
                                    {
                                        if (v.first == i)
                                        {
                                            cam_serial_number[i] = QString::fromStdString(v.second);
                                            found = true;
                                            break;
                                        }
                                    }
                                    if (!found)
                                    {
                                        cam_serial_number[i] = config_ptr->get_cam_serial_number(i);
                                    }
                                }

                                if (config_ptr->set_cam_order(cam_serial_number))
                                {
                                    result_str = "accept";
                                }
                                else
                                {
                                    message = "failed to set camera order";
                                }
                            }
                        }
                        else
                        {
                            message = "invalid target";
                        }
                    }
                }

                auto resp_buf = build_response_set_sensor_index(id, target, index, result_str, message);
                query.reply(zenoh::KeyExpr(query.get_keyexpr()), zenoh::Bytes::serialize(resp_buf));

                if (result_str == "accept" && !id.empty())
                {
                    auto result_buf = build_setting_result(id, "success", "");
                    pub_result.put(zenoh::Bytes::serialize(result_buf));
                }
            },
            zenoh::closures::none
        );
        log_info("Queryable registered: {}", topic_set_sensor_index);

        // =========================================================================
        // 7. Queryable: setSensorOn (센서 켜기)
        // =========================================================================
        auto q_set_sensor_on = session.declare_queryable(
            zenoh::KeyExpr(topic_set_sensor_on),
            [this, &pub_result](const zenoh::Query& query)
            {
                std::string id;
                std::string target;
                std::vector<std::pair<int, std::string>> index;
                std::string result_str = "reject";
                std::string message;

                const auto& payload = query.get_payload();
                if (!payload.has_value())
                {
                    message = "no payload";
                }
                else
                {
                    auto bytes = payload->as_vector();
                    auto req = SLAMNAV::GetRequest_Set_Sensor_On(bytes.data());
                    if (!req || !req->id())
                    {
                        message = "invalid request";
                    }
                    else
                    {
                        id = req->id()->str();
                        target = req->target() ? req->target()->str() : "";

                        if (req->index())
                        {
                            for (size_t i = 0; i < req->index()->size(); ++i)
                            {
                                auto si = req->index()->Get(i);
                                if (si)
                                {
                                    int idx = si->index();
                                    std::string serial = si->serial_number() ?
                                        si->serial_number()->str() : "";
                                    index.emplace_back(idx, serial);
                                }
                            }
                        }

                        LIDAR_3D* lidar_3d_ptr = get_lidar_3d();
                        CONFIG* config_ptr = get_config();

                        if (target == "lidar3d")
                        {
                            if (!lidar_3d_ptr || !lidar_3d_ptr->get_is_connected())
                            {
                                message = "lidar3d not connected";
                            }
                            else
                            {
                                std::vector<int> indexs;
                                int lidar_num = config_ptr ? config_ptr->get_lidar_3d_num() : 0;
                                bool valid = true;

                                for (const auto& v : index)
                                {
                                    if (v.first >= lidar_num)
                                    {
                                        valid = false;
                                        message = "invalid index";
                                        break;
                                    }
                                    indexs.push_back(v.first);
                                }

                                if (valid)
                                {
                                    lidar_3d_ptr->set_on(indexs);
                                    result_str = "accept";
                                }
                            }
                        }
                        else
                        {
                            message = "invalid target";
                        }
                    }
                }

                auto resp_buf = build_response_set_sensor_on(id, target, index, result_str, message);
                query.reply(zenoh::KeyExpr(query.get_keyexpr()), zenoh::Bytes::serialize(resp_buf));

                if (result_str == "accept" && !id.empty())
                {
                    auto result_buf = build_setting_result(id, "success", "");
                    pub_result.put(zenoh::Bytes::serialize(result_buf));
                }
            },
            zenoh::closures::none
        );
        log_info("Queryable registered: {}", topic_set_sensor_on);

        // =========================================================================
        // 8. Queryable: getSensorOff (센서 끄기)
        // =========================================================================
        auto q_get_sensor_off = session.declare_queryable(
            zenoh::KeyExpr(topic_get_sensor_off),
            [this, &pub_result](const zenoh::Query& query)
            {
                std::string id;
                std::string target;
                std::vector<std::pair<int, std::string>> index;
                std::string result_str = "reject";
                std::string message;

                const auto& payload = query.get_payload();
                if (!payload.has_value())
                {
                    message = "no payload";
                }
                else
                {
                    auto bytes = payload->as_vector();
                    auto req = SLAMNAV::GetRequest_Get_Sensor_Off(bytes.data());
                    if (!req || !req->id())
                    {
                        message = "invalid request";
                    }
                    else
                    {
                        id = req->id()->str();
                        target = req->target() ? req->target()->str() : "";

                        if (req->index())
                        {
                            for (size_t i = 0; i < req->index()->size(); ++i)
                            {
                                auto si = req->index()->Get(i);
                                if (si)
                                {
                                    int idx = si->index();
                                    std::string serial = si->serial_number() ?
                                        si->serial_number()->str() : "";
                                    index.emplace_back(idx, serial);
                                }
                            }
                        }

                        LIDAR_3D* lidar_3d_ptr = get_lidar_3d();
                        CONFIG* config_ptr = get_config();

                        if (target == "lidar3d")
                        {
                            if (!lidar_3d_ptr || !lidar_3d_ptr->get_is_connected())
                            {
                                message = "lidar3d not connected";
                            }
                            else
                            {
                                std::vector<int> indexs;
                                int lidar_num = config_ptr ? config_ptr->get_lidar_3d_num() : 0;
                                bool valid = true;

                                for (const auto& v : index)
                                {
                                    if (v.first >= lidar_num)
                                    {
                                        valid = false;
                                        message = "invalid index";
                                        break;
                                    }
                                    indexs.push_back(v.first);
                                }

                                if (valid)
                                {
                                    lidar_3d_ptr->set_off(indexs);
                                    result_str = "accept";
                                }
                            }
                        }
                        else
                        {
                            message = "invalid target";
                        }
                    }
                }

                auto resp_buf = build_response_get_sensor_off(id, target, index, result_str, message);
                query.reply(zenoh::KeyExpr(query.get_keyexpr()), zenoh::Bytes::serialize(resp_buf));

                if (result_str == "accept" && !id.empty())
                {
                    auto result_buf = build_setting_result(id, "success", "");
                    pub_result.put(zenoh::Bytes::serialize(result_buf));
                }
            },
            zenoh::closures::none
        );
        log_info("Queryable registered: {}", topic_get_sensor_off);

        // =========================================================================
        // 9. Queryable: getPduParam (PDU 파라미터 조회)
        // =========================================================================
        auto q_get_pdu = session.declare_queryable(
            zenoh::KeyExpr(topic_get_pdu),
            [this, &pub_result](const zenoh::Query& query)
            {
                std::string id;
                std::vector<std::tuple<std::string, std::string, std::string>> params;
                std::string result_str = "reject";
                std::string message;

                const auto& payload = query.get_payload();
                if (!payload.has_value())
                {
                    message = "no payload";
                }
                else
                {
                    auto bytes = payload->as_vector();
                    auto req = SLAMNAV::GetRequest_Get_Pdu_Param(bytes.data());
                    if (!req || !req->id())
                    {
                        message = "invalid request";
                    }
                    else
                    {
                        id = req->id()->str();

                        MOBILE* mobile_ptr = get_mobile();
                        if (!mobile_ptr)
                        {
                            message = "mobile not connected";
                        }
                        else
                        {
                            bool use_sf_obstacle_detect = mobile_ptr->get_detect_mode();
                            params.emplace_back("use_sf_obstacle_detect", "boolean",
                                use_sf_obstacle_detect ? "true" : "false");
                            result_str = "accept";
                        }
                    }
                }

                auto resp_buf = build_response_get_pdu_param(id, params, result_str, message);
                query.reply(zenoh::KeyExpr(query.get_keyexpr()), zenoh::Bytes::serialize(resp_buf));

                if (result_str == "accept" && !id.empty())
                {
                    auto result_buf = build_setting_result(id, "success", "");
                    pub_result.put(zenoh::Bytes::serialize(result_buf));
                }
            },
            zenoh::closures::none
        );
        log_info("Queryable registered: {}", topic_get_pdu);

        // =========================================================================
        // 10. Queryable: setPduParam (PDU 파라미터 설정)
        // =========================================================================
        auto q_set_pdu = session.declare_queryable(
            zenoh::KeyExpr(topic_set_pdu),
            [this, &pub_result](const zenoh::Query& query)
            {
                std::string id;
                std::vector<std::tuple<std::string, std::string, std::string>> params;
                std::string result_str = "reject";
                std::string message;

                const auto& payload = query.get_payload();
                if (!payload.has_value())
                {
                    message = "no payload";
                }
                else
                {
                    auto bytes = payload->as_vector();
                    auto req = SLAMNAV::GetRequest_Set_Pdu_Param(bytes.data());
                    if (!req || !req->id())
                    {
                        message = "invalid request";
                    }
                    else
                    {
                        id = req->id()->str();

                        MOBILE* mobile_ptr = get_mobile();
                        if (!mobile_ptr)
                        {
                            message = "mobile not connected";
                        }
                        else if (!req->params() || req->params()->size() == 0)
                        {
                            message = "no params";
                        }
                        else
                        {
                            for (size_t i = 0; i < req->params()->size(); ++i)
                            {
                                auto p = req->params()->Get(i);
                                if (p && p->key())
                                {
                                    std::string key = p->key()->str();
                                    std::string type = p->type() ? p->type()->str() : "";
                                    std::string value = p->value() ? p->value()->str() : "";
                                    params.emplace_back(key, type, value);
                                }
                            }

                            if (params.size() != 1)
                            {
                                message = "only one param supported";
                            }
                            else
                            {
                                auto& [key, type, value] = params[0];

                                if (key == "use_sf_obstacle_detect")
                                {
                                    if (type != "boolean")
                                    {
                                        message = "invalid type for use_sf_obstacle_detect";
                                    }
                                    else if (value != "true" && value != "false")
                                    {
                                        message = "invalid value for use_sf_obstacle_detect";
                                    }
                                    else
                                    {
                                        bool is_true = (value == "true");
                                        mobile_ptr->set_detect_mode(is_true);
                                        result_str = "accept";
                                    }
                                }
                                else
                                {
                                    message = "unknown parameter: " + key;
                                }
                            }
                        }
                    }
                }

                auto resp_buf = build_response_set_pdu_param(id, params, result_str, message);
                query.reply(zenoh::KeyExpr(query.get_keyexpr()), zenoh::Bytes::serialize(resp_buf));

                if (result_str == "accept" && !id.empty())
                {
                    auto result_buf = build_setting_result(id, "success", "");
                    pub_result.put(zenoh::Bytes::serialize(result_buf));
                }
            },
            zenoh::closures::none
        );
        log_info("Queryable registered: {}", topic_set_pdu);

        // =========================================================================
        // 11. Queryable: getDriveParam (드라이브 파라미터 조회)
        // =========================================================================
        auto q_get_drive = session.declare_queryable(
            zenoh::KeyExpr(topic_get_drive),
            [this, &pub_result](const zenoh::Query& query)
            {
                std::string id;
                std::vector<std::tuple<std::string, std::string, std::string>> params;
                std::string result_str = "reject";
                std::string message;

                const auto& payload = query.get_payload();
                if (!payload.has_value())
                {
                    message = "no payload";
                }
                else
                {
                    auto bytes = payload->as_vector();
                    auto req = SLAMNAV::GetRequest_Get_Drive_Param(bytes.data());
                    if (!req || !req->id())
                    {
                        message = "invalid request";
                    }
                    else
                    {
                        id = req->id()->str();

                        MOBILE* mobile_ptr = get_mobile();
                        if (!mobile_ptr)
                        {
                            message = "mobile not connected";
                        }
                        else
                        {
                            mobile_ptr->robot_request();
                            std::this_thread::sleep_for(std::chrono::milliseconds(500));

                            auto ms = mobile_ptr->get_setting();

                            char buf[32];
                            params.emplace_back("version", "int", std::to_string(ms.version));
                            params.emplace_back("robot_type", "int", std::to_string(ms.robot_type));

                            snprintf(buf, sizeof(buf), "%.3f", ms.v_limit);
                            params.emplace_back("v_limit", "float", buf);

                            snprintf(buf, sizeof(buf), "%.3f", ms.w_limit * R2D);
                            params.emplace_back("w_limit", "float", buf);

                            snprintf(buf, sizeof(buf), "%.3f", ms.a_limit);
                            params.emplace_back("a_limit", "float", buf);

                            snprintf(buf, sizeof(buf), "%.3f", ms.b_limit * R2D);
                            params.emplace_back("b_limit", "float", buf);

                            result_str = "accept";
                        }
                    }
                }

                auto resp_buf = build_response_get_drive_param(id, params, result_str, message);
                query.reply(zenoh::KeyExpr(query.get_keyexpr()), zenoh::Bytes::serialize(resp_buf));

                if (result_str == "accept" && !id.empty())
                {
                    auto result_buf = build_setting_result(id, "success", "");
                    pub_result.put(zenoh::Bytes::serialize(result_buf));
                }
            },
            zenoh::closures::none
        );
        log_info("Queryable registered: {}", topic_get_drive);

        // =========================================================================
        // 12. Main loop (keep alive)
        // =========================================================================
        while (is_setting_running_.load())
        {
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
        }

        log_info("setting_loop ending, resources will be released");
    }
    catch (const zenoh::ZException& e)
    {
        log_error("setting_loop Zenoh exception: {}", e.what());
    }
    catch (const std::exception& e)
    {
        log_error("setting_loop exception: {}", e.what());
    }

    log_info("setting_loop ended");
}
