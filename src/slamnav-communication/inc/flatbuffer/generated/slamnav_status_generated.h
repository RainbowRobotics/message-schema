// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SLAMNAVSTATUS_SLAMNAV_H_
#define FLATBUFFERS_GENERATED_SLAMNAVSTATUS_SLAMNAV_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 9 &&
              FLATBUFFERS_VERSION_REVISION == 23,
             "Non-compatible flatbuffers version included");

namespace SLAMNAV {

struct StatusImu;

struct StatusMotor;

struct StatusCondition;

struct StatusRobotState;
struct StatusRobotStateBuilder;

struct StatusRobotSafetyIoState;
struct StatusRobotSafetyIoStateBuilder;

struct StatusPower;

struct StatusSetting;
struct StatusSettingBuilder;

struct StatusMap;
struct StatusMapBuilder;

struct Status;
struct StatusBuilder;

struct StatusMoveState;
struct StatusMoveStateBuilder;

struct StatusPose;

struct StatusVel;

struct StatusNode;
struct StatusNodeBuilder;

struct Move_Status;
struct Move_StatusBuilder;

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) StatusImu FLATBUFFERS_FINAL_CLASS {
 private:
  float acc_x_;
  float acc_y_;
  float acc_z_;
  float gyr_x_;
  float gyr_y_;
  float gyr_z_;
  float imu_rx_;
  float imu_ry_;
  float imu_rz_;

 public:
  StatusImu()
      : acc_x_(0),
        acc_y_(0),
        acc_z_(0),
        gyr_x_(0),
        gyr_y_(0),
        gyr_z_(0),
        imu_rx_(0),
        imu_ry_(0),
        imu_rz_(0) {
  }
  StatusImu(float _acc_x, float _acc_y, float _acc_z, float _gyr_x, float _gyr_y, float _gyr_z, float _imu_rx, float _imu_ry, float _imu_rz)
      : acc_x_(::flatbuffers::EndianScalar(_acc_x)),
        acc_y_(::flatbuffers::EndianScalar(_acc_y)),
        acc_z_(::flatbuffers::EndianScalar(_acc_z)),
        gyr_x_(::flatbuffers::EndianScalar(_gyr_x)),
        gyr_y_(::flatbuffers::EndianScalar(_gyr_y)),
        gyr_z_(::flatbuffers::EndianScalar(_gyr_z)),
        imu_rx_(::flatbuffers::EndianScalar(_imu_rx)),
        imu_ry_(::flatbuffers::EndianScalar(_imu_ry)),
        imu_rz_(::flatbuffers::EndianScalar(_imu_rz)) {
  }
  float acc_x() const {
    return ::flatbuffers::EndianScalar(acc_x_);
  }
  float acc_y() const {
    return ::flatbuffers::EndianScalar(acc_y_);
  }
  float acc_z() const {
    return ::flatbuffers::EndianScalar(acc_z_);
  }
  float gyr_x() const {
    return ::flatbuffers::EndianScalar(gyr_x_);
  }
  float gyr_y() const {
    return ::flatbuffers::EndianScalar(gyr_y_);
  }
  float gyr_z() const {
    return ::flatbuffers::EndianScalar(gyr_z_);
  }
  float imu_rx() const {
    return ::flatbuffers::EndianScalar(imu_rx_);
  }
  float imu_ry() const {
    return ::flatbuffers::EndianScalar(imu_ry_);
  }
  float imu_rz() const {
    return ::flatbuffers::EndianScalar(imu_rz_);
  }
};
FLATBUFFERS_STRUCT_END(StatusImu, 36);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) StatusMotor FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t connection_;
  int8_t padding0__;  int16_t padding1__;
  int32_t status_;
  float temp_;
  float current_;

 public:
  StatusMotor()
      : connection_(0),
        padding0__(0),
        padding1__(0),
        status_(0),
        temp_(0),
        current_(0) {
    (void)padding0__;
    (void)padding1__;
  }
  StatusMotor(bool _connection, int32_t _status, float _temp, float _current)
      : connection_(::flatbuffers::EndianScalar(static_cast<uint8_t>(_connection))),
        padding0__(0),
        padding1__(0),
        status_(::flatbuffers::EndianScalar(_status)),
        temp_(::flatbuffers::EndianScalar(_temp)),
        current_(::flatbuffers::EndianScalar(_current)) {
    (void)padding0__;
    (void)padding1__;
  }
  bool connection() const {
    return ::flatbuffers::EndianScalar(connection_) != 0;
  }
  int32_t status() const {
    return ::flatbuffers::EndianScalar(status_);
  }
  float temp() const {
    return ::flatbuffers::EndianScalar(temp_);
  }
  float current() const {
    return ::flatbuffers::EndianScalar(current_);
  }
};
FLATBUFFERS_STRUCT_END(StatusMotor, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) StatusCondition FLATBUFFERS_FINAL_CLASS {
 private:
  float inlier_error_;
  float inlier_ratio_;
  float mapping_error_;
  float mapping_ratio_;

 public:
  StatusCondition()
      : inlier_error_(0),
        inlier_ratio_(0),
        mapping_error_(0),
        mapping_ratio_(0) {
  }
  StatusCondition(float _inlier_error, float _inlier_ratio, float _mapping_error, float _mapping_ratio)
      : inlier_error_(::flatbuffers::EndianScalar(_inlier_error)),
        inlier_ratio_(::flatbuffers::EndianScalar(_inlier_ratio)),
        mapping_error_(::flatbuffers::EndianScalar(_mapping_error)),
        mapping_ratio_(::flatbuffers::EndianScalar(_mapping_ratio)) {
  }
  float inlier_error() const {
    return ::flatbuffers::EndianScalar(inlier_error_);
  }
  float inlier_ratio() const {
    return ::flatbuffers::EndianScalar(inlier_ratio_);
  }
  float mapping_error() const {
    return ::flatbuffers::EndianScalar(mapping_error_);
  }
  float mapping_ratio() const {
    return ::flatbuffers::EndianScalar(mapping_ratio_);
  }
};
FLATBUFFERS_STRUCT_END(StatusCondition, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) StatusPower FLATBUFFERS_FINAL_CLASS {
 private:
  float bat_in_;
  float bat_out_;
  float bat_current_;
  float total_power_;
  float power_;
  float bat_percent_;
  float tabos_voltage_;
  float tabos_current_;
  float tabos_status_;
  float tabos_ttf_;
  float tabos_tte_;
  float tabos_soc_;
  float tabos_soh_;
  float tabos_temp_;
  float tabos_rc_;
  float tabos_ae_;
  float charge_current_;
  float contact_voltage_;

 public:
  StatusPower()
      : bat_in_(0),
        bat_out_(0),
        bat_current_(0),
        total_power_(0),
        power_(0),
        bat_percent_(0),
        tabos_voltage_(0),
        tabos_current_(0),
        tabos_status_(0),
        tabos_ttf_(0),
        tabos_tte_(0),
        tabos_soc_(0),
        tabos_soh_(0),
        tabos_temp_(0),
        tabos_rc_(0),
        tabos_ae_(0),
        charge_current_(0),
        contact_voltage_(0) {
  }
  StatusPower(float _bat_in, float _bat_out, float _bat_current, float _total_power, float _power, float _bat_percent, float _tabos_voltage, float _tabos_current, float _tabos_status, float _tabos_ttf, float _tabos_tte, float _tabos_soc, float _tabos_soh, float _tabos_temp, float _tabos_rc, float _tabos_ae, float _charge_current, float _contact_voltage)
      : bat_in_(::flatbuffers::EndianScalar(_bat_in)),
        bat_out_(::flatbuffers::EndianScalar(_bat_out)),
        bat_current_(::flatbuffers::EndianScalar(_bat_current)),
        total_power_(::flatbuffers::EndianScalar(_total_power)),
        power_(::flatbuffers::EndianScalar(_power)),
        bat_percent_(::flatbuffers::EndianScalar(_bat_percent)),
        tabos_voltage_(::flatbuffers::EndianScalar(_tabos_voltage)),
        tabos_current_(::flatbuffers::EndianScalar(_tabos_current)),
        tabos_status_(::flatbuffers::EndianScalar(_tabos_status)),
        tabos_ttf_(::flatbuffers::EndianScalar(_tabos_ttf)),
        tabos_tte_(::flatbuffers::EndianScalar(_tabos_tte)),
        tabos_soc_(::flatbuffers::EndianScalar(_tabos_soc)),
        tabos_soh_(::flatbuffers::EndianScalar(_tabos_soh)),
        tabos_temp_(::flatbuffers::EndianScalar(_tabos_temp)),
        tabos_rc_(::flatbuffers::EndianScalar(_tabos_rc)),
        tabos_ae_(::flatbuffers::EndianScalar(_tabos_ae)),
        charge_current_(::flatbuffers::EndianScalar(_charge_current)),
        contact_voltage_(::flatbuffers::EndianScalar(_contact_voltage)) {
  }
  float bat_in() const {
    return ::flatbuffers::EndianScalar(bat_in_);
  }
  float bat_out() const {
    return ::flatbuffers::EndianScalar(bat_out_);
  }
  float bat_current() const {
    return ::flatbuffers::EndianScalar(bat_current_);
  }
  float total_power() const {
    return ::flatbuffers::EndianScalar(total_power_);
  }
  float power() const {
    return ::flatbuffers::EndianScalar(power_);
  }
  float bat_percent() const {
    return ::flatbuffers::EndianScalar(bat_percent_);
  }
  float tabos_voltage() const {
    return ::flatbuffers::EndianScalar(tabos_voltage_);
  }
  float tabos_current() const {
    return ::flatbuffers::EndianScalar(tabos_current_);
  }
  float tabos_status() const {
    return ::flatbuffers::EndianScalar(tabos_status_);
  }
  float tabos_ttf() const {
    return ::flatbuffers::EndianScalar(tabos_ttf_);
  }
  float tabos_tte() const {
    return ::flatbuffers::EndianScalar(tabos_tte_);
  }
  float tabos_soc() const {
    return ::flatbuffers::EndianScalar(tabos_soc_);
  }
  float tabos_soh() const {
    return ::flatbuffers::EndianScalar(tabos_soh_);
  }
  float tabos_temp() const {
    return ::flatbuffers::EndianScalar(tabos_temp_);
  }
  float tabos_rc() const {
    return ::flatbuffers::EndianScalar(tabos_rc_);
  }
  float tabos_ae() const {
    return ::flatbuffers::EndianScalar(tabos_ae_);
  }
  float charge_current() const {
    return ::flatbuffers::EndianScalar(charge_current_);
  }
  float contact_voltage() const {
    return ::flatbuffers::EndianScalar(contact_voltage_);
  }
};
FLATBUFFERS_STRUCT_END(StatusPower, 72);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) StatusPose FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;
  float rz_;

 public:
  StatusPose()
      : x_(0),
        y_(0),
        z_(0),
        rz_(0) {
  }
  StatusPose(float _x, float _y, float _z, float _rz)
      : x_(::flatbuffers::EndianScalar(_x)),
        y_(::flatbuffers::EndianScalar(_y)),
        z_(::flatbuffers::EndianScalar(_z)),
        rz_(::flatbuffers::EndianScalar(_rz)) {
  }
  float x() const {
    return ::flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return ::flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return ::flatbuffers::EndianScalar(z_);
  }
  float rz() const {
    return ::flatbuffers::EndianScalar(rz_);
  }
};
FLATBUFFERS_STRUCT_END(StatusPose, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) StatusVel FLATBUFFERS_FINAL_CLASS {
 private:
  float vx_;
  float vy_;
  float wz_;

 public:
  StatusVel()
      : vx_(0),
        vy_(0),
        wz_(0) {
  }
  StatusVel(float _vx, float _vy, float _wz)
      : vx_(::flatbuffers::EndianScalar(_vx)),
        vy_(::flatbuffers::EndianScalar(_vy)),
        wz_(::flatbuffers::EndianScalar(_wz)) {
  }
  float vx() const {
    return ::flatbuffers::EndianScalar(vx_);
  }
  float vy() const {
    return ::flatbuffers::EndianScalar(vy_);
  }
  float wz() const {
    return ::flatbuffers::EndianScalar(wz_);
  }
};
FLATBUFFERS_STRUCT_END(StatusVel, 12);

struct StatusRobotState FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StatusRobotStateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHARGE = 4,
    VT_DOCK = 6,
    VT_EMO = 8,
    VT_LOCALIZATION = 10,
    VT_POWER = 12,
    VT_SSS_RECOVERY = 14,
    VT_SW_RESET = 16,
    VT_SW_STOP = 18,
    VT_SW_START = 20,
    VT_SF_BUMPER_DETECT = 22,
    VT_SF_OBS_DETECT = 24,
    VT_SF_OPERATIONAL_STOP = 26
  };
  const ::flatbuffers::String *charge() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CHARGE);
  }
  bool dock() const {
    return GetField<uint8_t>(VT_DOCK, 0) != 0;
  }
  bool emo() const {
    return GetField<uint8_t>(VT_EMO, 0) != 0;
  }
  const ::flatbuffers::String *localization() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LOCALIZATION);
  }
  bool power() const {
    return GetField<uint8_t>(VT_POWER, 0) != 0;
  }
  bool sss_recovery() const {
    return GetField<uint8_t>(VT_SSS_RECOVERY, 0) != 0;
  }
  bool sw_reset() const {
    return GetField<uint8_t>(VT_SW_RESET, 0) != 0;
  }
  bool sw_stop() const {
    return GetField<uint8_t>(VT_SW_STOP, 0) != 0;
  }
  bool sw_start() const {
    return GetField<uint8_t>(VT_SW_START, 0) != 0;
  }
  bool sf_bumper_detect() const {
    return GetField<uint8_t>(VT_SF_BUMPER_DETECT, 0) != 0;
  }
  bool sf_obs_detect() const {
    return GetField<uint8_t>(VT_SF_OBS_DETECT, 0) != 0;
  }
  bool sf_operational_stop() const {
    return GetField<uint8_t>(VT_SF_OPERATIONAL_STOP, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CHARGE) &&
           verifier.VerifyString(charge()) &&
           VerifyField<uint8_t>(verifier, VT_DOCK, 1) &&
           VerifyField<uint8_t>(verifier, VT_EMO, 1) &&
           VerifyOffset(verifier, VT_LOCALIZATION) &&
           verifier.VerifyString(localization()) &&
           VerifyField<uint8_t>(verifier, VT_POWER, 1) &&
           VerifyField<uint8_t>(verifier, VT_SSS_RECOVERY, 1) &&
           VerifyField<uint8_t>(verifier, VT_SW_RESET, 1) &&
           VerifyField<uint8_t>(verifier, VT_SW_STOP, 1) &&
           VerifyField<uint8_t>(verifier, VT_SW_START, 1) &&
           VerifyField<uint8_t>(verifier, VT_SF_BUMPER_DETECT, 1) &&
           VerifyField<uint8_t>(verifier, VT_SF_OBS_DETECT, 1) &&
           VerifyField<uint8_t>(verifier, VT_SF_OPERATIONAL_STOP, 1) &&
           verifier.EndTable();
  }
};

struct StatusRobotStateBuilder {
  typedef StatusRobotState Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_charge(::flatbuffers::Offset<::flatbuffers::String> charge) {
    fbb_.AddOffset(StatusRobotState::VT_CHARGE, charge);
  }
  void add_dock(bool dock) {
    fbb_.AddElement<uint8_t>(StatusRobotState::VT_DOCK, static_cast<uint8_t>(dock), 0);
  }
  void add_emo(bool emo) {
    fbb_.AddElement<uint8_t>(StatusRobotState::VT_EMO, static_cast<uint8_t>(emo), 0);
  }
  void add_localization(::flatbuffers::Offset<::flatbuffers::String> localization) {
    fbb_.AddOffset(StatusRobotState::VT_LOCALIZATION, localization);
  }
  void add_power(bool power) {
    fbb_.AddElement<uint8_t>(StatusRobotState::VT_POWER, static_cast<uint8_t>(power), 0);
  }
  void add_sss_recovery(bool sss_recovery) {
    fbb_.AddElement<uint8_t>(StatusRobotState::VT_SSS_RECOVERY, static_cast<uint8_t>(sss_recovery), 0);
  }
  void add_sw_reset(bool sw_reset) {
    fbb_.AddElement<uint8_t>(StatusRobotState::VT_SW_RESET, static_cast<uint8_t>(sw_reset), 0);
  }
  void add_sw_stop(bool sw_stop) {
    fbb_.AddElement<uint8_t>(StatusRobotState::VT_SW_STOP, static_cast<uint8_t>(sw_stop), 0);
  }
  void add_sw_start(bool sw_start) {
    fbb_.AddElement<uint8_t>(StatusRobotState::VT_SW_START, static_cast<uint8_t>(sw_start), 0);
  }
  void add_sf_bumper_detect(bool sf_bumper_detect) {
    fbb_.AddElement<uint8_t>(StatusRobotState::VT_SF_BUMPER_DETECT, static_cast<uint8_t>(sf_bumper_detect), 0);
  }
  void add_sf_obs_detect(bool sf_obs_detect) {
    fbb_.AddElement<uint8_t>(StatusRobotState::VT_SF_OBS_DETECT, static_cast<uint8_t>(sf_obs_detect), 0);
  }
  void add_sf_operational_stop(bool sf_operational_stop) {
    fbb_.AddElement<uint8_t>(StatusRobotState::VT_SF_OPERATIONAL_STOP, static_cast<uint8_t>(sf_operational_stop), 0);
  }
  explicit StatusRobotStateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StatusRobotState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StatusRobotState>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StatusRobotState> CreateStatusRobotState(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> charge = 0,
    bool dock = false,
    bool emo = false,
    ::flatbuffers::Offset<::flatbuffers::String> localization = 0,
    bool power = false,
    bool sss_recovery = false,
    bool sw_reset = false,
    bool sw_stop = false,
    bool sw_start = false,
    bool sf_bumper_detect = false,
    bool sf_obs_detect = false,
    bool sf_operational_stop = false) {
  StatusRobotStateBuilder builder_(_fbb);
  builder_.add_localization(localization);
  builder_.add_charge(charge);
  builder_.add_sf_operational_stop(sf_operational_stop);
  builder_.add_sf_obs_detect(sf_obs_detect);
  builder_.add_sf_bumper_detect(sf_bumper_detect);
  builder_.add_sw_start(sw_start);
  builder_.add_sw_stop(sw_stop);
  builder_.add_sw_reset(sw_reset);
  builder_.add_sss_recovery(sss_recovery);
  builder_.add_power(power);
  builder_.add_emo(emo);
  builder_.add_dock(dock);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<StatusRobotState> CreateStatusRobotStateDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *charge = nullptr,
    bool dock = false,
    bool emo = false,
    const char *localization = nullptr,
    bool power = false,
    bool sss_recovery = false,
    bool sw_reset = false,
    bool sw_stop = false,
    bool sw_start = false,
    bool sf_bumper_detect = false,
    bool sf_obs_detect = false,
    bool sf_operational_stop = false) {
  auto charge__ = charge ? _fbb.CreateString(charge) : 0;
  auto localization__ = localization ? _fbb.CreateString(localization) : 0;
  return SLAMNAV::CreateStatusRobotState(
      _fbb,
      charge__,
      dock,
      emo,
      localization__,
      power,
      sss_recovery,
      sw_reset,
      sw_stop,
      sw_start,
      sf_bumper_detect,
      sf_obs_detect,
      sf_operational_stop);
}

struct StatusRobotSafetyIoState FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StatusRobotSafetyIoStateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MCU0_DIO = 4,
    VT_MCU1_DIO = 6,
    VT_MCU0_DIN = 8,
    VT_MCU1_DIN = 10
  };
  const ::flatbuffers::Vector<uint8_t> *mcu0_dio() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_MCU0_DIO);
  }
  const ::flatbuffers::Vector<uint8_t> *mcu1_dio() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_MCU1_DIO);
  }
  const ::flatbuffers::Vector<uint8_t> *mcu0_din() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_MCU0_DIN);
  }
  const ::flatbuffers::Vector<uint8_t> *mcu1_din() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_MCU1_DIN);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MCU0_DIO) &&
           verifier.VerifyVector(mcu0_dio()) &&
           VerifyOffset(verifier, VT_MCU1_DIO) &&
           verifier.VerifyVector(mcu1_dio()) &&
           VerifyOffset(verifier, VT_MCU0_DIN) &&
           verifier.VerifyVector(mcu0_din()) &&
           VerifyOffset(verifier, VT_MCU1_DIN) &&
           verifier.VerifyVector(mcu1_din()) &&
           verifier.EndTable();
  }
};

struct StatusRobotSafetyIoStateBuilder {
  typedef StatusRobotSafetyIoState Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_mcu0_dio(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> mcu0_dio) {
    fbb_.AddOffset(StatusRobotSafetyIoState::VT_MCU0_DIO, mcu0_dio);
  }
  void add_mcu1_dio(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> mcu1_dio) {
    fbb_.AddOffset(StatusRobotSafetyIoState::VT_MCU1_DIO, mcu1_dio);
  }
  void add_mcu0_din(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> mcu0_din) {
    fbb_.AddOffset(StatusRobotSafetyIoState::VT_MCU0_DIN, mcu0_din);
  }
  void add_mcu1_din(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> mcu1_din) {
    fbb_.AddOffset(StatusRobotSafetyIoState::VT_MCU1_DIN, mcu1_din);
  }
  explicit StatusRobotSafetyIoStateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StatusRobotSafetyIoState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StatusRobotSafetyIoState>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StatusRobotSafetyIoState> CreateStatusRobotSafetyIoState(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> mcu0_dio = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> mcu1_dio = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> mcu0_din = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> mcu1_din = 0) {
  StatusRobotSafetyIoStateBuilder builder_(_fbb);
  builder_.add_mcu1_din(mcu1_din);
  builder_.add_mcu0_din(mcu0_din);
  builder_.add_mcu1_dio(mcu1_dio);
  builder_.add_mcu0_dio(mcu0_dio);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<StatusRobotSafetyIoState> CreateStatusRobotSafetyIoStateDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *mcu0_dio = nullptr,
    const std::vector<uint8_t> *mcu1_dio = nullptr,
    const std::vector<uint8_t> *mcu0_din = nullptr,
    const std::vector<uint8_t> *mcu1_din = nullptr) {
  auto mcu0_dio__ = mcu0_dio ? _fbb.CreateVector<uint8_t>(*mcu0_dio) : 0;
  auto mcu1_dio__ = mcu1_dio ? _fbb.CreateVector<uint8_t>(*mcu1_dio) : 0;
  auto mcu0_din__ = mcu0_din ? _fbb.CreateVector<uint8_t>(*mcu0_din) : 0;
  auto mcu1_din__ = mcu1_din ? _fbb.CreateVector<uint8_t>(*mcu1_din) : 0;
  return SLAMNAV::CreateStatusRobotSafetyIoState(
      _fbb,
      mcu0_dio__,
      mcu1_dio__,
      mcu0_din__,
      mcu1_din__);
}

struct StatusSetting FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StatusSettingBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLATFORM_TYPE = 4,
    VT_PLATFORM_NAME = 6
  };
  const ::flatbuffers::String *platform_type() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PLATFORM_TYPE);
  }
  const ::flatbuffers::String *platform_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PLATFORM_NAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PLATFORM_TYPE) &&
           verifier.VerifyString(platform_type()) &&
           VerifyOffset(verifier, VT_PLATFORM_NAME) &&
           verifier.VerifyString(platform_name()) &&
           verifier.EndTable();
  }
};

struct StatusSettingBuilder {
  typedef StatusSetting Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_platform_type(::flatbuffers::Offset<::flatbuffers::String> platform_type) {
    fbb_.AddOffset(StatusSetting::VT_PLATFORM_TYPE, platform_type);
  }
  void add_platform_name(::flatbuffers::Offset<::flatbuffers::String> platform_name) {
    fbb_.AddOffset(StatusSetting::VT_PLATFORM_NAME, platform_name);
  }
  explicit StatusSettingBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StatusSetting> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StatusSetting>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StatusSetting> CreateStatusSetting(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> platform_type = 0,
    ::flatbuffers::Offset<::flatbuffers::String> platform_name = 0) {
  StatusSettingBuilder builder_(_fbb);
  builder_.add_platform_name(platform_name);
  builder_.add_platform_type(platform_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<StatusSetting> CreateStatusSettingDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *platform_type = nullptr,
    const char *platform_name = nullptr) {
  auto platform_type__ = platform_type ? _fbb.CreateString(platform_type) : 0;
  auto platform_name__ = platform_name ? _fbb.CreateString(platform_name) : 0;
  return SLAMNAV::CreateStatusSetting(
      _fbb,
      platform_type__,
      platform_name__);
}

struct StatusMap FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StatusMapBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MAP_NAME = 4,
    VT_MAP_STATUS = 6
  };
  const ::flatbuffers::String *map_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MAP_NAME);
  }
  const ::flatbuffers::String *map_status() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MAP_STATUS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MAP_NAME) &&
           verifier.VerifyString(map_name()) &&
           VerifyOffset(verifier, VT_MAP_STATUS) &&
           verifier.VerifyString(map_status()) &&
           verifier.EndTable();
  }
};

struct StatusMapBuilder {
  typedef StatusMap Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_map_name(::flatbuffers::Offset<::flatbuffers::String> map_name) {
    fbb_.AddOffset(StatusMap::VT_MAP_NAME, map_name);
  }
  void add_map_status(::flatbuffers::Offset<::flatbuffers::String> map_status) {
    fbb_.AddOffset(StatusMap::VT_MAP_STATUS, map_status);
  }
  explicit StatusMapBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StatusMap> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StatusMap>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StatusMap> CreateStatusMap(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> map_name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> map_status = 0) {
  StatusMapBuilder builder_(_fbb);
  builder_.add_map_status(map_status);
  builder_.add_map_name(map_name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<StatusMap> CreateStatusMapDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *map_name = nullptr,
    const char *map_status = nullptr) {
  auto map_name__ = map_name ? _fbb.CreateString(map_name) : 0;
  auto map_status__ = map_status ? _fbb.CreateString(map_status) : 0;
  return SLAMNAV::CreateStatusMap(
      _fbb,
      map_name__,
      map_status__);
}

struct Status FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StatusBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONDITION = 4,
    VT_IMU = 6,
    VT_MOTOR = 8,
    VT_POWER = 10,
    VT_ROBOT_STATE = 12,
    VT_ROBOT_SAFETY_IO_STATE = 14,
    VT_SETTING = 16,
    VT_MAP = 18
  };
  const SLAMNAV::StatusCondition *condition() const {
    return GetStruct<const SLAMNAV::StatusCondition *>(VT_CONDITION);
  }
  const SLAMNAV::StatusImu *imu() const {
    return GetStruct<const SLAMNAV::StatusImu *>(VT_IMU);
  }
  const ::flatbuffers::Vector<const SLAMNAV::StatusMotor *> *motor() const {
    return GetPointer<const ::flatbuffers::Vector<const SLAMNAV::StatusMotor *> *>(VT_MOTOR);
  }
  const SLAMNAV::StatusPower *power() const {
    return GetStruct<const SLAMNAV::StatusPower *>(VT_POWER);
  }
  const SLAMNAV::StatusRobotState *robot_state() const {
    return GetPointer<const SLAMNAV::StatusRobotState *>(VT_ROBOT_STATE);
  }
  const SLAMNAV::StatusRobotSafetyIoState *robot_safety_io_state() const {
    return GetPointer<const SLAMNAV::StatusRobotSafetyIoState *>(VT_ROBOT_SAFETY_IO_STATE);
  }
  const SLAMNAV::StatusSetting *setting() const {
    return GetPointer<const SLAMNAV::StatusSetting *>(VT_SETTING);
  }
  const SLAMNAV::StatusMap *map() const {
    return GetPointer<const SLAMNAV::StatusMap *>(VT_MAP);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<SLAMNAV::StatusCondition>(verifier, VT_CONDITION, 4) &&
           VerifyField<SLAMNAV::StatusImu>(verifier, VT_IMU, 4) &&
           VerifyOffset(verifier, VT_MOTOR) &&
           verifier.VerifyVector(motor()) &&
           VerifyField<SLAMNAV::StatusPower>(verifier, VT_POWER, 4) &&
           VerifyOffset(verifier, VT_ROBOT_STATE) &&
           verifier.VerifyTable(robot_state()) &&
           VerifyOffset(verifier, VT_ROBOT_SAFETY_IO_STATE) &&
           verifier.VerifyTable(robot_safety_io_state()) &&
           VerifyOffset(verifier, VT_SETTING) &&
           verifier.VerifyTable(setting()) &&
           VerifyOffset(verifier, VT_MAP) &&
           verifier.VerifyTable(map()) &&
           verifier.EndTable();
  }
};

struct StatusBuilder {
  typedef Status Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_condition(const SLAMNAV::StatusCondition *condition) {
    fbb_.AddStruct(Status::VT_CONDITION, condition);
  }
  void add_imu(const SLAMNAV::StatusImu *imu) {
    fbb_.AddStruct(Status::VT_IMU, imu);
  }
  void add_motor(::flatbuffers::Offset<::flatbuffers::Vector<const SLAMNAV::StatusMotor *>> motor) {
    fbb_.AddOffset(Status::VT_MOTOR, motor);
  }
  void add_power(const SLAMNAV::StatusPower *power) {
    fbb_.AddStruct(Status::VT_POWER, power);
  }
  void add_robot_state(::flatbuffers::Offset<SLAMNAV::StatusRobotState> robot_state) {
    fbb_.AddOffset(Status::VT_ROBOT_STATE, robot_state);
  }
  void add_robot_safety_io_state(::flatbuffers::Offset<SLAMNAV::StatusRobotSafetyIoState> robot_safety_io_state) {
    fbb_.AddOffset(Status::VT_ROBOT_SAFETY_IO_STATE, robot_safety_io_state);
  }
  void add_setting(::flatbuffers::Offset<SLAMNAV::StatusSetting> setting) {
    fbb_.AddOffset(Status::VT_SETTING, setting);
  }
  void add_map(::flatbuffers::Offset<SLAMNAV::StatusMap> map) {
    fbb_.AddOffset(Status::VT_MAP, map);
  }
  explicit StatusBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Status> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Status>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Status> CreateStatus(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const SLAMNAV::StatusCondition *condition = nullptr,
    const SLAMNAV::StatusImu *imu = nullptr,
    ::flatbuffers::Offset<::flatbuffers::Vector<const SLAMNAV::StatusMotor *>> motor = 0,
    const SLAMNAV::StatusPower *power = nullptr,
    ::flatbuffers::Offset<SLAMNAV::StatusRobotState> robot_state = 0,
    ::flatbuffers::Offset<SLAMNAV::StatusRobotSafetyIoState> robot_safety_io_state = 0,
    ::flatbuffers::Offset<SLAMNAV::StatusSetting> setting = 0,
    ::flatbuffers::Offset<SLAMNAV::StatusMap> map = 0) {
  StatusBuilder builder_(_fbb);
  builder_.add_map(map);
  builder_.add_setting(setting);
  builder_.add_robot_safety_io_state(robot_safety_io_state);
  builder_.add_robot_state(robot_state);
  builder_.add_power(power);
  builder_.add_motor(motor);
  builder_.add_imu(imu);
  builder_.add_condition(condition);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Status> CreateStatusDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const SLAMNAV::StatusCondition *condition = nullptr,
    const SLAMNAV::StatusImu *imu = nullptr,
    const std::vector<SLAMNAV::StatusMotor> *motor = nullptr,
    const SLAMNAV::StatusPower *power = nullptr,
    ::flatbuffers::Offset<SLAMNAV::StatusRobotState> robot_state = 0,
    ::flatbuffers::Offset<SLAMNAV::StatusRobotSafetyIoState> robot_safety_io_state = 0,
    ::flatbuffers::Offset<SLAMNAV::StatusSetting> setting = 0,
    ::flatbuffers::Offset<SLAMNAV::StatusMap> map = 0) {
  auto motor__ = motor ? _fbb.CreateVectorOfStructs<SLAMNAV::StatusMotor>(*motor) : 0;
  return SLAMNAV::CreateStatus(
      _fbb,
      condition,
      imu,
      motor__,
      power,
      robot_state,
      robot_safety_io_state,
      setting,
      map);
}

struct StatusMoveState FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StatusMoveStateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AUTO_MOVE = 4,
    VT_DOCK_MOVE = 6,
    VT_JOG_MOVE = 8,
    VT_OBS = 10,
    VT_PATH = 12
  };
  const ::flatbuffers::String *auto_move() const {
    return GetPointer<const ::flatbuffers::String *>(VT_AUTO_MOVE);
  }
  const ::flatbuffers::String *dock_move() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DOCK_MOVE);
  }
  const ::flatbuffers::String *jog_move() const {
    return GetPointer<const ::flatbuffers::String *>(VT_JOG_MOVE);
  }
  const ::flatbuffers::String *obs() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OBS);
  }
  const ::flatbuffers::String *path() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PATH);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_AUTO_MOVE) &&
           verifier.VerifyString(auto_move()) &&
           VerifyOffset(verifier, VT_DOCK_MOVE) &&
           verifier.VerifyString(dock_move()) &&
           VerifyOffset(verifier, VT_JOG_MOVE) &&
           verifier.VerifyString(jog_move()) &&
           VerifyOffset(verifier, VT_OBS) &&
           verifier.VerifyString(obs()) &&
           VerifyOffset(verifier, VT_PATH) &&
           verifier.VerifyString(path()) &&
           verifier.EndTable();
  }
};

struct StatusMoveStateBuilder {
  typedef StatusMoveState Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_auto_move(::flatbuffers::Offset<::flatbuffers::String> auto_move) {
    fbb_.AddOffset(StatusMoveState::VT_AUTO_MOVE, auto_move);
  }
  void add_dock_move(::flatbuffers::Offset<::flatbuffers::String> dock_move) {
    fbb_.AddOffset(StatusMoveState::VT_DOCK_MOVE, dock_move);
  }
  void add_jog_move(::flatbuffers::Offset<::flatbuffers::String> jog_move) {
    fbb_.AddOffset(StatusMoveState::VT_JOG_MOVE, jog_move);
  }
  void add_obs(::flatbuffers::Offset<::flatbuffers::String> obs) {
    fbb_.AddOffset(StatusMoveState::VT_OBS, obs);
  }
  void add_path(::flatbuffers::Offset<::flatbuffers::String> path) {
    fbb_.AddOffset(StatusMoveState::VT_PATH, path);
  }
  explicit StatusMoveStateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StatusMoveState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StatusMoveState>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StatusMoveState> CreateStatusMoveState(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> auto_move = 0,
    ::flatbuffers::Offset<::flatbuffers::String> dock_move = 0,
    ::flatbuffers::Offset<::flatbuffers::String> jog_move = 0,
    ::flatbuffers::Offset<::flatbuffers::String> obs = 0,
    ::flatbuffers::Offset<::flatbuffers::String> path = 0) {
  StatusMoveStateBuilder builder_(_fbb);
  builder_.add_path(path);
  builder_.add_obs(obs);
  builder_.add_jog_move(jog_move);
  builder_.add_dock_move(dock_move);
  builder_.add_auto_move(auto_move);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<StatusMoveState> CreateStatusMoveStateDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *auto_move = nullptr,
    const char *dock_move = nullptr,
    const char *jog_move = nullptr,
    const char *obs = nullptr,
    const char *path = nullptr) {
  auto auto_move__ = auto_move ? _fbb.CreateString(auto_move) : 0;
  auto dock_move__ = dock_move ? _fbb.CreateString(dock_move) : 0;
  auto jog_move__ = jog_move ? _fbb.CreateString(jog_move) : 0;
  auto obs__ = obs ? _fbb.CreateString(obs) : 0;
  auto path__ = path ? _fbb.CreateString(path) : 0;
  return SLAMNAV::CreateStatusMoveState(
      _fbb,
      auto_move__,
      dock_move__,
      jog_move__,
      obs__,
      path__);
}

struct StatusNode FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StatusNodeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NODE_ID = 4,
    VT_NAME = 6,
    VT_STATE = 8,
    VT_X = 10,
    VT_Y = 12,
    VT_RZ = 14
  };
  const ::flatbuffers::String *node_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NODE_ID);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::String *state() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STATE);
  }
  float x() const {
    return GetField<float>(VT_X, 0.0f);
  }
  float y() const {
    return GetField<float>(VT_Y, 0.0f);
  }
  float rz() const {
    return GetField<float>(VT_RZ, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NODE_ID) &&
           verifier.VerifyString(node_id()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_STATE) &&
           verifier.VerifyString(state()) &&
           VerifyField<float>(verifier, VT_X, 4) &&
           VerifyField<float>(verifier, VT_Y, 4) &&
           VerifyField<float>(verifier, VT_RZ, 4) &&
           verifier.EndTable();
  }
};

struct StatusNodeBuilder {
  typedef StatusNode Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_node_id(::flatbuffers::Offset<::flatbuffers::String> node_id) {
    fbb_.AddOffset(StatusNode::VT_NODE_ID, node_id);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(StatusNode::VT_NAME, name);
  }
  void add_state(::flatbuffers::Offset<::flatbuffers::String> state) {
    fbb_.AddOffset(StatusNode::VT_STATE, state);
  }
  void add_x(float x) {
    fbb_.AddElement<float>(StatusNode::VT_X, x, 0.0f);
  }
  void add_y(float y) {
    fbb_.AddElement<float>(StatusNode::VT_Y, y, 0.0f);
  }
  void add_rz(float rz) {
    fbb_.AddElement<float>(StatusNode::VT_RZ, rz, 0.0f);
  }
  explicit StatusNodeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StatusNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StatusNode>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StatusNode> CreateStatusNode(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> node_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> state = 0,
    float x = 0.0f,
    float y = 0.0f,
    float rz = 0.0f) {
  StatusNodeBuilder builder_(_fbb);
  builder_.add_rz(rz);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add_state(state);
  builder_.add_name(name);
  builder_.add_node_id(node_id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<StatusNode> CreateStatusNodeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *node_id = nullptr,
    const char *name = nullptr,
    const char *state = nullptr,
    float x = 0.0f,
    float y = 0.0f,
    float rz = 0.0f) {
  auto node_id__ = node_id ? _fbb.CreateString(node_id) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto state__ = state ? _fbb.CreateString(state) : 0;
  return SLAMNAV::CreateStatusNode(
      _fbb,
      node_id__,
      name__,
      state__,
      x,
      y,
      rz);
}

struct Move_Status FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Move_StatusBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CUR_NODE = 4,
    VT_GOAL_NODE = 6,
    VT_MOVE_STATE = 8,
    VT_POSE = 10,
    VT_VEL = 12
  };
  const SLAMNAV::StatusNode *cur_node() const {
    return GetPointer<const SLAMNAV::StatusNode *>(VT_CUR_NODE);
  }
  const SLAMNAV::StatusNode *goal_node() const {
    return GetPointer<const SLAMNAV::StatusNode *>(VT_GOAL_NODE);
  }
  const SLAMNAV::StatusMoveState *move_state() const {
    return GetPointer<const SLAMNAV::StatusMoveState *>(VT_MOVE_STATE);
  }
  const SLAMNAV::StatusPose *pose() const {
    return GetStruct<const SLAMNAV::StatusPose *>(VT_POSE);
  }
  const SLAMNAV::StatusVel *vel() const {
    return GetStruct<const SLAMNAV::StatusVel *>(VT_VEL);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CUR_NODE) &&
           verifier.VerifyTable(cur_node()) &&
           VerifyOffset(verifier, VT_GOAL_NODE) &&
           verifier.VerifyTable(goal_node()) &&
           VerifyOffset(verifier, VT_MOVE_STATE) &&
           verifier.VerifyTable(move_state()) &&
           VerifyField<SLAMNAV::StatusPose>(verifier, VT_POSE, 4) &&
           VerifyField<SLAMNAV::StatusVel>(verifier, VT_VEL, 4) &&
           verifier.EndTable();
  }
};

struct Move_StatusBuilder {
  typedef Move_Status Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_cur_node(::flatbuffers::Offset<SLAMNAV::StatusNode> cur_node) {
    fbb_.AddOffset(Move_Status::VT_CUR_NODE, cur_node);
  }
  void add_goal_node(::flatbuffers::Offset<SLAMNAV::StatusNode> goal_node) {
    fbb_.AddOffset(Move_Status::VT_GOAL_NODE, goal_node);
  }
  void add_move_state(::flatbuffers::Offset<SLAMNAV::StatusMoveState> move_state) {
    fbb_.AddOffset(Move_Status::VT_MOVE_STATE, move_state);
  }
  void add_pose(const SLAMNAV::StatusPose *pose) {
    fbb_.AddStruct(Move_Status::VT_POSE, pose);
  }
  void add_vel(const SLAMNAV::StatusVel *vel) {
    fbb_.AddStruct(Move_Status::VT_VEL, vel);
  }
  explicit Move_StatusBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Move_Status> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Move_Status>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Move_Status> CreateMove_Status(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<SLAMNAV::StatusNode> cur_node = 0,
    ::flatbuffers::Offset<SLAMNAV::StatusNode> goal_node = 0,
    ::flatbuffers::Offset<SLAMNAV::StatusMoveState> move_state = 0,
    const SLAMNAV::StatusPose *pose = nullptr,
    const SLAMNAV::StatusVel *vel = nullptr) {
  Move_StatusBuilder builder_(_fbb);
  builder_.add_vel(vel);
  builder_.add_pose(pose);
  builder_.add_move_state(move_state);
  builder_.add_goal_node(goal_node);
  builder_.add_cur_node(cur_node);
  return builder_.Finish();
}

}  // namespace SLAMNAV

#endif  // FLATBUFFERS_GENERATED_SLAMNAVSTATUS_SLAMNAV_H_
