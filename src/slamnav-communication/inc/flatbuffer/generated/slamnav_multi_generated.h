// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SLAMNAVMULTI_SLAMNAV_H_
#define FLATBUFFERS_GENERATED_SLAMNAVMULTI_SLAMNAV_H_

#include "flatbuffers/flatbuffers.h"

namespace SLAMNAV {

struct Request_Path;
struct Request_PathBuilder;
struct Request_PathT;

struct Response_Path;
struct Response_PathBuilder;
struct Response_PathT;

struct Request_Vobs;
struct Request_VobsBuilder;
struct Request_VobsT;

struct Response_Vobs;
struct Response_VobsBuilder;
struct Response_VobsT;

struct Request_PathT : public flatbuffers::NativeTable {
  typedef Request_Path TableType;
  std::string id;
  std::vector<std::string> path;
  Request_PathT() {
  }
};

struct Request_Path FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Request_PathT NativeTableType;
  typedef Request_PathBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_PATH = 6
  };
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  flatbuffers::String *mutable_id() {
    return GetPointer<flatbuffers::String *>(VT_ID);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *path() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_PATH);
  }
  flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *mutable_path() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_PATH);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_PATH) &&
           verifier.VerifyVector(path()) &&
           verifier.VerifyVectorOfStrings(path()) &&
           verifier.EndTable();
  }
  Request_PathT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_PathT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Request_Path> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_PathT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_PathBuilder {
  typedef Request_Path Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(Request_Path::VT_ID, id);
  }
  void add_path(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> path) {
    fbb_.AddOffset(Request_Path::VT_PATH, path);
  }
  explicit Request_PathBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Request_Path> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Request_Path>(end);
    return o;
  }
};

inline flatbuffers::Offset<Request_Path> CreateRequest_Path(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> id = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> path = 0) {
  Request_PathBuilder builder_(_fbb);
  builder_.add_path(path);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<Request_Path> CreateRequest_PathDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *path = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto path__ = path ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*path) : 0;
  return SLAMNAV::CreateRequest_Path(
      _fbb,
      id__,
      path__);
}

flatbuffers::Offset<Request_Path> CreateRequest_Path(flatbuffers::FlatBufferBuilder &_fbb, const Request_PathT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Response_PathT : public flatbuffers::NativeTable {
  typedef Response_Path TableType;
  std::string id;
  std::vector<std::string> path;
  std::string result;
  std::string message;
  Response_PathT() {
  }
};

struct Response_Path FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Response_PathT NativeTableType;
  typedef Response_PathBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_PATH = 6,
    VT_RESULT = 8,
    VT_MESSAGE = 10
  };
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  flatbuffers::String *mutable_id() {
    return GetPointer<flatbuffers::String *>(VT_ID);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *path() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_PATH);
  }
  flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *mutable_path() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_PATH);
  }
  const flatbuffers::String *result() const {
    return GetPointer<const flatbuffers::String *>(VT_RESULT);
  }
  flatbuffers::String *mutable_result() {
    return GetPointer<flatbuffers::String *>(VT_RESULT);
  }
  const flatbuffers::String *message() const {
    return GetPointer<const flatbuffers::String *>(VT_MESSAGE);
  }
  flatbuffers::String *mutable_message() {
    return GetPointer<flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_PATH) &&
           verifier.VerifyVector(path()) &&
           verifier.VerifyVectorOfStrings(path()) &&
           VerifyOffset(verifier, VT_RESULT) &&
           verifier.VerifyString(result()) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
  Response_PathT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Response_PathT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Response_Path> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Response_PathT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Response_PathBuilder {
  typedef Response_Path Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(Response_Path::VT_ID, id);
  }
  void add_path(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> path) {
    fbb_.AddOffset(Response_Path::VT_PATH, path);
  }
  void add_result(flatbuffers::Offset<flatbuffers::String> result) {
    fbb_.AddOffset(Response_Path::VT_RESULT, result);
  }
  void add_message(flatbuffers::Offset<flatbuffers::String> message) {
    fbb_.AddOffset(Response_Path::VT_MESSAGE, message);
  }
  explicit Response_PathBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Response_Path> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Response_Path>(end);
    return o;
  }
};

inline flatbuffers::Offset<Response_Path> CreateResponse_Path(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> id = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> path = 0,
    flatbuffers::Offset<flatbuffers::String> result = 0,
    flatbuffers::Offset<flatbuffers::String> message = 0) {
  Response_PathBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_result(result);
  builder_.add_path(path);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<Response_Path> CreateResponse_PathDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *path = nullptr,
    const char *result = nullptr,
    const char *message = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto path__ = path ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*path) : 0;
  auto result__ = result ? _fbb.CreateString(result) : 0;
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return SLAMNAV::CreateResponse_Path(
      _fbb,
      id__,
      path__,
      result__,
      message__);
}

flatbuffers::Offset<Response_Path> CreateResponse_Path(flatbuffers::FlatBufferBuilder &_fbb, const Response_PathT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Request_VobsT : public flatbuffers::NativeTable {
  typedef Request_Vobs TableType;
  std::string id;
  std::vector<std::string> vobs_robots;
  std::vector<std::string> vobs_closures;
  std::string is_vobs_closures_change;
  Request_VobsT() {
  }
};

struct Request_Vobs FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Request_VobsT NativeTableType;
  typedef Request_VobsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_VOBS_ROBOTS = 6,
    VT_VOBS_CLOSURES = 8,
    VT_IS_VOBS_CLOSURES_CHANGE = 10
  };
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  flatbuffers::String *mutable_id() {
    return GetPointer<flatbuffers::String *>(VT_ID);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *vobs_robots() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_VOBS_ROBOTS);
  }
  flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *mutable_vobs_robots() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_VOBS_ROBOTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *vobs_closures() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_VOBS_CLOSURES);
  }
  flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *mutable_vobs_closures() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_VOBS_CLOSURES);
  }
  const flatbuffers::String *is_vobs_closures_change() const {
    return GetPointer<const flatbuffers::String *>(VT_IS_VOBS_CLOSURES_CHANGE);
  }
  flatbuffers::String *mutable_is_vobs_closures_change() {
    return GetPointer<flatbuffers::String *>(VT_IS_VOBS_CLOSURES_CHANGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_VOBS_ROBOTS) &&
           verifier.VerifyVector(vobs_robots()) &&
           verifier.VerifyVectorOfStrings(vobs_robots()) &&
           VerifyOffset(verifier, VT_VOBS_CLOSURES) &&
           verifier.VerifyVector(vobs_closures()) &&
           verifier.VerifyVectorOfStrings(vobs_closures()) &&
           VerifyOffset(verifier, VT_IS_VOBS_CLOSURES_CHANGE) &&
           verifier.VerifyString(is_vobs_closures_change()) &&
           verifier.EndTable();
  }
  Request_VobsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_VobsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Request_Vobs> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_VobsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_VobsBuilder {
  typedef Request_Vobs Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(Request_Vobs::VT_ID, id);
  }
  void add_vobs_robots(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> vobs_robots) {
    fbb_.AddOffset(Request_Vobs::VT_VOBS_ROBOTS, vobs_robots);
  }
  void add_vobs_closures(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> vobs_closures) {
    fbb_.AddOffset(Request_Vobs::VT_VOBS_CLOSURES, vobs_closures);
  }
  void add_is_vobs_closures_change(flatbuffers::Offset<flatbuffers::String> is_vobs_closures_change) {
    fbb_.AddOffset(Request_Vobs::VT_IS_VOBS_CLOSURES_CHANGE, is_vobs_closures_change);
  }
  explicit Request_VobsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Request_Vobs> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Request_Vobs>(end);
    return o;
  }
};

inline flatbuffers::Offset<Request_Vobs> CreateRequest_Vobs(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> id = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> vobs_robots = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> vobs_closures = 0,
    flatbuffers::Offset<flatbuffers::String> is_vobs_closures_change = 0) {
  Request_VobsBuilder builder_(_fbb);
  builder_.add_is_vobs_closures_change(is_vobs_closures_change);
  builder_.add_vobs_closures(vobs_closures);
  builder_.add_vobs_robots(vobs_robots);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<Request_Vobs> CreateRequest_VobsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *vobs_robots = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *vobs_closures = nullptr,
    const char *is_vobs_closures_change = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto vobs_robots__ = vobs_robots ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*vobs_robots) : 0;
  auto vobs_closures__ = vobs_closures ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*vobs_closures) : 0;
  auto is_vobs_closures_change__ = is_vobs_closures_change ? _fbb.CreateString(is_vobs_closures_change) : 0;
  return SLAMNAV::CreateRequest_Vobs(
      _fbb,
      id__,
      vobs_robots__,
      vobs_closures__,
      is_vobs_closures_change__);
}

flatbuffers::Offset<Request_Vobs> CreateRequest_Vobs(flatbuffers::FlatBufferBuilder &_fbb, const Request_VobsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Response_VobsT : public flatbuffers::NativeTable {
  typedef Response_Vobs TableType;
  std::string id;
  std::vector<std::string> vobs_robots;
  std::vector<std::string> vobs_closures;
  std::string is_vobs_closures_change;
  std::string result;
  std::string message;
  Response_VobsT() {
  }
};

struct Response_Vobs FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Response_VobsT NativeTableType;
  typedef Response_VobsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_VOBS_ROBOTS = 6,
    VT_VOBS_CLOSURES = 8,
    VT_IS_VOBS_CLOSURES_CHANGE = 10,
    VT_RESULT = 12,
    VT_MESSAGE = 14
  };
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  flatbuffers::String *mutable_id() {
    return GetPointer<flatbuffers::String *>(VT_ID);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *vobs_robots() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_VOBS_ROBOTS);
  }
  flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *mutable_vobs_robots() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_VOBS_ROBOTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *vobs_closures() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_VOBS_CLOSURES);
  }
  flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *mutable_vobs_closures() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_VOBS_CLOSURES);
  }
  const flatbuffers::String *is_vobs_closures_change() const {
    return GetPointer<const flatbuffers::String *>(VT_IS_VOBS_CLOSURES_CHANGE);
  }
  flatbuffers::String *mutable_is_vobs_closures_change() {
    return GetPointer<flatbuffers::String *>(VT_IS_VOBS_CLOSURES_CHANGE);
  }
  const flatbuffers::String *result() const {
    return GetPointer<const flatbuffers::String *>(VT_RESULT);
  }
  flatbuffers::String *mutable_result() {
    return GetPointer<flatbuffers::String *>(VT_RESULT);
  }
  const flatbuffers::String *message() const {
    return GetPointer<const flatbuffers::String *>(VT_MESSAGE);
  }
  flatbuffers::String *mutable_message() {
    return GetPointer<flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_VOBS_ROBOTS) &&
           verifier.VerifyVector(vobs_robots()) &&
           verifier.VerifyVectorOfStrings(vobs_robots()) &&
           VerifyOffset(verifier, VT_VOBS_CLOSURES) &&
           verifier.VerifyVector(vobs_closures()) &&
           verifier.VerifyVectorOfStrings(vobs_closures()) &&
           VerifyOffset(verifier, VT_IS_VOBS_CLOSURES_CHANGE) &&
           verifier.VerifyString(is_vobs_closures_change()) &&
           VerifyOffset(verifier, VT_RESULT) &&
           verifier.VerifyString(result()) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
  Response_VobsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Response_VobsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Response_Vobs> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Response_VobsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Response_VobsBuilder {
  typedef Response_Vobs Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(Response_Vobs::VT_ID, id);
  }
  void add_vobs_robots(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> vobs_robots) {
    fbb_.AddOffset(Response_Vobs::VT_VOBS_ROBOTS, vobs_robots);
  }
  void add_vobs_closures(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> vobs_closures) {
    fbb_.AddOffset(Response_Vobs::VT_VOBS_CLOSURES, vobs_closures);
  }
  void add_is_vobs_closures_change(flatbuffers::Offset<flatbuffers::String> is_vobs_closures_change) {
    fbb_.AddOffset(Response_Vobs::VT_IS_VOBS_CLOSURES_CHANGE, is_vobs_closures_change);
  }
  void add_result(flatbuffers::Offset<flatbuffers::String> result) {
    fbb_.AddOffset(Response_Vobs::VT_RESULT, result);
  }
  void add_message(flatbuffers::Offset<flatbuffers::String> message) {
    fbb_.AddOffset(Response_Vobs::VT_MESSAGE, message);
  }
  explicit Response_VobsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Response_Vobs> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Response_Vobs>(end);
    return o;
  }
};

inline flatbuffers::Offset<Response_Vobs> CreateResponse_Vobs(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> id = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> vobs_robots = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> vobs_closures = 0,
    flatbuffers::Offset<flatbuffers::String> is_vobs_closures_change = 0,
    flatbuffers::Offset<flatbuffers::String> result = 0,
    flatbuffers::Offset<flatbuffers::String> message = 0) {
  Response_VobsBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_result(result);
  builder_.add_is_vobs_closures_change(is_vobs_closures_change);
  builder_.add_vobs_closures(vobs_closures);
  builder_.add_vobs_robots(vobs_robots);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<Response_Vobs> CreateResponse_VobsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *vobs_robots = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *vobs_closures = nullptr,
    const char *is_vobs_closures_change = nullptr,
    const char *result = nullptr,
    const char *message = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto vobs_robots__ = vobs_robots ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*vobs_robots) : 0;
  auto vobs_closures__ = vobs_closures ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*vobs_closures) : 0;
  auto is_vobs_closures_change__ = is_vobs_closures_change ? _fbb.CreateString(is_vobs_closures_change) : 0;
  auto result__ = result ? _fbb.CreateString(result) : 0;
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return SLAMNAV::CreateResponse_Vobs(
      _fbb,
      id__,
      vobs_robots__,
      vobs_closures__,
      is_vobs_closures_change__,
      result__,
      message__);
}

flatbuffers::Offset<Response_Vobs> CreateResponse_Vobs(flatbuffers::FlatBufferBuilder &_fbb, const Response_VobsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline Request_PathT *Request_Path::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<SLAMNAV::Request_PathT> _o = std::unique_ptr<SLAMNAV::Request_PathT>(new Request_PathT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Request_Path::UnPackTo(Request_PathT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); }
  { auto _e = path(); if (_e) { _o->path.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->path[_i] = _e->Get(_i)->str(); } } }
}

inline flatbuffers::Offset<Request_Path> Request_Path::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_PathT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_Path(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Request_Path> CreateRequest_Path(flatbuffers::FlatBufferBuilder &_fbb, const Request_PathT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Request_PathT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id.empty() ? 0 : _fbb.CreateString(_o->id);
  auto _path = _o->path.size() ? _fbb.CreateVectorOfStrings(_o->path) : 0;
  return SLAMNAV::CreateRequest_Path(
      _fbb,
      _id,
      _path);
}

inline Response_PathT *Response_Path::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<SLAMNAV::Response_PathT> _o = std::unique_ptr<SLAMNAV::Response_PathT>(new Response_PathT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Response_Path::UnPackTo(Response_PathT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); }
  { auto _e = path(); if (_e) { _o->path.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->path[_i] = _e->Get(_i)->str(); } } }
  { auto _e = result(); if (_e) _o->result = _e->str(); }
  { auto _e = message(); if (_e) _o->message = _e->str(); }
}

inline flatbuffers::Offset<Response_Path> Response_Path::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Response_PathT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateResponse_Path(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Response_Path> CreateResponse_Path(flatbuffers::FlatBufferBuilder &_fbb, const Response_PathT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Response_PathT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id.empty() ? 0 : _fbb.CreateString(_o->id);
  auto _path = _o->path.size() ? _fbb.CreateVectorOfStrings(_o->path) : 0;
  auto _result = _o->result.empty() ? 0 : _fbb.CreateString(_o->result);
  auto _message = _o->message.empty() ? 0 : _fbb.CreateString(_o->message);
  return SLAMNAV::CreateResponse_Path(
      _fbb,
      _id,
      _path,
      _result,
      _message);
}

inline Request_VobsT *Request_Vobs::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<SLAMNAV::Request_VobsT> _o = std::unique_ptr<SLAMNAV::Request_VobsT>(new Request_VobsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Request_Vobs::UnPackTo(Request_VobsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); }
  { auto _e = vobs_robots(); if (_e) { _o->vobs_robots.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->vobs_robots[_i] = _e->Get(_i)->str(); } } }
  { auto _e = vobs_closures(); if (_e) { _o->vobs_closures.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->vobs_closures[_i] = _e->Get(_i)->str(); } } }
  { auto _e = is_vobs_closures_change(); if (_e) _o->is_vobs_closures_change = _e->str(); }
}

inline flatbuffers::Offset<Request_Vobs> Request_Vobs::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_VobsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_Vobs(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Request_Vobs> CreateRequest_Vobs(flatbuffers::FlatBufferBuilder &_fbb, const Request_VobsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Request_VobsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id.empty() ? 0 : _fbb.CreateString(_o->id);
  auto _vobs_robots = _o->vobs_robots.size() ? _fbb.CreateVectorOfStrings(_o->vobs_robots) : 0;
  auto _vobs_closures = _o->vobs_closures.size() ? _fbb.CreateVectorOfStrings(_o->vobs_closures) : 0;
  auto _is_vobs_closures_change = _o->is_vobs_closures_change.empty() ? 0 : _fbb.CreateString(_o->is_vobs_closures_change);
  return SLAMNAV::CreateRequest_Vobs(
      _fbb,
      _id,
      _vobs_robots,
      _vobs_closures,
      _is_vobs_closures_change);
}

inline Response_VobsT *Response_Vobs::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<SLAMNAV::Response_VobsT> _o = std::unique_ptr<SLAMNAV::Response_VobsT>(new Response_VobsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Response_Vobs::UnPackTo(Response_VobsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); }
  { auto _e = vobs_robots(); if (_e) { _o->vobs_robots.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->vobs_robots[_i] = _e->Get(_i)->str(); } } }
  { auto _e = vobs_closures(); if (_e) { _o->vobs_closures.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->vobs_closures[_i] = _e->Get(_i)->str(); } } }
  { auto _e = is_vobs_closures_change(); if (_e) _o->is_vobs_closures_change = _e->str(); }
  { auto _e = result(); if (_e) _o->result = _e->str(); }
  { auto _e = message(); if (_e) _o->message = _e->str(); }
}

inline flatbuffers::Offset<Response_Vobs> Response_Vobs::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Response_VobsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateResponse_Vobs(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Response_Vobs> CreateResponse_Vobs(flatbuffers::FlatBufferBuilder &_fbb, const Response_VobsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Response_VobsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id.empty() ? 0 : _fbb.CreateString(_o->id);
  auto _vobs_robots = _o->vobs_robots.size() ? _fbb.CreateVectorOfStrings(_o->vobs_robots) : 0;
  auto _vobs_closures = _o->vobs_closures.size() ? _fbb.CreateVectorOfStrings(_o->vobs_closures) : 0;
  auto _is_vobs_closures_change = _o->is_vobs_closures_change.empty() ? 0 : _fbb.CreateString(_o->is_vobs_closures_change);
  auto _result = _o->result.empty() ? 0 : _fbb.CreateString(_o->result);
  auto _message = _o->message.empty() ? 0 : _fbb.CreateString(_o->message);
  return SLAMNAV::CreateResponse_Vobs(
      _fbb,
      _id,
      _vobs_robots,
      _vobs_closures,
      _is_vobs_closures_change,
      _result,
      _message);
}

}  // namespace SLAMNAV

#endif  // FLATBUFFERS_GENERATED_SLAMNAVMULTI_SLAMNAV_H_
