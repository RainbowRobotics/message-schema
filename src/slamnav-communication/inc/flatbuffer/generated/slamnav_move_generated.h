// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SLAMNAVMOVE_SLAMNAV_H_
#define FLATBUFFERS_GENERATED_SLAMNAVMOVE_SLAMNAV_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 9 &&
              FLATBUFFERS_VERSION_REVISION == 23,
             "Non-compatible flatbuffers version included");

namespace SLAMNAV {

struct MovePose;

struct RequestMoveGoal;
struct RequestMoveGoalBuilder;

struct ResponseMoveGoal;
struct ResponseMoveGoalBuilder;

struct RequestMoveTarget;
struct RequestMoveTargetBuilder;

struct ResponseMoveTarget;
struct ResponseMoveTargetBuilder;

struct RequestMoveStop;
struct RequestMoveStopBuilder;

struct ResponseMoveStop;
struct ResponseMoveStopBuilder;

struct RequestMovePause;
struct RequestMovePauseBuilder;

struct ResponseMovePause;
struct ResponseMovePauseBuilder;

struct RequestMoveResume;
struct RequestMoveResumeBuilder;

struct ResponseMoveResume;
struct ResponseMoveResumeBuilder;

struct RequestMoveXLinear;
struct RequestMoveXLinearBuilder;

struct ResponseMoveXLinear;
struct ResponseMoveXLinearBuilder;

struct RequestMoveYLinear;
struct RequestMoveYLinearBuilder;

struct ResponseMoveYLinear;
struct ResponseMoveYLinearBuilder;

struct RequestMoveCircular;
struct RequestMoveCircularBuilder;

struct ResponseMoveCircular;
struct ResponseMoveCircularBuilder;

struct RequestMoveRotate;
struct RequestMoveRotateBuilder;

struct ResponseMoveRotate;
struct ResponseMoveRotateBuilder;

struct MoveJog;
struct MoveJogBuilder;

struct ResultMove;
struct ResultMoveBuilder;

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) MovePose FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;
  float rz_;

 public:
  MovePose()
      : x_(0),
        y_(0),
        z_(0),
        rz_(0) {
  }
  MovePose(float _x, float _y, float _z, float _rz)
      : x_(::flatbuffers::EndianScalar(_x)),
        y_(::flatbuffers::EndianScalar(_y)),
        z_(::flatbuffers::EndianScalar(_z)),
        rz_(::flatbuffers::EndianScalar(_rz)) {
  }
  float x() const {
    return ::flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return ::flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return ::flatbuffers::EndianScalar(z_);
  }
  float rz() const {
    return ::flatbuffers::EndianScalar(rz_);
  }
};
FLATBUFFERS_STRUCT_END(MovePose, 16);

struct RequestMoveGoal FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RequestMoveGoalBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_GOAL_ID = 6,
    VT_GOAL_NAME = 8,
    VT_METHOD = 10,
    VT_PRESET = 12
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  const ::flatbuffers::String *goal_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_GOAL_ID);
  }
  const ::flatbuffers::String *goal_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_GOAL_NAME);
  }
  const ::flatbuffers::String *method() const {
    return GetPointer<const ::flatbuffers::String *>(VT_METHOD);
  }
  int32_t preset() const {
    return GetField<int32_t>(VT_PRESET, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_GOAL_ID) &&
           verifier.VerifyString(goal_id()) &&
           VerifyOffset(verifier, VT_GOAL_NAME) &&
           verifier.VerifyString(goal_name()) &&
           VerifyOffset(verifier, VT_METHOD) &&
           verifier.VerifyString(method()) &&
           VerifyField<int32_t>(verifier, VT_PRESET, 4) &&
           verifier.EndTable();
  }
};

struct RequestMoveGoalBuilder {
  typedef RequestMoveGoal Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(RequestMoveGoal::VT_ID, id);
  }
  void add_goal_id(::flatbuffers::Offset<::flatbuffers::String> goal_id) {
    fbb_.AddOffset(RequestMoveGoal::VT_GOAL_ID, goal_id);
  }
  void add_goal_name(::flatbuffers::Offset<::flatbuffers::String> goal_name) {
    fbb_.AddOffset(RequestMoveGoal::VT_GOAL_NAME, goal_name);
  }
  void add_method(::flatbuffers::Offset<::flatbuffers::String> method) {
    fbb_.AddOffset(RequestMoveGoal::VT_METHOD, method);
  }
  void add_preset(int32_t preset) {
    fbb_.AddElement<int32_t>(RequestMoveGoal::VT_PRESET, preset, 0);
  }
  explicit RequestMoveGoalBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RequestMoveGoal> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RequestMoveGoal>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RequestMoveGoal> CreateRequestMoveGoal(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> goal_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> goal_name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> method = 0,
    int32_t preset = 0) {
  RequestMoveGoalBuilder builder_(_fbb);
  builder_.add_preset(preset);
  builder_.add_method(method);
  builder_.add_goal_name(goal_name);
  builder_.add_goal_id(goal_id);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RequestMoveGoal> CreateRequestMoveGoalDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *goal_id = nullptr,
    const char *goal_name = nullptr,
    const char *method = nullptr,
    int32_t preset = 0) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto goal_id__ = goal_id ? _fbb.CreateString(goal_id) : 0;
  auto goal_name__ = goal_name ? _fbb.CreateString(goal_name) : 0;
  auto method__ = method ? _fbb.CreateString(method) : 0;
  return SLAMNAV::CreateRequestMoveGoal(
      _fbb,
      id__,
      goal_id__,
      goal_name__,
      method__,
      preset);
}

struct ResponseMoveGoal FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ResponseMoveGoalBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_GOAL_ID = 6,
    VT_GOAL_NAME = 8,
    VT_METHOD = 10,
    VT_PRESET = 12,
    VT_RESULT = 14,
    VT_MESSAGE = 16
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  const ::flatbuffers::String *goal_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_GOAL_ID);
  }
  const ::flatbuffers::String *goal_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_GOAL_NAME);
  }
  const ::flatbuffers::String *method() const {
    return GetPointer<const ::flatbuffers::String *>(VT_METHOD);
  }
  int32_t preset() const {
    return GetField<int32_t>(VT_PRESET, 0);
  }
  const ::flatbuffers::String *result() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RESULT);
  }
  const ::flatbuffers::String *message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_GOAL_ID) &&
           verifier.VerifyString(goal_id()) &&
           VerifyOffset(verifier, VT_GOAL_NAME) &&
           verifier.VerifyString(goal_name()) &&
           VerifyOffset(verifier, VT_METHOD) &&
           verifier.VerifyString(method()) &&
           VerifyField<int32_t>(verifier, VT_PRESET, 4) &&
           VerifyOffset(verifier, VT_RESULT) &&
           verifier.VerifyString(result()) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
};

struct ResponseMoveGoalBuilder {
  typedef ResponseMoveGoal Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(ResponseMoveGoal::VT_ID, id);
  }
  void add_goal_id(::flatbuffers::Offset<::flatbuffers::String> goal_id) {
    fbb_.AddOffset(ResponseMoveGoal::VT_GOAL_ID, goal_id);
  }
  void add_goal_name(::flatbuffers::Offset<::flatbuffers::String> goal_name) {
    fbb_.AddOffset(ResponseMoveGoal::VT_GOAL_NAME, goal_name);
  }
  void add_method(::flatbuffers::Offset<::flatbuffers::String> method) {
    fbb_.AddOffset(ResponseMoveGoal::VT_METHOD, method);
  }
  void add_preset(int32_t preset) {
    fbb_.AddElement<int32_t>(ResponseMoveGoal::VT_PRESET, preset, 0);
  }
  void add_result(::flatbuffers::Offset<::flatbuffers::String> result) {
    fbb_.AddOffset(ResponseMoveGoal::VT_RESULT, result);
  }
  void add_message(::flatbuffers::Offset<::flatbuffers::String> message) {
    fbb_.AddOffset(ResponseMoveGoal::VT_MESSAGE, message);
  }
  explicit ResponseMoveGoalBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ResponseMoveGoal> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ResponseMoveGoal>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ResponseMoveGoal> CreateResponseMoveGoal(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> goal_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> goal_name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> method = 0,
    int32_t preset = 0,
    ::flatbuffers::Offset<::flatbuffers::String> result = 0,
    ::flatbuffers::Offset<::flatbuffers::String> message = 0) {
  ResponseMoveGoalBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_result(result);
  builder_.add_preset(preset);
  builder_.add_method(method);
  builder_.add_goal_name(goal_name);
  builder_.add_goal_id(goal_id);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ResponseMoveGoal> CreateResponseMoveGoalDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *goal_id = nullptr,
    const char *goal_name = nullptr,
    const char *method = nullptr,
    int32_t preset = 0,
    const char *result = nullptr,
    const char *message = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto goal_id__ = goal_id ? _fbb.CreateString(goal_id) : 0;
  auto goal_name__ = goal_name ? _fbb.CreateString(goal_name) : 0;
  auto method__ = method ? _fbb.CreateString(method) : 0;
  auto result__ = result ? _fbb.CreateString(result) : 0;
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return SLAMNAV::CreateResponseMoveGoal(
      _fbb,
      id__,
      goal_id__,
      goal_name__,
      method__,
      preset,
      result__,
      message__);
}

struct RequestMoveTarget FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RequestMoveTargetBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_GOAL_POSE = 6,
    VT_METHOD = 8,
    VT_PRESET = 10
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  const SLAMNAV::MovePose *goal_pose() const {
    return GetStruct<const SLAMNAV::MovePose *>(VT_GOAL_POSE);
  }
  const ::flatbuffers::String *method() const {
    return GetPointer<const ::flatbuffers::String *>(VT_METHOD);
  }
  int32_t preset() const {
    return GetField<int32_t>(VT_PRESET, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyField<SLAMNAV::MovePose>(verifier, VT_GOAL_POSE, 4) &&
           VerifyOffset(verifier, VT_METHOD) &&
           verifier.VerifyString(method()) &&
           VerifyField<int32_t>(verifier, VT_PRESET, 4) &&
           verifier.EndTable();
  }
};

struct RequestMoveTargetBuilder {
  typedef RequestMoveTarget Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(RequestMoveTarget::VT_ID, id);
  }
  void add_goal_pose(const SLAMNAV::MovePose *goal_pose) {
    fbb_.AddStruct(RequestMoveTarget::VT_GOAL_POSE, goal_pose);
  }
  void add_method(::flatbuffers::Offset<::flatbuffers::String> method) {
    fbb_.AddOffset(RequestMoveTarget::VT_METHOD, method);
  }
  void add_preset(int32_t preset) {
    fbb_.AddElement<int32_t>(RequestMoveTarget::VT_PRESET, preset, 0);
  }
  explicit RequestMoveTargetBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RequestMoveTarget> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RequestMoveTarget>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RequestMoveTarget> CreateRequestMoveTarget(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    const SLAMNAV::MovePose *goal_pose = nullptr,
    ::flatbuffers::Offset<::flatbuffers::String> method = 0,
    int32_t preset = 0) {
  RequestMoveTargetBuilder builder_(_fbb);
  builder_.add_preset(preset);
  builder_.add_method(method);
  builder_.add_goal_pose(goal_pose);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RequestMoveTarget> CreateRequestMoveTargetDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const SLAMNAV::MovePose *goal_pose = nullptr,
    const char *method = nullptr,
    int32_t preset = 0) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto method__ = method ? _fbb.CreateString(method) : 0;
  return SLAMNAV::CreateRequestMoveTarget(
      _fbb,
      id__,
      goal_pose,
      method__,
      preset);
}

struct ResponseMoveTarget FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ResponseMoveTargetBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_METHOD = 6,
    VT_GOAL_POSE = 8,
    VT_PRESET = 10,
    VT_RESULT = 12,
    VT_MESSAGE = 14
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  const ::flatbuffers::String *method() const {
    return GetPointer<const ::flatbuffers::String *>(VT_METHOD);
  }
  const SLAMNAV::MovePose *goal_pose() const {
    return GetStruct<const SLAMNAV::MovePose *>(VT_GOAL_POSE);
  }
  int32_t preset() const {
    return GetField<int32_t>(VT_PRESET, 0);
  }
  const ::flatbuffers::String *result() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RESULT);
  }
  const ::flatbuffers::String *message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_METHOD) &&
           verifier.VerifyString(method()) &&
           VerifyField<SLAMNAV::MovePose>(verifier, VT_GOAL_POSE, 4) &&
           VerifyField<int32_t>(verifier, VT_PRESET, 4) &&
           VerifyOffset(verifier, VT_RESULT) &&
           verifier.VerifyString(result()) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
};

struct ResponseMoveTargetBuilder {
  typedef ResponseMoveTarget Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(ResponseMoveTarget::VT_ID, id);
  }
  void add_method(::flatbuffers::Offset<::flatbuffers::String> method) {
    fbb_.AddOffset(ResponseMoveTarget::VT_METHOD, method);
  }
  void add_goal_pose(const SLAMNAV::MovePose *goal_pose) {
    fbb_.AddStruct(ResponseMoveTarget::VT_GOAL_POSE, goal_pose);
  }
  void add_preset(int32_t preset) {
    fbb_.AddElement<int32_t>(ResponseMoveTarget::VT_PRESET, preset, 0);
  }
  void add_result(::flatbuffers::Offset<::flatbuffers::String> result) {
    fbb_.AddOffset(ResponseMoveTarget::VT_RESULT, result);
  }
  void add_message(::flatbuffers::Offset<::flatbuffers::String> message) {
    fbb_.AddOffset(ResponseMoveTarget::VT_MESSAGE, message);
  }
  explicit ResponseMoveTargetBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ResponseMoveTarget> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ResponseMoveTarget>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ResponseMoveTarget> CreateResponseMoveTarget(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> method = 0,
    const SLAMNAV::MovePose *goal_pose = nullptr,
    int32_t preset = 0,
    ::flatbuffers::Offset<::flatbuffers::String> result = 0,
    ::flatbuffers::Offset<::flatbuffers::String> message = 0) {
  ResponseMoveTargetBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_result(result);
  builder_.add_preset(preset);
  builder_.add_goal_pose(goal_pose);
  builder_.add_method(method);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ResponseMoveTarget> CreateResponseMoveTargetDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *method = nullptr,
    const SLAMNAV::MovePose *goal_pose = nullptr,
    int32_t preset = 0,
    const char *result = nullptr,
    const char *message = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto method__ = method ? _fbb.CreateString(method) : 0;
  auto result__ = result ? _fbb.CreateString(result) : 0;
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return SLAMNAV::CreateResponseMoveTarget(
      _fbb,
      id__,
      method__,
      goal_pose,
      preset,
      result__,
      message__);
}

struct RequestMoveStop FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RequestMoveStopBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           verifier.EndTable();
  }
};

struct RequestMoveStopBuilder {
  typedef RequestMoveStop Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(RequestMoveStop::VT_ID, id);
  }
  explicit RequestMoveStopBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RequestMoveStop> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RequestMoveStop>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RequestMoveStop> CreateRequestMoveStop(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0) {
  RequestMoveStopBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RequestMoveStop> CreateRequestMoveStopDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  return SLAMNAV::CreateRequestMoveStop(
      _fbb,
      id__);
}

struct ResponseMoveStop FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ResponseMoveStopBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_RESULT = 6,
    VT_MESSAGE = 8
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  const ::flatbuffers::String *result() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RESULT);
  }
  const ::flatbuffers::String *message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_RESULT) &&
           verifier.VerifyString(result()) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
};

struct ResponseMoveStopBuilder {
  typedef ResponseMoveStop Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(ResponseMoveStop::VT_ID, id);
  }
  void add_result(::flatbuffers::Offset<::flatbuffers::String> result) {
    fbb_.AddOffset(ResponseMoveStop::VT_RESULT, result);
  }
  void add_message(::flatbuffers::Offset<::flatbuffers::String> message) {
    fbb_.AddOffset(ResponseMoveStop::VT_MESSAGE, message);
  }
  explicit ResponseMoveStopBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ResponseMoveStop> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ResponseMoveStop>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ResponseMoveStop> CreateResponseMoveStop(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> result = 0,
    ::flatbuffers::Offset<::flatbuffers::String> message = 0) {
  ResponseMoveStopBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_result(result);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ResponseMoveStop> CreateResponseMoveStopDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *result = nullptr,
    const char *message = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto result__ = result ? _fbb.CreateString(result) : 0;
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return SLAMNAV::CreateResponseMoveStop(
      _fbb,
      id__,
      result__,
      message__);
}

struct RequestMovePause FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RequestMovePauseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           verifier.EndTable();
  }
};

struct RequestMovePauseBuilder {
  typedef RequestMovePause Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(RequestMovePause::VT_ID, id);
  }
  explicit RequestMovePauseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RequestMovePause> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RequestMovePause>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RequestMovePause> CreateRequestMovePause(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0) {
  RequestMovePauseBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RequestMovePause> CreateRequestMovePauseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  return SLAMNAV::CreateRequestMovePause(
      _fbb,
      id__);
}

struct ResponseMovePause FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ResponseMovePauseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_RESULT = 6,
    VT_MESSAGE = 8
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  const ::flatbuffers::String *result() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RESULT);
  }
  const ::flatbuffers::String *message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_RESULT) &&
           verifier.VerifyString(result()) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
};

struct ResponseMovePauseBuilder {
  typedef ResponseMovePause Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(ResponseMovePause::VT_ID, id);
  }
  void add_result(::flatbuffers::Offset<::flatbuffers::String> result) {
    fbb_.AddOffset(ResponseMovePause::VT_RESULT, result);
  }
  void add_message(::flatbuffers::Offset<::flatbuffers::String> message) {
    fbb_.AddOffset(ResponseMovePause::VT_MESSAGE, message);
  }
  explicit ResponseMovePauseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ResponseMovePause> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ResponseMovePause>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ResponseMovePause> CreateResponseMovePause(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> result = 0,
    ::flatbuffers::Offset<::flatbuffers::String> message = 0) {
  ResponseMovePauseBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_result(result);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ResponseMovePause> CreateResponseMovePauseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *result = nullptr,
    const char *message = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto result__ = result ? _fbb.CreateString(result) : 0;
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return SLAMNAV::CreateResponseMovePause(
      _fbb,
      id__,
      result__,
      message__);
}

struct RequestMoveResume FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RequestMoveResumeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           verifier.EndTable();
  }
};

struct RequestMoveResumeBuilder {
  typedef RequestMoveResume Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(RequestMoveResume::VT_ID, id);
  }
  explicit RequestMoveResumeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RequestMoveResume> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RequestMoveResume>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RequestMoveResume> CreateRequestMoveResume(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0) {
  RequestMoveResumeBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RequestMoveResume> CreateRequestMoveResumeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  return SLAMNAV::CreateRequestMoveResume(
      _fbb,
      id__);
}

struct ResponseMoveResume FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ResponseMoveResumeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_RESULT = 6,
    VT_MESSAGE = 8
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  const ::flatbuffers::String *result() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RESULT);
  }
  const ::flatbuffers::String *message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_RESULT) &&
           verifier.VerifyString(result()) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
};

struct ResponseMoveResumeBuilder {
  typedef ResponseMoveResume Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(ResponseMoveResume::VT_ID, id);
  }
  void add_result(::flatbuffers::Offset<::flatbuffers::String> result) {
    fbb_.AddOffset(ResponseMoveResume::VT_RESULT, result);
  }
  void add_message(::flatbuffers::Offset<::flatbuffers::String> message) {
    fbb_.AddOffset(ResponseMoveResume::VT_MESSAGE, message);
  }
  explicit ResponseMoveResumeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ResponseMoveResume> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ResponseMoveResume>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ResponseMoveResume> CreateResponseMoveResume(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> result = 0,
    ::flatbuffers::Offset<::flatbuffers::String> message = 0) {
  ResponseMoveResumeBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_result(result);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ResponseMoveResume> CreateResponseMoveResumeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *result = nullptr,
    const char *message = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto result__ = result ? _fbb.CreateString(result) : 0;
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return SLAMNAV::CreateResponseMoveResume(
      _fbb,
      id__,
      result__,
      message__);
}

struct RequestMoveXLinear FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RequestMoveXLinearBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_TARGET = 6,
    VT_SPEED = 8
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  float target() const {
    return GetField<float>(VT_TARGET, 0.0f);
  }
  float speed() const {
    return GetField<float>(VT_SPEED, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyField<float>(verifier, VT_TARGET, 4) &&
           VerifyField<float>(verifier, VT_SPEED, 4) &&
           verifier.EndTable();
  }
};

struct RequestMoveXLinearBuilder {
  typedef RequestMoveXLinear Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(RequestMoveXLinear::VT_ID, id);
  }
  void add_target(float target) {
    fbb_.AddElement<float>(RequestMoveXLinear::VT_TARGET, target, 0.0f);
  }
  void add_speed(float speed) {
    fbb_.AddElement<float>(RequestMoveXLinear::VT_SPEED, speed, 0.0f);
  }
  explicit RequestMoveXLinearBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RequestMoveXLinear> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RequestMoveXLinear>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RequestMoveXLinear> CreateRequestMoveXLinear(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    float target = 0.0f,
    float speed = 0.0f) {
  RequestMoveXLinearBuilder builder_(_fbb);
  builder_.add_speed(speed);
  builder_.add_target(target);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RequestMoveXLinear> CreateRequestMoveXLinearDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    float target = 0.0f,
    float speed = 0.0f) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  return SLAMNAV::CreateRequestMoveXLinear(
      _fbb,
      id__,
      target,
      speed);
}

struct ResponseMoveXLinear FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ResponseMoveXLinearBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_TARGET = 6,
    VT_SPEED = 8,
    VT_RESULT = 10,
    VT_MESSAGE = 12
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  float target() const {
    return GetField<float>(VT_TARGET, 0.0f);
  }
  float speed() const {
    return GetField<float>(VT_SPEED, 0.0f);
  }
  const ::flatbuffers::String *result() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RESULT);
  }
  const ::flatbuffers::String *message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyField<float>(verifier, VT_TARGET, 4) &&
           VerifyField<float>(verifier, VT_SPEED, 4) &&
           VerifyOffset(verifier, VT_RESULT) &&
           verifier.VerifyString(result()) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
};

struct ResponseMoveXLinearBuilder {
  typedef ResponseMoveXLinear Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(ResponseMoveXLinear::VT_ID, id);
  }
  void add_target(float target) {
    fbb_.AddElement<float>(ResponseMoveXLinear::VT_TARGET, target, 0.0f);
  }
  void add_speed(float speed) {
    fbb_.AddElement<float>(ResponseMoveXLinear::VT_SPEED, speed, 0.0f);
  }
  void add_result(::flatbuffers::Offset<::flatbuffers::String> result) {
    fbb_.AddOffset(ResponseMoveXLinear::VT_RESULT, result);
  }
  void add_message(::flatbuffers::Offset<::flatbuffers::String> message) {
    fbb_.AddOffset(ResponseMoveXLinear::VT_MESSAGE, message);
  }
  explicit ResponseMoveXLinearBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ResponseMoveXLinear> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ResponseMoveXLinear>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ResponseMoveXLinear> CreateResponseMoveXLinear(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    float target = 0.0f,
    float speed = 0.0f,
    ::flatbuffers::Offset<::flatbuffers::String> result = 0,
    ::flatbuffers::Offset<::flatbuffers::String> message = 0) {
  ResponseMoveXLinearBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_result(result);
  builder_.add_speed(speed);
  builder_.add_target(target);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ResponseMoveXLinear> CreateResponseMoveXLinearDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    float target = 0.0f,
    float speed = 0.0f,
    const char *result = nullptr,
    const char *message = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto result__ = result ? _fbb.CreateString(result) : 0;
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return SLAMNAV::CreateResponseMoveXLinear(
      _fbb,
      id__,
      target,
      speed,
      result__,
      message__);
}

struct RequestMoveYLinear FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RequestMoveYLinearBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_TARGET = 6,
    VT_SPEED = 8
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  float target() const {
    return GetField<float>(VT_TARGET, 0.0f);
  }
  float speed() const {
    return GetField<float>(VT_SPEED, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyField<float>(verifier, VT_TARGET, 4) &&
           VerifyField<float>(verifier, VT_SPEED, 4) &&
           verifier.EndTable();
  }
};

struct RequestMoveYLinearBuilder {
  typedef RequestMoveYLinear Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(RequestMoveYLinear::VT_ID, id);
  }
  void add_target(float target) {
    fbb_.AddElement<float>(RequestMoveYLinear::VT_TARGET, target, 0.0f);
  }
  void add_speed(float speed) {
    fbb_.AddElement<float>(RequestMoveYLinear::VT_SPEED, speed, 0.0f);
  }
  explicit RequestMoveYLinearBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RequestMoveYLinear> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RequestMoveYLinear>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RequestMoveYLinear> CreateRequestMoveYLinear(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    float target = 0.0f,
    float speed = 0.0f) {
  RequestMoveYLinearBuilder builder_(_fbb);
  builder_.add_speed(speed);
  builder_.add_target(target);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RequestMoveYLinear> CreateRequestMoveYLinearDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    float target = 0.0f,
    float speed = 0.0f) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  return SLAMNAV::CreateRequestMoveYLinear(
      _fbb,
      id__,
      target,
      speed);
}

struct ResponseMoveYLinear FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ResponseMoveYLinearBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_TARGET = 6,
    VT_SPEED = 8,
    VT_RESULT = 10,
    VT_MESSAGE = 12
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  float target() const {
    return GetField<float>(VT_TARGET, 0.0f);
  }
  float speed() const {
    return GetField<float>(VT_SPEED, 0.0f);
  }
  const ::flatbuffers::String *result() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RESULT);
  }
  const ::flatbuffers::String *message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyField<float>(verifier, VT_TARGET, 4) &&
           VerifyField<float>(verifier, VT_SPEED, 4) &&
           VerifyOffset(verifier, VT_RESULT) &&
           verifier.VerifyString(result()) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
};

struct ResponseMoveYLinearBuilder {
  typedef ResponseMoveYLinear Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(ResponseMoveYLinear::VT_ID, id);
  }
  void add_target(float target) {
    fbb_.AddElement<float>(ResponseMoveYLinear::VT_TARGET, target, 0.0f);
  }
  void add_speed(float speed) {
    fbb_.AddElement<float>(ResponseMoveYLinear::VT_SPEED, speed, 0.0f);
  }
  void add_result(::flatbuffers::Offset<::flatbuffers::String> result) {
    fbb_.AddOffset(ResponseMoveYLinear::VT_RESULT, result);
  }
  void add_message(::flatbuffers::Offset<::flatbuffers::String> message) {
    fbb_.AddOffset(ResponseMoveYLinear::VT_MESSAGE, message);
  }
  explicit ResponseMoveYLinearBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ResponseMoveYLinear> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ResponseMoveYLinear>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ResponseMoveYLinear> CreateResponseMoveYLinear(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    float target = 0.0f,
    float speed = 0.0f,
    ::flatbuffers::Offset<::flatbuffers::String> result = 0,
    ::flatbuffers::Offset<::flatbuffers::String> message = 0) {
  ResponseMoveYLinearBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_result(result);
  builder_.add_speed(speed);
  builder_.add_target(target);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ResponseMoveYLinear> CreateResponseMoveYLinearDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    float target = 0.0f,
    float speed = 0.0f,
    const char *result = nullptr,
    const char *message = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto result__ = result ? _fbb.CreateString(result) : 0;
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return SLAMNAV::CreateResponseMoveYLinear(
      _fbb,
      id__,
      target,
      speed,
      result__,
      message__);
}

struct RequestMoveCircular FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RequestMoveCircularBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_TARGET = 6,
    VT_SPEED = 8,
    VT_DIRECTION = 10
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  float target() const {
    return GetField<float>(VT_TARGET, 0.0f);
  }
  float speed() const {
    return GetField<float>(VT_SPEED, 0.0f);
  }
  const ::flatbuffers::String *direction() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DIRECTION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyField<float>(verifier, VT_TARGET, 4) &&
           VerifyField<float>(verifier, VT_SPEED, 4) &&
           VerifyOffset(verifier, VT_DIRECTION) &&
           verifier.VerifyString(direction()) &&
           verifier.EndTable();
  }
};

struct RequestMoveCircularBuilder {
  typedef RequestMoveCircular Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(RequestMoveCircular::VT_ID, id);
  }
  void add_target(float target) {
    fbb_.AddElement<float>(RequestMoveCircular::VT_TARGET, target, 0.0f);
  }
  void add_speed(float speed) {
    fbb_.AddElement<float>(RequestMoveCircular::VT_SPEED, speed, 0.0f);
  }
  void add_direction(::flatbuffers::Offset<::flatbuffers::String> direction) {
    fbb_.AddOffset(RequestMoveCircular::VT_DIRECTION, direction);
  }
  explicit RequestMoveCircularBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RequestMoveCircular> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RequestMoveCircular>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RequestMoveCircular> CreateRequestMoveCircular(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    float target = 0.0f,
    float speed = 0.0f,
    ::flatbuffers::Offset<::flatbuffers::String> direction = 0) {
  RequestMoveCircularBuilder builder_(_fbb);
  builder_.add_direction(direction);
  builder_.add_speed(speed);
  builder_.add_target(target);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RequestMoveCircular> CreateRequestMoveCircularDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    float target = 0.0f,
    float speed = 0.0f,
    const char *direction = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto direction__ = direction ? _fbb.CreateString(direction) : 0;
  return SLAMNAV::CreateRequestMoveCircular(
      _fbb,
      id__,
      target,
      speed,
      direction__);
}

struct ResponseMoveCircular FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ResponseMoveCircularBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_TARGET = 6,
    VT_SPEED = 8,
    VT_DIRECTION = 10,
    VT_RESULT = 12,
    VT_MESSAGE = 14
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  float target() const {
    return GetField<float>(VT_TARGET, 0.0f);
  }
  float speed() const {
    return GetField<float>(VT_SPEED, 0.0f);
  }
  const ::flatbuffers::String *direction() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DIRECTION);
  }
  const ::flatbuffers::String *result() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RESULT);
  }
  const ::flatbuffers::String *message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyField<float>(verifier, VT_TARGET, 4) &&
           VerifyField<float>(verifier, VT_SPEED, 4) &&
           VerifyOffset(verifier, VT_DIRECTION) &&
           verifier.VerifyString(direction()) &&
           VerifyOffset(verifier, VT_RESULT) &&
           verifier.VerifyString(result()) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
};

struct ResponseMoveCircularBuilder {
  typedef ResponseMoveCircular Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(ResponseMoveCircular::VT_ID, id);
  }
  void add_target(float target) {
    fbb_.AddElement<float>(ResponseMoveCircular::VT_TARGET, target, 0.0f);
  }
  void add_speed(float speed) {
    fbb_.AddElement<float>(ResponseMoveCircular::VT_SPEED, speed, 0.0f);
  }
  void add_direction(::flatbuffers::Offset<::flatbuffers::String> direction) {
    fbb_.AddOffset(ResponseMoveCircular::VT_DIRECTION, direction);
  }
  void add_result(::flatbuffers::Offset<::flatbuffers::String> result) {
    fbb_.AddOffset(ResponseMoveCircular::VT_RESULT, result);
  }
  void add_message(::flatbuffers::Offset<::flatbuffers::String> message) {
    fbb_.AddOffset(ResponseMoveCircular::VT_MESSAGE, message);
  }
  explicit ResponseMoveCircularBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ResponseMoveCircular> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ResponseMoveCircular>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ResponseMoveCircular> CreateResponseMoveCircular(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    float target = 0.0f,
    float speed = 0.0f,
    ::flatbuffers::Offset<::flatbuffers::String> direction = 0,
    ::flatbuffers::Offset<::flatbuffers::String> result = 0,
    ::flatbuffers::Offset<::flatbuffers::String> message = 0) {
  ResponseMoveCircularBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_result(result);
  builder_.add_direction(direction);
  builder_.add_speed(speed);
  builder_.add_target(target);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ResponseMoveCircular> CreateResponseMoveCircularDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    float target = 0.0f,
    float speed = 0.0f,
    const char *direction = nullptr,
    const char *result = nullptr,
    const char *message = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto direction__ = direction ? _fbb.CreateString(direction) : 0;
  auto result__ = result ? _fbb.CreateString(result) : 0;
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return SLAMNAV::CreateResponseMoveCircular(
      _fbb,
      id__,
      target,
      speed,
      direction__,
      result__,
      message__);
}

struct RequestMoveRotate FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RequestMoveRotateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_TARGET = 6,
    VT_SPEED = 8
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  float target() const {
    return GetField<float>(VT_TARGET, 0.0f);
  }
  float speed() const {
    return GetField<float>(VT_SPEED, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyField<float>(verifier, VT_TARGET, 4) &&
           VerifyField<float>(verifier, VT_SPEED, 4) &&
           verifier.EndTable();
  }
};

struct RequestMoveRotateBuilder {
  typedef RequestMoveRotate Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(RequestMoveRotate::VT_ID, id);
  }
  void add_target(float target) {
    fbb_.AddElement<float>(RequestMoveRotate::VT_TARGET, target, 0.0f);
  }
  void add_speed(float speed) {
    fbb_.AddElement<float>(RequestMoveRotate::VT_SPEED, speed, 0.0f);
  }
  explicit RequestMoveRotateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RequestMoveRotate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RequestMoveRotate>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RequestMoveRotate> CreateRequestMoveRotate(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    float target = 0.0f,
    float speed = 0.0f) {
  RequestMoveRotateBuilder builder_(_fbb);
  builder_.add_speed(speed);
  builder_.add_target(target);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RequestMoveRotate> CreateRequestMoveRotateDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    float target = 0.0f,
    float speed = 0.0f) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  return SLAMNAV::CreateRequestMoveRotate(
      _fbb,
      id__,
      target,
      speed);
}

struct ResponseMoveRotate FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ResponseMoveRotateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_TARGET = 6,
    VT_SPEED = 8,
    VT_RESULT = 10,
    VT_MESSAGE = 12
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  float target() const {
    return GetField<float>(VT_TARGET, 0.0f);
  }
  float speed() const {
    return GetField<float>(VT_SPEED, 0.0f);
  }
  const ::flatbuffers::String *result() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RESULT);
  }
  const ::flatbuffers::String *message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyField<float>(verifier, VT_TARGET, 4) &&
           VerifyField<float>(verifier, VT_SPEED, 4) &&
           VerifyOffset(verifier, VT_RESULT) &&
           verifier.VerifyString(result()) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
};

struct ResponseMoveRotateBuilder {
  typedef ResponseMoveRotate Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(ResponseMoveRotate::VT_ID, id);
  }
  void add_target(float target) {
    fbb_.AddElement<float>(ResponseMoveRotate::VT_TARGET, target, 0.0f);
  }
  void add_speed(float speed) {
    fbb_.AddElement<float>(ResponseMoveRotate::VT_SPEED, speed, 0.0f);
  }
  void add_result(::flatbuffers::Offset<::flatbuffers::String> result) {
    fbb_.AddOffset(ResponseMoveRotate::VT_RESULT, result);
  }
  void add_message(::flatbuffers::Offset<::flatbuffers::String> message) {
    fbb_.AddOffset(ResponseMoveRotate::VT_MESSAGE, message);
  }
  explicit ResponseMoveRotateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ResponseMoveRotate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ResponseMoveRotate>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ResponseMoveRotate> CreateResponseMoveRotate(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    float target = 0.0f,
    float speed = 0.0f,
    ::flatbuffers::Offset<::flatbuffers::String> result = 0,
    ::flatbuffers::Offset<::flatbuffers::String> message = 0) {
  ResponseMoveRotateBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_result(result);
  builder_.add_speed(speed);
  builder_.add_target(target);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ResponseMoveRotate> CreateResponseMoveRotateDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    float target = 0.0f,
    float speed = 0.0f,
    const char *result = nullptr,
    const char *message = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto result__ = result ? _fbb.CreateString(result) : 0;
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return SLAMNAV::CreateResponseMoveRotate(
      _fbb,
      id__,
      target,
      speed,
      result__,
      message__);
}

struct MoveJog FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MoveJogBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VX = 4,
    VT_VY = 6,
    VT_WZ = 8
  };
  float vx() const {
    return GetField<float>(VT_VX, 0.0f);
  }
  float vy() const {
    return GetField<float>(VT_VY, 0.0f);
  }
  float wz() const {
    return GetField<float>(VT_WZ, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_VX, 4) &&
           VerifyField<float>(verifier, VT_VY, 4) &&
           VerifyField<float>(verifier, VT_WZ, 4) &&
           verifier.EndTable();
  }
};

struct MoveJogBuilder {
  typedef MoveJog Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_vx(float vx) {
    fbb_.AddElement<float>(MoveJog::VT_VX, vx, 0.0f);
  }
  void add_vy(float vy) {
    fbb_.AddElement<float>(MoveJog::VT_VY, vy, 0.0f);
  }
  void add_wz(float wz) {
    fbb_.AddElement<float>(MoveJog::VT_WZ, wz, 0.0f);
  }
  explicit MoveJogBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MoveJog> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MoveJog>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MoveJog> CreateMoveJog(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float vx = 0.0f,
    float vy = 0.0f,
    float wz = 0.0f) {
  MoveJogBuilder builder_(_fbb);
  builder_.add_wz(wz);
  builder_.add_vy(vy);
  builder_.add_vx(vx);
  return builder_.Finish();
}

struct ResultMove FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ResultMoveBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_GOAL_ID = 6,
    VT_GOAL_NAME = 8,
    VT_METHOD = 10,
    VT_PRESET = 12,
    VT_GOAL_POSE = 14,
    VT_TARGET = 16,
    VT_SPEED = 18,
    VT_DIRECTION = 20,
    VT_RESULT = 22,
    VT_MESSAGE = 24
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  const ::flatbuffers::String *goal_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_GOAL_ID);
  }
  const ::flatbuffers::String *goal_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_GOAL_NAME);
  }
  const ::flatbuffers::String *method() const {
    return GetPointer<const ::flatbuffers::String *>(VT_METHOD);
  }
  int32_t preset() const {
    return GetField<int32_t>(VT_PRESET, 0);
  }
  const SLAMNAV::MovePose *goal_pose() const {
    return GetStruct<const SLAMNAV::MovePose *>(VT_GOAL_POSE);
  }
  float target() const {
    return GetField<float>(VT_TARGET, 0.0f);
  }
  float speed() const {
    return GetField<float>(VT_SPEED, 0.0f);
  }
  const ::flatbuffers::String *direction() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DIRECTION);
  }
  const ::flatbuffers::String *result() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RESULT);
  }
  const ::flatbuffers::String *message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_GOAL_ID) &&
           verifier.VerifyString(goal_id()) &&
           VerifyOffset(verifier, VT_GOAL_NAME) &&
           verifier.VerifyString(goal_name()) &&
           VerifyOffset(verifier, VT_METHOD) &&
           verifier.VerifyString(method()) &&
           VerifyField<int32_t>(verifier, VT_PRESET, 4) &&
           VerifyField<SLAMNAV::MovePose>(verifier, VT_GOAL_POSE, 4) &&
           VerifyField<float>(verifier, VT_TARGET, 4) &&
           VerifyField<float>(verifier, VT_SPEED, 4) &&
           VerifyOffset(verifier, VT_DIRECTION) &&
           verifier.VerifyString(direction()) &&
           VerifyOffset(verifier, VT_RESULT) &&
           verifier.VerifyString(result()) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
};

struct ResultMoveBuilder {
  typedef ResultMove Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(ResultMove::VT_ID, id);
  }
  void add_goal_id(::flatbuffers::Offset<::flatbuffers::String> goal_id) {
    fbb_.AddOffset(ResultMove::VT_GOAL_ID, goal_id);
  }
  void add_goal_name(::flatbuffers::Offset<::flatbuffers::String> goal_name) {
    fbb_.AddOffset(ResultMove::VT_GOAL_NAME, goal_name);
  }
  void add_method(::flatbuffers::Offset<::flatbuffers::String> method) {
    fbb_.AddOffset(ResultMove::VT_METHOD, method);
  }
  void add_preset(int32_t preset) {
    fbb_.AddElement<int32_t>(ResultMove::VT_PRESET, preset, 0);
  }
  void add_goal_pose(const SLAMNAV::MovePose *goal_pose) {
    fbb_.AddStruct(ResultMove::VT_GOAL_POSE, goal_pose);
  }
  void add_target(float target) {
    fbb_.AddElement<float>(ResultMove::VT_TARGET, target, 0.0f);
  }
  void add_speed(float speed) {
    fbb_.AddElement<float>(ResultMove::VT_SPEED, speed, 0.0f);
  }
  void add_direction(::flatbuffers::Offset<::flatbuffers::String> direction) {
    fbb_.AddOffset(ResultMove::VT_DIRECTION, direction);
  }
  void add_result(::flatbuffers::Offset<::flatbuffers::String> result) {
    fbb_.AddOffset(ResultMove::VT_RESULT, result);
  }
  void add_message(::flatbuffers::Offset<::flatbuffers::String> message) {
    fbb_.AddOffset(ResultMove::VT_MESSAGE, message);
  }
  explicit ResultMoveBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ResultMove> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ResultMove>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ResultMove> CreateResultMove(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> goal_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> goal_name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> method = 0,
    int32_t preset = 0,
    const SLAMNAV::MovePose *goal_pose = nullptr,
    float target = 0.0f,
    float speed = 0.0f,
    ::flatbuffers::Offset<::flatbuffers::String> direction = 0,
    ::flatbuffers::Offset<::flatbuffers::String> result = 0,
    ::flatbuffers::Offset<::flatbuffers::String> message = 0) {
  ResultMoveBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_result(result);
  builder_.add_direction(direction);
  builder_.add_speed(speed);
  builder_.add_target(target);
  builder_.add_goal_pose(goal_pose);
  builder_.add_preset(preset);
  builder_.add_method(method);
  builder_.add_goal_name(goal_name);
  builder_.add_goal_id(goal_id);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ResultMove> CreateResultMoveDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *goal_id = nullptr,
    const char *goal_name = nullptr,
    const char *method = nullptr,
    int32_t preset = 0,
    const SLAMNAV::MovePose *goal_pose = nullptr,
    float target = 0.0f,
    float speed = 0.0f,
    const char *direction = nullptr,
    const char *result = nullptr,
    const char *message = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto goal_id__ = goal_id ? _fbb.CreateString(goal_id) : 0;
  auto goal_name__ = goal_name ? _fbb.CreateString(goal_name) : 0;
  auto method__ = method ? _fbb.CreateString(method) : 0;
  auto direction__ = direction ? _fbb.CreateString(direction) : 0;
  auto result__ = result ? _fbb.CreateString(result) : 0;
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return SLAMNAV::CreateResultMove(
      _fbb,
      id__,
      goal_id__,
      goal_name__,
      method__,
      preset,
      goal_pose,
      target,
      speed,
      direction__,
      result__,
      message__);
}

}  // namespace SLAMNAV

#endif  // FLATBUFFERS_GENERATED_SLAMNAVMOVE_SLAMNAV_H_
