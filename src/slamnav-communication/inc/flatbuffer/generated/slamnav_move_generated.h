// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SLAMNAVMOVE_SLAMNAV_H_
#define FLATBUFFERS_GENERATED_SLAMNAVMOVE_SLAMNAV_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 9 &&
              FLATBUFFERS_VERSION_REVISION == 23,
             "Non-compatible flatbuffers version included");

namespace SLAMNAV {

struct MovePose;

struct Request_Move_Goal;
struct Request_Move_GoalBuilder;

struct Response_Move_Goal;
struct Response_Move_GoalBuilder;

struct Request_Move_Target;
struct Request_Move_TargetBuilder;

struct Response_Move_Target;
struct Response_Move_TargetBuilder;

struct Move_Jog;
struct Move_JogBuilder;

struct Request_Move_Stop;
struct Request_Move_StopBuilder;

struct Response_Move_Stop;
struct Response_Move_StopBuilder;

struct Request_Move_Pause;
struct Request_Move_PauseBuilder;

struct Response_Move_Pause;
struct Response_Move_PauseBuilder;

struct Request_Move_Resume;
struct Request_Move_ResumeBuilder;

struct Response_Move_Resume;
struct Response_Move_ResumeBuilder;

struct Request_Move_xLinear;
struct Request_Move_xLinearBuilder;

struct Response_Move_xLinear;
struct Response_Move_xLinearBuilder;

struct Request_Move_yLinear;
struct Request_Move_yLinearBuilder;

struct Response_Move_yLinear;
struct Response_Move_yLinearBuilder;

struct Request_Move_Circular;
struct Request_Move_CircularBuilder;

struct Response_Move_Circular;
struct Response_Move_CircularBuilder;

struct Request_Move_Rotate;
struct Request_Move_RotateBuilder;

struct Response_Move_Rotate;
struct Response_Move_RotateBuilder;

struct Result_Move;
struct Result_MoveBuilder;

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) MovePose FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;
  float rz_;

 public:
  MovePose()
      : x_(0),
        y_(0),
        z_(0),
        rz_(0) {
  }
  MovePose(float _x, float _y, float _z, float _rz)
      : x_(::flatbuffers::EndianScalar(_x)),
        y_(::flatbuffers::EndianScalar(_y)),
        z_(::flatbuffers::EndianScalar(_z)),
        rz_(::flatbuffers::EndianScalar(_rz)) {
  }
  float x() const {
    return ::flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return ::flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return ::flatbuffers::EndianScalar(z_);
  }
  float rz() const {
    return ::flatbuffers::EndianScalar(rz_);
  }
};
FLATBUFFERS_STRUCT_END(MovePose, 16);

struct Request_Move_Goal FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Request_Move_GoalBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_GOAL_ID = 6,
    VT_GOAL_NAME = 8,
    VT_METHOD = 10,
    VT_PRESET = 12
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  const ::flatbuffers::String *goal_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_GOAL_ID);
  }
  const ::flatbuffers::String *goal_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_GOAL_NAME);
  }
  const ::flatbuffers::String *method() const {
    return GetPointer<const ::flatbuffers::String *>(VT_METHOD);
  }
  int32_t preset() const {
    return GetField<int32_t>(VT_PRESET, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_GOAL_ID) &&
           verifier.VerifyString(goal_id()) &&
           VerifyOffset(verifier, VT_GOAL_NAME) &&
           verifier.VerifyString(goal_name()) &&
           VerifyOffset(verifier, VT_METHOD) &&
           verifier.VerifyString(method()) &&
           VerifyField<int32_t>(verifier, VT_PRESET, 4) &&
           verifier.EndTable();
  }
};

struct Request_Move_GoalBuilder {
  typedef Request_Move_Goal Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(Request_Move_Goal::VT_ID, id);
  }
  void add_goal_id(::flatbuffers::Offset<::flatbuffers::String> goal_id) {
    fbb_.AddOffset(Request_Move_Goal::VT_GOAL_ID, goal_id);
  }
  void add_goal_name(::flatbuffers::Offset<::flatbuffers::String> goal_name) {
    fbb_.AddOffset(Request_Move_Goal::VT_GOAL_NAME, goal_name);
  }
  void add_method(::flatbuffers::Offset<::flatbuffers::String> method) {
    fbb_.AddOffset(Request_Move_Goal::VT_METHOD, method);
  }
  void add_preset(int32_t preset) {
    fbb_.AddElement<int32_t>(Request_Move_Goal::VT_PRESET, preset, 0);
  }
  explicit Request_Move_GoalBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Request_Move_Goal> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Request_Move_Goal>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Request_Move_Goal> CreateRequest_Move_Goal(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> goal_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> goal_name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> method = 0,
    int32_t preset = 0) {
  Request_Move_GoalBuilder builder_(_fbb);
  builder_.add_preset(preset);
  builder_.add_method(method);
  builder_.add_goal_name(goal_name);
  builder_.add_goal_id(goal_id);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Request_Move_Goal> CreateRequest_Move_GoalDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *goal_id = nullptr,
    const char *goal_name = nullptr,
    const char *method = nullptr,
    int32_t preset = 0) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto goal_id__ = goal_id ? _fbb.CreateString(goal_id) : 0;
  auto goal_name__ = goal_name ? _fbb.CreateString(goal_name) : 0;
  auto method__ = method ? _fbb.CreateString(method) : 0;
  return SLAMNAV::CreateRequest_Move_Goal(
      _fbb,
      id__,
      goal_id__,
      goal_name__,
      method__,
      preset);
}

struct Response_Move_Goal FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Response_Move_GoalBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_GOAL_ID = 6,
    VT_GOAL_NAME = 8,
    VT_METHOD = 10,
    VT_PRESET = 12,
    VT_RESULT = 14,
    VT_MESSAGE = 16
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  const ::flatbuffers::String *goal_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_GOAL_ID);
  }
  const ::flatbuffers::String *goal_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_GOAL_NAME);
  }
  const ::flatbuffers::String *method() const {
    return GetPointer<const ::flatbuffers::String *>(VT_METHOD);
  }
  int32_t preset() const {
    return GetField<int32_t>(VT_PRESET, 0);
  }
  const ::flatbuffers::String *result() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RESULT);
  }
  const ::flatbuffers::String *message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_GOAL_ID) &&
           verifier.VerifyString(goal_id()) &&
           VerifyOffset(verifier, VT_GOAL_NAME) &&
           verifier.VerifyString(goal_name()) &&
           VerifyOffset(verifier, VT_METHOD) &&
           verifier.VerifyString(method()) &&
           VerifyField<int32_t>(verifier, VT_PRESET, 4) &&
           VerifyOffset(verifier, VT_RESULT) &&
           verifier.VerifyString(result()) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
};

struct Response_Move_GoalBuilder {
  typedef Response_Move_Goal Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(Response_Move_Goal::VT_ID, id);
  }
  void add_goal_id(::flatbuffers::Offset<::flatbuffers::String> goal_id) {
    fbb_.AddOffset(Response_Move_Goal::VT_GOAL_ID, goal_id);
  }
  void add_goal_name(::flatbuffers::Offset<::flatbuffers::String> goal_name) {
    fbb_.AddOffset(Response_Move_Goal::VT_GOAL_NAME, goal_name);
  }
  void add_method(::flatbuffers::Offset<::flatbuffers::String> method) {
    fbb_.AddOffset(Response_Move_Goal::VT_METHOD, method);
  }
  void add_preset(int32_t preset) {
    fbb_.AddElement<int32_t>(Response_Move_Goal::VT_PRESET, preset, 0);
  }
  void add_result(::flatbuffers::Offset<::flatbuffers::String> result) {
    fbb_.AddOffset(Response_Move_Goal::VT_RESULT, result);
  }
  void add_message(::flatbuffers::Offset<::flatbuffers::String> message) {
    fbb_.AddOffset(Response_Move_Goal::VT_MESSAGE, message);
  }
  explicit Response_Move_GoalBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Response_Move_Goal> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Response_Move_Goal>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Response_Move_Goal> CreateResponse_Move_Goal(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> goal_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> goal_name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> method = 0,
    int32_t preset = 0,
    ::flatbuffers::Offset<::flatbuffers::String> result = 0,
    ::flatbuffers::Offset<::flatbuffers::String> message = 0) {
  Response_Move_GoalBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_result(result);
  builder_.add_preset(preset);
  builder_.add_method(method);
  builder_.add_goal_name(goal_name);
  builder_.add_goal_id(goal_id);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Response_Move_Goal> CreateResponse_Move_GoalDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *goal_id = nullptr,
    const char *goal_name = nullptr,
    const char *method = nullptr,
    int32_t preset = 0,
    const char *result = nullptr,
    const char *message = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto goal_id__ = goal_id ? _fbb.CreateString(goal_id) : 0;
  auto goal_name__ = goal_name ? _fbb.CreateString(goal_name) : 0;
  auto method__ = method ? _fbb.CreateString(method) : 0;
  auto result__ = result ? _fbb.CreateString(result) : 0;
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return SLAMNAV::CreateResponse_Move_Goal(
      _fbb,
      id__,
      goal_id__,
      goal_name__,
      method__,
      preset,
      result__,
      message__);
}

struct Request_Move_Target FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Request_Move_TargetBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_GOAL_POSE = 6,
    VT_METHOD = 8,
    VT_PRESET = 10
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  const SLAMNAV::MovePose *goal_pose() const {
    return GetStruct<const SLAMNAV::MovePose *>(VT_GOAL_POSE);
  }
  const ::flatbuffers::String *method() const {
    return GetPointer<const ::flatbuffers::String *>(VT_METHOD);
  }
  int32_t preset() const {
    return GetField<int32_t>(VT_PRESET, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyField<SLAMNAV::MovePose>(verifier, VT_GOAL_POSE, 4) &&
           VerifyOffset(verifier, VT_METHOD) &&
           verifier.VerifyString(method()) &&
           VerifyField<int32_t>(verifier, VT_PRESET, 4) &&
           verifier.EndTable();
  }
};

struct Request_Move_TargetBuilder {
  typedef Request_Move_Target Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(Request_Move_Target::VT_ID, id);
  }
  void add_goal_pose(const SLAMNAV::MovePose *goal_pose) {
    fbb_.AddStruct(Request_Move_Target::VT_GOAL_POSE, goal_pose);
  }
  void add_method(::flatbuffers::Offset<::flatbuffers::String> method) {
    fbb_.AddOffset(Request_Move_Target::VT_METHOD, method);
  }
  void add_preset(int32_t preset) {
    fbb_.AddElement<int32_t>(Request_Move_Target::VT_PRESET, preset, 0);
  }
  explicit Request_Move_TargetBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Request_Move_Target> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Request_Move_Target>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Request_Move_Target> CreateRequest_Move_Target(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    const SLAMNAV::MovePose *goal_pose = nullptr,
    ::flatbuffers::Offset<::flatbuffers::String> method = 0,
    int32_t preset = 0) {
  Request_Move_TargetBuilder builder_(_fbb);
  builder_.add_preset(preset);
  builder_.add_method(method);
  builder_.add_goal_pose(goal_pose);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Request_Move_Target> CreateRequest_Move_TargetDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const SLAMNAV::MovePose *goal_pose = nullptr,
    const char *method = nullptr,
    int32_t preset = 0) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto method__ = method ? _fbb.CreateString(method) : 0;
  return SLAMNAV::CreateRequest_Move_Target(
      _fbb,
      id__,
      goal_pose,
      method__,
      preset);
}

struct Response_Move_Target FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Response_Move_TargetBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_METHOD = 6,
    VT_GOAL_POSE = 8,
    VT_PRESET = 10,
    VT_RESULT = 12,
    VT_MESSAGE = 14
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  const ::flatbuffers::String *method() const {
    return GetPointer<const ::flatbuffers::String *>(VT_METHOD);
  }
  const SLAMNAV::MovePose *goal_pose() const {
    return GetStruct<const SLAMNAV::MovePose *>(VT_GOAL_POSE);
  }
  int32_t preset() const {
    return GetField<int32_t>(VT_PRESET, 0);
  }
  const ::flatbuffers::String *result() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RESULT);
  }
  const ::flatbuffers::String *message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_METHOD) &&
           verifier.VerifyString(method()) &&
           VerifyField<SLAMNAV::MovePose>(verifier, VT_GOAL_POSE, 4) &&
           VerifyField<int32_t>(verifier, VT_PRESET, 4) &&
           VerifyOffset(verifier, VT_RESULT) &&
           verifier.VerifyString(result()) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
};

struct Response_Move_TargetBuilder {
  typedef Response_Move_Target Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(Response_Move_Target::VT_ID, id);
  }
  void add_method(::flatbuffers::Offset<::flatbuffers::String> method) {
    fbb_.AddOffset(Response_Move_Target::VT_METHOD, method);
  }
  void add_goal_pose(const SLAMNAV::MovePose *goal_pose) {
    fbb_.AddStruct(Response_Move_Target::VT_GOAL_POSE, goal_pose);
  }
  void add_preset(int32_t preset) {
    fbb_.AddElement<int32_t>(Response_Move_Target::VT_PRESET, preset, 0);
  }
  void add_result(::flatbuffers::Offset<::flatbuffers::String> result) {
    fbb_.AddOffset(Response_Move_Target::VT_RESULT, result);
  }
  void add_message(::flatbuffers::Offset<::flatbuffers::String> message) {
    fbb_.AddOffset(Response_Move_Target::VT_MESSAGE, message);
  }
  explicit Response_Move_TargetBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Response_Move_Target> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Response_Move_Target>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Response_Move_Target> CreateResponse_Move_Target(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> method = 0,
    const SLAMNAV::MovePose *goal_pose = nullptr,
    int32_t preset = 0,
    ::flatbuffers::Offset<::flatbuffers::String> result = 0,
    ::flatbuffers::Offset<::flatbuffers::String> message = 0) {
  Response_Move_TargetBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_result(result);
  builder_.add_preset(preset);
  builder_.add_goal_pose(goal_pose);
  builder_.add_method(method);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Response_Move_Target> CreateResponse_Move_TargetDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *method = nullptr,
    const SLAMNAV::MovePose *goal_pose = nullptr,
    int32_t preset = 0,
    const char *result = nullptr,
    const char *message = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto method__ = method ? _fbb.CreateString(method) : 0;
  auto result__ = result ? _fbb.CreateString(result) : 0;
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return SLAMNAV::CreateResponse_Move_Target(
      _fbb,
      id__,
      method__,
      goal_pose,
      preset,
      result__,
      message__);
}

struct Move_Jog FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Move_JogBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VX = 4,
    VT_VY = 6,
    VT_WZ = 8
  };
  float vx() const {
    return GetField<float>(VT_VX, 0.0f);
  }
  float vy() const {
    return GetField<float>(VT_VY, 0.0f);
  }
  float wz() const {
    return GetField<float>(VT_WZ, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_VX, 4) &&
           VerifyField<float>(verifier, VT_VY, 4) &&
           VerifyField<float>(verifier, VT_WZ, 4) &&
           verifier.EndTable();
  }
};

struct Move_JogBuilder {
  typedef Move_Jog Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_vx(float vx) {
    fbb_.AddElement<float>(Move_Jog::VT_VX, vx, 0.0f);
  }
  void add_vy(float vy) {
    fbb_.AddElement<float>(Move_Jog::VT_VY, vy, 0.0f);
  }
  void add_wz(float wz) {
    fbb_.AddElement<float>(Move_Jog::VT_WZ, wz, 0.0f);
  }
  explicit Move_JogBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Move_Jog> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Move_Jog>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Move_Jog> CreateMove_Jog(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float vx = 0.0f,
    float vy = 0.0f,
    float wz = 0.0f) {
  Move_JogBuilder builder_(_fbb);
  builder_.add_wz(wz);
  builder_.add_vy(vy);
  builder_.add_vx(vx);
  return builder_.Finish();
}

struct Request_Move_Stop FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Request_Move_StopBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           verifier.EndTable();
  }
};

struct Request_Move_StopBuilder {
  typedef Request_Move_Stop Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(Request_Move_Stop::VT_ID, id);
  }
  explicit Request_Move_StopBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Request_Move_Stop> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Request_Move_Stop>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Request_Move_Stop> CreateRequest_Move_Stop(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0) {
  Request_Move_StopBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Request_Move_Stop> CreateRequest_Move_StopDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  return SLAMNAV::CreateRequest_Move_Stop(
      _fbb,
      id__);
}

struct Response_Move_Stop FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Response_Move_StopBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_RESULT = 6,
    VT_MESSAGE = 8
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  const ::flatbuffers::String *result() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RESULT);
  }
  const ::flatbuffers::String *message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_RESULT) &&
           verifier.VerifyString(result()) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
};

struct Response_Move_StopBuilder {
  typedef Response_Move_Stop Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(Response_Move_Stop::VT_ID, id);
  }
  void add_result(::flatbuffers::Offset<::flatbuffers::String> result) {
    fbb_.AddOffset(Response_Move_Stop::VT_RESULT, result);
  }
  void add_message(::flatbuffers::Offset<::flatbuffers::String> message) {
    fbb_.AddOffset(Response_Move_Stop::VT_MESSAGE, message);
  }
  explicit Response_Move_StopBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Response_Move_Stop> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Response_Move_Stop>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Response_Move_Stop> CreateResponse_Move_Stop(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> result = 0,
    ::flatbuffers::Offset<::flatbuffers::String> message = 0) {
  Response_Move_StopBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_result(result);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Response_Move_Stop> CreateResponse_Move_StopDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *result = nullptr,
    const char *message = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto result__ = result ? _fbb.CreateString(result) : 0;
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return SLAMNAV::CreateResponse_Move_Stop(
      _fbb,
      id__,
      result__,
      message__);
}

struct Request_Move_Pause FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Request_Move_PauseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           verifier.EndTable();
  }
};

struct Request_Move_PauseBuilder {
  typedef Request_Move_Pause Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(Request_Move_Pause::VT_ID, id);
  }
  explicit Request_Move_PauseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Request_Move_Pause> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Request_Move_Pause>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Request_Move_Pause> CreateRequest_Move_Pause(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0) {
  Request_Move_PauseBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Request_Move_Pause> CreateRequest_Move_PauseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  return SLAMNAV::CreateRequest_Move_Pause(
      _fbb,
      id__);
}

struct Response_Move_Pause FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Response_Move_PauseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_RESULT = 6,
    VT_MESSAGE = 8
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  const ::flatbuffers::String *result() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RESULT);
  }
  const ::flatbuffers::String *message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_RESULT) &&
           verifier.VerifyString(result()) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
};

struct Response_Move_PauseBuilder {
  typedef Response_Move_Pause Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(Response_Move_Pause::VT_ID, id);
  }
  void add_result(::flatbuffers::Offset<::flatbuffers::String> result) {
    fbb_.AddOffset(Response_Move_Pause::VT_RESULT, result);
  }
  void add_message(::flatbuffers::Offset<::flatbuffers::String> message) {
    fbb_.AddOffset(Response_Move_Pause::VT_MESSAGE, message);
  }
  explicit Response_Move_PauseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Response_Move_Pause> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Response_Move_Pause>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Response_Move_Pause> CreateResponse_Move_Pause(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> result = 0,
    ::flatbuffers::Offset<::flatbuffers::String> message = 0) {
  Response_Move_PauseBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_result(result);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Response_Move_Pause> CreateResponse_Move_PauseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *result = nullptr,
    const char *message = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto result__ = result ? _fbb.CreateString(result) : 0;
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return SLAMNAV::CreateResponse_Move_Pause(
      _fbb,
      id__,
      result__,
      message__);
}

struct Request_Move_Resume FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Request_Move_ResumeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           verifier.EndTable();
  }
};

struct Request_Move_ResumeBuilder {
  typedef Request_Move_Resume Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(Request_Move_Resume::VT_ID, id);
  }
  explicit Request_Move_ResumeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Request_Move_Resume> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Request_Move_Resume>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Request_Move_Resume> CreateRequest_Move_Resume(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0) {
  Request_Move_ResumeBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Request_Move_Resume> CreateRequest_Move_ResumeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  return SLAMNAV::CreateRequest_Move_Resume(
      _fbb,
      id__);
}

struct Response_Move_Resume FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Response_Move_ResumeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_RESULT = 6,
    VT_MESSAGE = 8
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  const ::flatbuffers::String *result() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RESULT);
  }
  const ::flatbuffers::String *message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_RESULT) &&
           verifier.VerifyString(result()) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
};

struct Response_Move_ResumeBuilder {
  typedef Response_Move_Resume Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(Response_Move_Resume::VT_ID, id);
  }
  void add_result(::flatbuffers::Offset<::flatbuffers::String> result) {
    fbb_.AddOffset(Response_Move_Resume::VT_RESULT, result);
  }
  void add_message(::flatbuffers::Offset<::flatbuffers::String> message) {
    fbb_.AddOffset(Response_Move_Resume::VT_MESSAGE, message);
  }
  explicit Response_Move_ResumeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Response_Move_Resume> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Response_Move_Resume>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Response_Move_Resume> CreateResponse_Move_Resume(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> result = 0,
    ::flatbuffers::Offset<::flatbuffers::String> message = 0) {
  Response_Move_ResumeBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_result(result);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Response_Move_Resume> CreateResponse_Move_ResumeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *result = nullptr,
    const char *message = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto result__ = result ? _fbb.CreateString(result) : 0;
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return SLAMNAV::CreateResponse_Move_Resume(
      _fbb,
      id__,
      result__,
      message__);
}

struct Request_Move_xLinear FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Request_Move_xLinearBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_TARGET = 6,
    VT_SPEED = 8
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  float target() const {
    return GetField<float>(VT_TARGET, 0.0f);
  }
  float speed() const {
    return GetField<float>(VT_SPEED, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyField<float>(verifier, VT_TARGET, 4) &&
           VerifyField<float>(verifier, VT_SPEED, 4) &&
           verifier.EndTable();
  }
};

struct Request_Move_xLinearBuilder {
  typedef Request_Move_xLinear Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(Request_Move_xLinear::VT_ID, id);
  }
  void add_target(float target) {
    fbb_.AddElement<float>(Request_Move_xLinear::VT_TARGET, target, 0.0f);
  }
  void add_speed(float speed) {
    fbb_.AddElement<float>(Request_Move_xLinear::VT_SPEED, speed, 0.0f);
  }
  explicit Request_Move_xLinearBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Request_Move_xLinear> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Request_Move_xLinear>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Request_Move_xLinear> CreateRequest_Move_xLinear(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    float target = 0.0f,
    float speed = 0.0f) {
  Request_Move_xLinearBuilder builder_(_fbb);
  builder_.add_speed(speed);
  builder_.add_target(target);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Request_Move_xLinear> CreateRequest_Move_xLinearDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    float target = 0.0f,
    float speed = 0.0f) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  return SLAMNAV::CreateRequest_Move_xLinear(
      _fbb,
      id__,
      target,
      speed);
}

struct Response_Move_xLinear FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Response_Move_xLinearBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_TARGET = 6,
    VT_SPEED = 8,
    VT_RESULT = 10,
    VT_MESSAGE = 12
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  float target() const {
    return GetField<float>(VT_TARGET, 0.0f);
  }
  float speed() const {
    return GetField<float>(VT_SPEED, 0.0f);
  }
  const ::flatbuffers::String *result() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RESULT);
  }
  const ::flatbuffers::String *message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyField<float>(verifier, VT_TARGET, 4) &&
           VerifyField<float>(verifier, VT_SPEED, 4) &&
           VerifyOffset(verifier, VT_RESULT) &&
           verifier.VerifyString(result()) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
};

struct Response_Move_xLinearBuilder {
  typedef Response_Move_xLinear Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(Response_Move_xLinear::VT_ID, id);
  }
  void add_target(float target) {
    fbb_.AddElement<float>(Response_Move_xLinear::VT_TARGET, target, 0.0f);
  }
  void add_speed(float speed) {
    fbb_.AddElement<float>(Response_Move_xLinear::VT_SPEED, speed, 0.0f);
  }
  void add_result(::flatbuffers::Offset<::flatbuffers::String> result) {
    fbb_.AddOffset(Response_Move_xLinear::VT_RESULT, result);
  }
  void add_message(::flatbuffers::Offset<::flatbuffers::String> message) {
    fbb_.AddOffset(Response_Move_xLinear::VT_MESSAGE, message);
  }
  explicit Response_Move_xLinearBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Response_Move_xLinear> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Response_Move_xLinear>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Response_Move_xLinear> CreateResponse_Move_xLinear(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    float target = 0.0f,
    float speed = 0.0f,
    ::flatbuffers::Offset<::flatbuffers::String> result = 0,
    ::flatbuffers::Offset<::flatbuffers::String> message = 0) {
  Response_Move_xLinearBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_result(result);
  builder_.add_speed(speed);
  builder_.add_target(target);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Response_Move_xLinear> CreateResponse_Move_xLinearDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    float target = 0.0f,
    float speed = 0.0f,
    const char *result = nullptr,
    const char *message = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto result__ = result ? _fbb.CreateString(result) : 0;
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return SLAMNAV::CreateResponse_Move_xLinear(
      _fbb,
      id__,
      target,
      speed,
      result__,
      message__);
}

struct Request_Move_yLinear FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Request_Move_yLinearBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_TARGET = 6,
    VT_SPEED = 8
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  float target() const {
    return GetField<float>(VT_TARGET, 0.0f);
  }
  float speed() const {
    return GetField<float>(VT_SPEED, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyField<float>(verifier, VT_TARGET, 4) &&
           VerifyField<float>(verifier, VT_SPEED, 4) &&
           verifier.EndTable();
  }
};

struct Request_Move_yLinearBuilder {
  typedef Request_Move_yLinear Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(Request_Move_yLinear::VT_ID, id);
  }
  void add_target(float target) {
    fbb_.AddElement<float>(Request_Move_yLinear::VT_TARGET, target, 0.0f);
  }
  void add_speed(float speed) {
    fbb_.AddElement<float>(Request_Move_yLinear::VT_SPEED, speed, 0.0f);
  }
  explicit Request_Move_yLinearBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Request_Move_yLinear> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Request_Move_yLinear>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Request_Move_yLinear> CreateRequest_Move_yLinear(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    float target = 0.0f,
    float speed = 0.0f) {
  Request_Move_yLinearBuilder builder_(_fbb);
  builder_.add_speed(speed);
  builder_.add_target(target);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Request_Move_yLinear> CreateRequest_Move_yLinearDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    float target = 0.0f,
    float speed = 0.0f) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  return SLAMNAV::CreateRequest_Move_yLinear(
      _fbb,
      id__,
      target,
      speed);
}

struct Response_Move_yLinear FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Response_Move_yLinearBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_TARGET = 6,
    VT_SPEED = 8,
    VT_RESULT = 10,
    VT_MESSAGE = 12
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  float target() const {
    return GetField<float>(VT_TARGET, 0.0f);
  }
  float speed() const {
    return GetField<float>(VT_SPEED, 0.0f);
  }
  const ::flatbuffers::String *result() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RESULT);
  }
  const ::flatbuffers::String *message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyField<float>(verifier, VT_TARGET, 4) &&
           VerifyField<float>(verifier, VT_SPEED, 4) &&
           VerifyOffset(verifier, VT_RESULT) &&
           verifier.VerifyString(result()) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
};

struct Response_Move_yLinearBuilder {
  typedef Response_Move_yLinear Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(Response_Move_yLinear::VT_ID, id);
  }
  void add_target(float target) {
    fbb_.AddElement<float>(Response_Move_yLinear::VT_TARGET, target, 0.0f);
  }
  void add_speed(float speed) {
    fbb_.AddElement<float>(Response_Move_yLinear::VT_SPEED, speed, 0.0f);
  }
  void add_result(::flatbuffers::Offset<::flatbuffers::String> result) {
    fbb_.AddOffset(Response_Move_yLinear::VT_RESULT, result);
  }
  void add_message(::flatbuffers::Offset<::flatbuffers::String> message) {
    fbb_.AddOffset(Response_Move_yLinear::VT_MESSAGE, message);
  }
  explicit Response_Move_yLinearBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Response_Move_yLinear> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Response_Move_yLinear>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Response_Move_yLinear> CreateResponse_Move_yLinear(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    float target = 0.0f,
    float speed = 0.0f,
    ::flatbuffers::Offset<::flatbuffers::String> result = 0,
    ::flatbuffers::Offset<::flatbuffers::String> message = 0) {
  Response_Move_yLinearBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_result(result);
  builder_.add_speed(speed);
  builder_.add_target(target);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Response_Move_yLinear> CreateResponse_Move_yLinearDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    float target = 0.0f,
    float speed = 0.0f,
    const char *result = nullptr,
    const char *message = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto result__ = result ? _fbb.CreateString(result) : 0;
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return SLAMNAV::CreateResponse_Move_yLinear(
      _fbb,
      id__,
      target,
      speed,
      result__,
      message__);
}

struct Request_Move_Circular FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Request_Move_CircularBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_TARGET = 6,
    VT_SPEED = 8,
    VT_DIRECTION = 10
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  float target() const {
    return GetField<float>(VT_TARGET, 0.0f);
  }
  float speed() const {
    return GetField<float>(VT_SPEED, 0.0f);
  }
  const ::flatbuffers::String *direction() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DIRECTION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyField<float>(verifier, VT_TARGET, 4) &&
           VerifyField<float>(verifier, VT_SPEED, 4) &&
           VerifyOffset(verifier, VT_DIRECTION) &&
           verifier.VerifyString(direction()) &&
           verifier.EndTable();
  }
};

struct Request_Move_CircularBuilder {
  typedef Request_Move_Circular Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(Request_Move_Circular::VT_ID, id);
  }
  void add_target(float target) {
    fbb_.AddElement<float>(Request_Move_Circular::VT_TARGET, target, 0.0f);
  }
  void add_speed(float speed) {
    fbb_.AddElement<float>(Request_Move_Circular::VT_SPEED, speed, 0.0f);
  }
  void add_direction(::flatbuffers::Offset<::flatbuffers::String> direction) {
    fbb_.AddOffset(Request_Move_Circular::VT_DIRECTION, direction);
  }
  explicit Request_Move_CircularBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Request_Move_Circular> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Request_Move_Circular>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Request_Move_Circular> CreateRequest_Move_Circular(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    float target = 0.0f,
    float speed = 0.0f,
    ::flatbuffers::Offset<::flatbuffers::String> direction = 0) {
  Request_Move_CircularBuilder builder_(_fbb);
  builder_.add_direction(direction);
  builder_.add_speed(speed);
  builder_.add_target(target);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Request_Move_Circular> CreateRequest_Move_CircularDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    float target = 0.0f,
    float speed = 0.0f,
    const char *direction = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto direction__ = direction ? _fbb.CreateString(direction) : 0;
  return SLAMNAV::CreateRequest_Move_Circular(
      _fbb,
      id__,
      target,
      speed,
      direction__);
}

struct Response_Move_Circular FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Response_Move_CircularBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_TARGET = 6,
    VT_SPEED = 8,
    VT_DIRECTION = 10,
    VT_RESULT = 12,
    VT_MESSAGE = 14
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  float target() const {
    return GetField<float>(VT_TARGET, 0.0f);
  }
  float speed() const {
    return GetField<float>(VT_SPEED, 0.0f);
  }
  const ::flatbuffers::String *direction() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DIRECTION);
  }
  const ::flatbuffers::String *result() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RESULT);
  }
  const ::flatbuffers::String *message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyField<float>(verifier, VT_TARGET, 4) &&
           VerifyField<float>(verifier, VT_SPEED, 4) &&
           VerifyOffset(verifier, VT_DIRECTION) &&
           verifier.VerifyString(direction()) &&
           VerifyOffset(verifier, VT_RESULT) &&
           verifier.VerifyString(result()) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
};

struct Response_Move_CircularBuilder {
  typedef Response_Move_Circular Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(Response_Move_Circular::VT_ID, id);
  }
  void add_target(float target) {
    fbb_.AddElement<float>(Response_Move_Circular::VT_TARGET, target, 0.0f);
  }
  void add_speed(float speed) {
    fbb_.AddElement<float>(Response_Move_Circular::VT_SPEED, speed, 0.0f);
  }
  void add_direction(::flatbuffers::Offset<::flatbuffers::String> direction) {
    fbb_.AddOffset(Response_Move_Circular::VT_DIRECTION, direction);
  }
  void add_result(::flatbuffers::Offset<::flatbuffers::String> result) {
    fbb_.AddOffset(Response_Move_Circular::VT_RESULT, result);
  }
  void add_message(::flatbuffers::Offset<::flatbuffers::String> message) {
    fbb_.AddOffset(Response_Move_Circular::VT_MESSAGE, message);
  }
  explicit Response_Move_CircularBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Response_Move_Circular> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Response_Move_Circular>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Response_Move_Circular> CreateResponse_Move_Circular(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    float target = 0.0f,
    float speed = 0.0f,
    ::flatbuffers::Offset<::flatbuffers::String> direction = 0,
    ::flatbuffers::Offset<::flatbuffers::String> result = 0,
    ::flatbuffers::Offset<::flatbuffers::String> message = 0) {
  Response_Move_CircularBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_result(result);
  builder_.add_direction(direction);
  builder_.add_speed(speed);
  builder_.add_target(target);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Response_Move_Circular> CreateResponse_Move_CircularDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    float target = 0.0f,
    float speed = 0.0f,
    const char *direction = nullptr,
    const char *result = nullptr,
    const char *message = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto direction__ = direction ? _fbb.CreateString(direction) : 0;
  auto result__ = result ? _fbb.CreateString(result) : 0;
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return SLAMNAV::CreateResponse_Move_Circular(
      _fbb,
      id__,
      target,
      speed,
      direction__,
      result__,
      message__);
}

struct Request_Move_Rotate FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Request_Move_RotateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_TARGET = 6,
    VT_SPEED = 8
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  float target() const {
    return GetField<float>(VT_TARGET, 0.0f);
  }
  float speed() const {
    return GetField<float>(VT_SPEED, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyField<float>(verifier, VT_TARGET, 4) &&
           VerifyField<float>(verifier, VT_SPEED, 4) &&
           verifier.EndTable();
  }
};

struct Request_Move_RotateBuilder {
  typedef Request_Move_Rotate Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(Request_Move_Rotate::VT_ID, id);
  }
  void add_target(float target) {
    fbb_.AddElement<float>(Request_Move_Rotate::VT_TARGET, target, 0.0f);
  }
  void add_speed(float speed) {
    fbb_.AddElement<float>(Request_Move_Rotate::VT_SPEED, speed, 0.0f);
  }
  explicit Request_Move_RotateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Request_Move_Rotate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Request_Move_Rotate>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Request_Move_Rotate> CreateRequest_Move_Rotate(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    float target = 0.0f,
    float speed = 0.0f) {
  Request_Move_RotateBuilder builder_(_fbb);
  builder_.add_speed(speed);
  builder_.add_target(target);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Request_Move_Rotate> CreateRequest_Move_RotateDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    float target = 0.0f,
    float speed = 0.0f) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  return SLAMNAV::CreateRequest_Move_Rotate(
      _fbb,
      id__,
      target,
      speed);
}

struct Response_Move_Rotate FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Response_Move_RotateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_TARGET = 6,
    VT_SPEED = 8,
    VT_RESULT = 10,
    VT_MESSAGE = 12
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  float target() const {
    return GetField<float>(VT_TARGET, 0.0f);
  }
  float speed() const {
    return GetField<float>(VT_SPEED, 0.0f);
  }
  const ::flatbuffers::String *result() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RESULT);
  }
  const ::flatbuffers::String *message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyField<float>(verifier, VT_TARGET, 4) &&
           VerifyField<float>(verifier, VT_SPEED, 4) &&
           VerifyOffset(verifier, VT_RESULT) &&
           verifier.VerifyString(result()) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
};

struct Response_Move_RotateBuilder {
  typedef Response_Move_Rotate Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(Response_Move_Rotate::VT_ID, id);
  }
  void add_target(float target) {
    fbb_.AddElement<float>(Response_Move_Rotate::VT_TARGET, target, 0.0f);
  }
  void add_speed(float speed) {
    fbb_.AddElement<float>(Response_Move_Rotate::VT_SPEED, speed, 0.0f);
  }
  void add_result(::flatbuffers::Offset<::flatbuffers::String> result) {
    fbb_.AddOffset(Response_Move_Rotate::VT_RESULT, result);
  }
  void add_message(::flatbuffers::Offset<::flatbuffers::String> message) {
    fbb_.AddOffset(Response_Move_Rotate::VT_MESSAGE, message);
  }
  explicit Response_Move_RotateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Response_Move_Rotate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Response_Move_Rotate>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Response_Move_Rotate> CreateResponse_Move_Rotate(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    float target = 0.0f,
    float speed = 0.0f,
    ::flatbuffers::Offset<::flatbuffers::String> result = 0,
    ::flatbuffers::Offset<::flatbuffers::String> message = 0) {
  Response_Move_RotateBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_result(result);
  builder_.add_speed(speed);
  builder_.add_target(target);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Response_Move_Rotate> CreateResponse_Move_RotateDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    float target = 0.0f,
    float speed = 0.0f,
    const char *result = nullptr,
    const char *message = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto result__ = result ? _fbb.CreateString(result) : 0;
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return SLAMNAV::CreateResponse_Move_Rotate(
      _fbb,
      id__,
      target,
      speed,
      result__,
      message__);
}

struct Result_Move FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Result_MoveBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_GOAL_ID = 6,
    VT_GOAL_NAME = 8,
    VT_METHOD = 10,
    VT_PRESET = 12,
    VT_GOAL_POSE = 14,
    VT_TARGET = 16,
    VT_SPEED = 18,
    VT_DIRECTION = 20,
    VT_RESULT = 22,
    VT_MESSAGE = 24
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  const ::flatbuffers::String *goal_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_GOAL_ID);
  }
  const ::flatbuffers::String *goal_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_GOAL_NAME);
  }
  const ::flatbuffers::String *method() const {
    return GetPointer<const ::flatbuffers::String *>(VT_METHOD);
  }
  int32_t preset() const {
    return GetField<int32_t>(VT_PRESET, 0);
  }
  const SLAMNAV::MovePose *goal_pose() const {
    return GetStruct<const SLAMNAV::MovePose *>(VT_GOAL_POSE);
  }
  float target() const {
    return GetField<float>(VT_TARGET, 0.0f);
  }
  float speed() const {
    return GetField<float>(VT_SPEED, 0.0f);
  }
  const ::flatbuffers::String *direction() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DIRECTION);
  }
  const ::flatbuffers::String *result() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RESULT);
  }
  const ::flatbuffers::String *message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_GOAL_ID) &&
           verifier.VerifyString(goal_id()) &&
           VerifyOffset(verifier, VT_GOAL_NAME) &&
           verifier.VerifyString(goal_name()) &&
           VerifyOffset(verifier, VT_METHOD) &&
           verifier.VerifyString(method()) &&
           VerifyField<int32_t>(verifier, VT_PRESET, 4) &&
           VerifyField<SLAMNAV::MovePose>(verifier, VT_GOAL_POSE, 4) &&
           VerifyField<float>(verifier, VT_TARGET, 4) &&
           VerifyField<float>(verifier, VT_SPEED, 4) &&
           VerifyOffset(verifier, VT_DIRECTION) &&
           verifier.VerifyString(direction()) &&
           VerifyOffset(verifier, VT_RESULT) &&
           verifier.VerifyString(result()) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
};

struct Result_MoveBuilder {
  typedef Result_Move Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(Result_Move::VT_ID, id);
  }
  void add_goal_id(::flatbuffers::Offset<::flatbuffers::String> goal_id) {
    fbb_.AddOffset(Result_Move::VT_GOAL_ID, goal_id);
  }
  void add_goal_name(::flatbuffers::Offset<::flatbuffers::String> goal_name) {
    fbb_.AddOffset(Result_Move::VT_GOAL_NAME, goal_name);
  }
  void add_method(::flatbuffers::Offset<::flatbuffers::String> method) {
    fbb_.AddOffset(Result_Move::VT_METHOD, method);
  }
  void add_preset(int32_t preset) {
    fbb_.AddElement<int32_t>(Result_Move::VT_PRESET, preset, 0);
  }
  void add_goal_pose(const SLAMNAV::MovePose *goal_pose) {
    fbb_.AddStruct(Result_Move::VT_GOAL_POSE, goal_pose);
  }
  void add_target(float target) {
    fbb_.AddElement<float>(Result_Move::VT_TARGET, target, 0.0f);
  }
  void add_speed(float speed) {
    fbb_.AddElement<float>(Result_Move::VT_SPEED, speed, 0.0f);
  }
  void add_direction(::flatbuffers::Offset<::flatbuffers::String> direction) {
    fbb_.AddOffset(Result_Move::VT_DIRECTION, direction);
  }
  void add_result(::flatbuffers::Offset<::flatbuffers::String> result) {
    fbb_.AddOffset(Result_Move::VT_RESULT, result);
  }
  void add_message(::flatbuffers::Offset<::flatbuffers::String> message) {
    fbb_.AddOffset(Result_Move::VT_MESSAGE, message);
  }
  explicit Result_MoveBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Result_Move> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Result_Move>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Result_Move> CreateResult_Move(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> goal_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> goal_name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> method = 0,
    int32_t preset = 0,
    const SLAMNAV::MovePose *goal_pose = nullptr,
    float target = 0.0f,
    float speed = 0.0f,
    ::flatbuffers::Offset<::flatbuffers::String> direction = 0,
    ::flatbuffers::Offset<::flatbuffers::String> result = 0,
    ::flatbuffers::Offset<::flatbuffers::String> message = 0) {
  Result_MoveBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_result(result);
  builder_.add_direction(direction);
  builder_.add_speed(speed);
  builder_.add_target(target);
  builder_.add_goal_pose(goal_pose);
  builder_.add_preset(preset);
  builder_.add_method(method);
  builder_.add_goal_name(goal_name);
  builder_.add_goal_id(goal_id);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Result_Move> CreateResult_MoveDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *goal_id = nullptr,
    const char *goal_name = nullptr,
    const char *method = nullptr,
    int32_t preset = 0,
    const SLAMNAV::MovePose *goal_pose = nullptr,
    float target = 0.0f,
    float speed = 0.0f,
    const char *direction = nullptr,
    const char *result = nullptr,
    const char *message = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto goal_id__ = goal_id ? _fbb.CreateString(goal_id) : 0;
  auto goal_name__ = goal_name ? _fbb.CreateString(goal_name) : 0;
  auto method__ = method ? _fbb.CreateString(method) : 0;
  auto direction__ = direction ? _fbb.CreateString(direction) : 0;
  auto result__ = result ? _fbb.CreateString(result) : 0;
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return SLAMNAV::CreateResult_Move(
      _fbb,
      id__,
      goal_id__,
      goal_name__,
      method__,
      preset,
      goal_pose,
      target,
      speed,
      direction__,
      result__,
      message__);
}

}  // namespace SLAMNAV

#endif  // FLATBUFFERS_GENERATED_SLAMNAVMOVE_SLAMNAV_H_
