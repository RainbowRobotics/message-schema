// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SLAMNAVMAP_SLAMNAV_H_
#define FLATBUFFERS_GENERATED_SLAMNAVMAP_SLAMNAV_H_

#include "flatbuffers/flatbuffers.h"

namespace SLAMNAV {

struct MapFileInfo;
struct MapFileInfoBuilder;
struct MapFileInfoT;

struct MapFile;
struct MapFileBuilder;
struct MapFileT;

struct Request_Map_List;
struct Request_Map_ListBuilder;
struct Request_Map_ListT;

struct Response_Map_List;
struct Response_Map_ListBuilder;
struct Response_Map_ListT;

struct Request_Map_Delete;
struct Request_Map_DeleteBuilder;
struct Request_Map_DeleteT;

struct Response_Map_Delete;
struct Response_Map_DeleteBuilder;
struct Response_Map_DeleteT;

struct Request_Map_Current;
struct Request_Map_CurrentBuilder;
struct Request_Map_CurrentT;

struct Response_Map_Current;
struct Response_Map_CurrentBuilder;
struct Response_Map_CurrentT;

struct Request_Map_Load;
struct Request_Map_LoadBuilder;
struct Request_Map_LoadT;

struct Response_Map_Load;
struct Response_Map_LoadBuilder;
struct Response_Map_LoadT;

struct CloudData;

struct Request_Get_Map_File;
struct Request_Get_Map_FileBuilder;
struct Request_Get_Map_FileT;

struct Response_Get_Map_File;
struct Response_Get_Map_FileBuilder;
struct Response_Get_Map_FileT;

struct Link;
struct LinkBuilder;
struct LinkT;

struct Node;
struct NodeBuilder;
struct NodeT;

struct Request_Get_Map_Cloud;
struct Request_Get_Map_CloudBuilder;
struct Request_Get_Map_CloudT;

struct Response_Get_Map_Cloud;
struct Response_Get_Map_CloudBuilder;
struct Response_Get_Map_CloudT;

struct Request_Set_Map_Cloud;
struct Request_Set_Map_CloudBuilder;
struct Request_Set_Map_CloudT;

struct Response_Set_Map_Cloud;
struct Response_Set_Map_CloudBuilder;
struct Response_Set_Map_CloudT;

struct Request_Get_Map_pipe;
struct Request_Get_Map_pipeBuilder;
struct Request_Get_Map_pipeT;

struct Response_Get_Map_pipe;
struct Response_Get_Map_pipeBuilder;
struct Response_Get_Map_pipeT;

struct Request_Get_Map_Tiles;
struct Request_Get_Map_TilesBuilder;
struct Request_Get_Map_TilesT;

struct Response_Get_Map_Tiles;
struct Response_Get_Map_TilesBuilder;
struct Response_Get_Map_TilesT;

struct Request_Set_Map_Topology;
struct Request_Set_Map_TopologyBuilder;
struct Request_Set_Map_TopologyT;

struct Response_Set_Map_Topology;
struct Response_Set_Map_TopologyBuilder;
struct Response_Set_Map_TopologyT;

struct Request_Get_Map_Topology;
struct Request_Get_Map_TopologyBuilder;
struct Request_Get_Map_TopologyT;

struct Response_Get_Map_Topology;
struct Response_Get_Map_TopologyBuilder;
struct Response_Get_Map_TopologyT;

struct Request_Mapping_Start;
struct Request_Mapping_StartBuilder;
struct Request_Mapping_StartT;

struct Response_Mapping_Start;
struct Response_Mapping_StartBuilder;
struct Response_Mapping_StartT;

struct Request_Mapping_Stop;
struct Request_Mapping_StopBuilder;
struct Request_Mapping_StopT;

struct Response_Mapping_Stop;
struct Response_Mapping_StopBuilder;
struct Response_Mapping_StopT;

struct Request_Mapping_Save;
struct Request_Mapping_SaveBuilder;
struct Request_Mapping_SaveT;

struct Response_Mapping_Save;
struct Response_Mapping_SaveBuilder;
struct Response_Mapping_SaveT;

struct Request_Mapping_Cloud_Reload;
struct Request_Mapping_Cloud_ReloadBuilder;
struct Request_Mapping_Cloud_ReloadT;

struct Response_Mapping_Cloud_Reload;
struct Response_Mapping_Cloud_ReloadBuilder;
struct Response_Mapping_Cloud_ReloadT;

struct Map_Result;
struct Map_ResultBuilder;
struct Map_ResultT;

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) CloudData FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;
  float intensity_;

 public:
  CloudData()
      : x_(0),
        y_(0),
        z_(0),
        intensity_(0) {
  }
  CloudData(float _x, float _y, float _z, float _intensity)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)),
        intensity_(flatbuffers::EndianScalar(_intensity)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  void mutate_x(float _x) {
    flatbuffers::WriteScalar(&x_, _x);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  void mutate_y(float _y) {
    flatbuffers::WriteScalar(&y_, _y);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
  void mutate_z(float _z) {
    flatbuffers::WriteScalar(&z_, _z);
  }
  float intensity() const {
    return flatbuffers::EndianScalar(intensity_);
  }
  void mutate_intensity(float _intensity) {
    flatbuffers::WriteScalar(&intensity_, _intensity);
  }
};
FLATBUFFERS_STRUCT_END(CloudData, 16);

struct MapFileInfoT : public flatbuffers::NativeTable {
  typedef MapFileInfo TableType;
  std::string map_name;
  std::string created_at;
  std::string update_at;
  std::string map_type;
  float map_size;
  MapFileInfoT()
      : map_size(0.0f) {
  }
};

struct MapFileInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MapFileInfoT NativeTableType;
  typedef MapFileInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MAP_NAME = 4,
    VT_CREATED_AT = 6,
    VT_UPDATE_AT = 8,
    VT_MAP_TYPE = 10,
    VT_MAP_SIZE = 12
  };
  const flatbuffers::String *map_name() const {
    return GetPointer<const flatbuffers::String *>(VT_MAP_NAME);
  }
  flatbuffers::String *mutable_map_name() {
    return GetPointer<flatbuffers::String *>(VT_MAP_NAME);
  }
  const flatbuffers::String *created_at() const {
    return GetPointer<const flatbuffers::String *>(VT_CREATED_AT);
  }
  flatbuffers::String *mutable_created_at() {
    return GetPointer<flatbuffers::String *>(VT_CREATED_AT);
  }
  const flatbuffers::String *update_at() const {
    return GetPointer<const flatbuffers::String *>(VT_UPDATE_AT);
  }
  flatbuffers::String *mutable_update_at() {
    return GetPointer<flatbuffers::String *>(VT_UPDATE_AT);
  }
  const flatbuffers::String *map_type() const {
    return GetPointer<const flatbuffers::String *>(VT_MAP_TYPE);
  }
  flatbuffers::String *mutable_map_type() {
    return GetPointer<flatbuffers::String *>(VT_MAP_TYPE);
  }
  float map_size() const {
    return GetField<float>(VT_MAP_SIZE, 0.0f);
  }
  bool mutate_map_size(float _map_size) {
    return SetField<float>(VT_MAP_SIZE, _map_size, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MAP_NAME) &&
           verifier.VerifyString(map_name()) &&
           VerifyOffset(verifier, VT_CREATED_AT) &&
           verifier.VerifyString(created_at()) &&
           VerifyOffset(verifier, VT_UPDATE_AT) &&
           verifier.VerifyString(update_at()) &&
           VerifyOffset(verifier, VT_MAP_TYPE) &&
           verifier.VerifyString(map_type()) &&
           VerifyField<float>(verifier, VT_MAP_SIZE) &&
           verifier.EndTable();
  }
  MapFileInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MapFileInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MapFileInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MapFileInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MapFileInfoBuilder {
  typedef MapFileInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_map_name(flatbuffers::Offset<flatbuffers::String> map_name) {
    fbb_.AddOffset(MapFileInfo::VT_MAP_NAME, map_name);
  }
  void add_created_at(flatbuffers::Offset<flatbuffers::String> created_at) {
    fbb_.AddOffset(MapFileInfo::VT_CREATED_AT, created_at);
  }
  void add_update_at(flatbuffers::Offset<flatbuffers::String> update_at) {
    fbb_.AddOffset(MapFileInfo::VT_UPDATE_AT, update_at);
  }
  void add_map_type(flatbuffers::Offset<flatbuffers::String> map_type) {
    fbb_.AddOffset(MapFileInfo::VT_MAP_TYPE, map_type);
  }
  void add_map_size(float map_size) {
    fbb_.AddElement<float>(MapFileInfo::VT_MAP_SIZE, map_size, 0.0f);
  }
  explicit MapFileInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MapFileInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MapFileInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<MapFileInfo> CreateMapFileInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> map_name = 0,
    flatbuffers::Offset<flatbuffers::String> created_at = 0,
    flatbuffers::Offset<flatbuffers::String> update_at = 0,
    flatbuffers::Offset<flatbuffers::String> map_type = 0,
    float map_size = 0.0f) {
  MapFileInfoBuilder builder_(_fbb);
  builder_.add_map_size(map_size);
  builder_.add_map_type(map_type);
  builder_.add_update_at(update_at);
  builder_.add_created_at(created_at);
  builder_.add_map_name(map_name);
  return builder_.Finish();
}

inline flatbuffers::Offset<MapFileInfo> CreateMapFileInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *map_name = nullptr,
    const char *created_at = nullptr,
    const char *update_at = nullptr,
    const char *map_type = nullptr,
    float map_size = 0.0f) {
  auto map_name__ = map_name ? _fbb.CreateString(map_name) : 0;
  auto created_at__ = created_at ? _fbb.CreateString(created_at) : 0;
  auto update_at__ = update_at ? _fbb.CreateString(update_at) : 0;
  auto map_type__ = map_type ? _fbb.CreateString(map_type) : 0;
  return SLAMNAV::CreateMapFileInfo(
      _fbb,
      map_name__,
      created_at__,
      update_at__,
      map_type__,
      map_size);
}

flatbuffers::Offset<MapFileInfo> CreateMapFileInfo(flatbuffers::FlatBufferBuilder &_fbb, const MapFileInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MapFileT : public flatbuffers::NativeTable {
  typedef MapFile TableType;
  std::string file_name;
  std::string created_at;
  std::string update_at;
  std::string file_type;
  std::unique_ptr<SLAMNAV::MapFileInfoT> cloud_info;
  std::unique_ptr<SLAMNAV::MapFileInfoT> topo_info;
  MapFileT() {
  }
};

struct MapFile FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MapFileT NativeTableType;
  typedef MapFileBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FILE_NAME = 4,
    VT_CREATED_AT = 6,
    VT_UPDATE_AT = 8,
    VT_FILE_TYPE = 10,
    VT_CLOUD_INFO = 12,
    VT_TOPO_INFO = 14
  };
  const flatbuffers::String *file_name() const {
    return GetPointer<const flatbuffers::String *>(VT_FILE_NAME);
  }
  flatbuffers::String *mutable_file_name() {
    return GetPointer<flatbuffers::String *>(VT_FILE_NAME);
  }
  const flatbuffers::String *created_at() const {
    return GetPointer<const flatbuffers::String *>(VT_CREATED_AT);
  }
  flatbuffers::String *mutable_created_at() {
    return GetPointer<flatbuffers::String *>(VT_CREATED_AT);
  }
  const flatbuffers::String *update_at() const {
    return GetPointer<const flatbuffers::String *>(VT_UPDATE_AT);
  }
  flatbuffers::String *mutable_update_at() {
    return GetPointer<flatbuffers::String *>(VT_UPDATE_AT);
  }
  const flatbuffers::String *file_type() const {
    return GetPointer<const flatbuffers::String *>(VT_FILE_TYPE);
  }
  flatbuffers::String *mutable_file_type() {
    return GetPointer<flatbuffers::String *>(VT_FILE_TYPE);
  }
  const SLAMNAV::MapFileInfo *cloud_info() const {
    return GetPointer<const SLAMNAV::MapFileInfo *>(VT_CLOUD_INFO);
  }
  SLAMNAV::MapFileInfo *mutable_cloud_info() {
    return GetPointer<SLAMNAV::MapFileInfo *>(VT_CLOUD_INFO);
  }
  const SLAMNAV::MapFileInfo *topo_info() const {
    return GetPointer<const SLAMNAV::MapFileInfo *>(VT_TOPO_INFO);
  }
  SLAMNAV::MapFileInfo *mutable_topo_info() {
    return GetPointer<SLAMNAV::MapFileInfo *>(VT_TOPO_INFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FILE_NAME) &&
           verifier.VerifyString(file_name()) &&
           VerifyOffset(verifier, VT_CREATED_AT) &&
           verifier.VerifyString(created_at()) &&
           VerifyOffset(verifier, VT_UPDATE_AT) &&
           verifier.VerifyString(update_at()) &&
           VerifyOffset(verifier, VT_FILE_TYPE) &&
           verifier.VerifyString(file_type()) &&
           VerifyOffset(verifier, VT_CLOUD_INFO) &&
           verifier.VerifyTable(cloud_info()) &&
           VerifyOffset(verifier, VT_TOPO_INFO) &&
           verifier.VerifyTable(topo_info()) &&
           verifier.EndTable();
  }
  MapFileT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MapFileT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MapFile> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MapFileT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MapFileBuilder {
  typedef MapFile Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_file_name(flatbuffers::Offset<flatbuffers::String> file_name) {
    fbb_.AddOffset(MapFile::VT_FILE_NAME, file_name);
  }
  void add_created_at(flatbuffers::Offset<flatbuffers::String> created_at) {
    fbb_.AddOffset(MapFile::VT_CREATED_AT, created_at);
  }
  void add_update_at(flatbuffers::Offset<flatbuffers::String> update_at) {
    fbb_.AddOffset(MapFile::VT_UPDATE_AT, update_at);
  }
  void add_file_type(flatbuffers::Offset<flatbuffers::String> file_type) {
    fbb_.AddOffset(MapFile::VT_FILE_TYPE, file_type);
  }
  void add_cloud_info(flatbuffers::Offset<SLAMNAV::MapFileInfo> cloud_info) {
    fbb_.AddOffset(MapFile::VT_CLOUD_INFO, cloud_info);
  }
  void add_topo_info(flatbuffers::Offset<SLAMNAV::MapFileInfo> topo_info) {
    fbb_.AddOffset(MapFile::VT_TOPO_INFO, topo_info);
  }
  explicit MapFileBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MapFile> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MapFile>(end);
    return o;
  }
};

inline flatbuffers::Offset<MapFile> CreateMapFile(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> file_name = 0,
    flatbuffers::Offset<flatbuffers::String> created_at = 0,
    flatbuffers::Offset<flatbuffers::String> update_at = 0,
    flatbuffers::Offset<flatbuffers::String> file_type = 0,
    flatbuffers::Offset<SLAMNAV::MapFileInfo> cloud_info = 0,
    flatbuffers::Offset<SLAMNAV::MapFileInfo> topo_info = 0) {
  MapFileBuilder builder_(_fbb);
  builder_.add_topo_info(topo_info);
  builder_.add_cloud_info(cloud_info);
  builder_.add_file_type(file_type);
  builder_.add_update_at(update_at);
  builder_.add_created_at(created_at);
  builder_.add_file_name(file_name);
  return builder_.Finish();
}

inline flatbuffers::Offset<MapFile> CreateMapFileDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *file_name = nullptr,
    const char *created_at = nullptr,
    const char *update_at = nullptr,
    const char *file_type = nullptr,
    flatbuffers::Offset<SLAMNAV::MapFileInfo> cloud_info = 0,
    flatbuffers::Offset<SLAMNAV::MapFileInfo> topo_info = 0) {
  auto file_name__ = file_name ? _fbb.CreateString(file_name) : 0;
  auto created_at__ = created_at ? _fbb.CreateString(created_at) : 0;
  auto update_at__ = update_at ? _fbb.CreateString(update_at) : 0;
  auto file_type__ = file_type ? _fbb.CreateString(file_type) : 0;
  return SLAMNAV::CreateMapFile(
      _fbb,
      file_name__,
      created_at__,
      update_at__,
      file_type__,
      cloud_info,
      topo_info);
}

flatbuffers::Offset<MapFile> CreateMapFile(flatbuffers::FlatBufferBuilder &_fbb, const MapFileT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Request_Map_ListT : public flatbuffers::NativeTable {
  typedef Request_Map_List TableType;
  std::string id;
  Request_Map_ListT() {
  }
};

struct Request_Map_List FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Request_Map_ListT NativeTableType;
  typedef Request_Map_ListBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  flatbuffers::String *mutable_id() {
    return GetPointer<flatbuffers::String *>(VT_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           verifier.EndTable();
  }
  Request_Map_ListT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_Map_ListT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Request_Map_List> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_Map_ListT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_Map_ListBuilder {
  typedef Request_Map_List Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(Request_Map_List::VT_ID, id);
  }
  explicit Request_Map_ListBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Request_Map_List> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Request_Map_List>(end);
    return o;
  }
};

inline flatbuffers::Offset<Request_Map_List> CreateRequest_Map_List(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> id = 0) {
  Request_Map_ListBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<Request_Map_List> CreateRequest_Map_ListDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  return SLAMNAV::CreateRequest_Map_List(
      _fbb,
      id__);
}

flatbuffers::Offset<Request_Map_List> CreateRequest_Map_List(flatbuffers::FlatBufferBuilder &_fbb, const Request_Map_ListT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Response_Map_ListT : public flatbuffers::NativeTable {
  typedef Response_Map_List TableType;
  std::string id;
  std::vector<std::unique_ptr<SLAMNAV::MapFileT>> list;
  std::string result;
  std::string message;
  Response_Map_ListT() {
  }
};

struct Response_Map_List FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Response_Map_ListT NativeTableType;
  typedef Response_Map_ListBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_LIST = 6,
    VT_RESULT = 8,
    VT_MESSAGE = 10
  };
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  flatbuffers::String *mutable_id() {
    return GetPointer<flatbuffers::String *>(VT_ID);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SLAMNAV::MapFile>> *list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SLAMNAV::MapFile>> *>(VT_LIST);
  }
  flatbuffers::Vector<flatbuffers::Offset<SLAMNAV::MapFile>> *mutable_list() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<SLAMNAV::MapFile>> *>(VT_LIST);
  }
  const flatbuffers::String *result() const {
    return GetPointer<const flatbuffers::String *>(VT_RESULT);
  }
  flatbuffers::String *mutable_result() {
    return GetPointer<flatbuffers::String *>(VT_RESULT);
  }
  const flatbuffers::String *message() const {
    return GetPointer<const flatbuffers::String *>(VT_MESSAGE);
  }
  flatbuffers::String *mutable_message() {
    return GetPointer<flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_LIST) &&
           verifier.VerifyVector(list()) &&
           verifier.VerifyVectorOfTables(list()) &&
           VerifyOffset(verifier, VT_RESULT) &&
           verifier.VerifyString(result()) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
  Response_Map_ListT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Response_Map_ListT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Response_Map_List> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Response_Map_ListT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Response_Map_ListBuilder {
  typedef Response_Map_List Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(Response_Map_List::VT_ID, id);
  }
  void add_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SLAMNAV::MapFile>>> list) {
    fbb_.AddOffset(Response_Map_List::VT_LIST, list);
  }
  void add_result(flatbuffers::Offset<flatbuffers::String> result) {
    fbb_.AddOffset(Response_Map_List::VT_RESULT, result);
  }
  void add_message(flatbuffers::Offset<flatbuffers::String> message) {
    fbb_.AddOffset(Response_Map_List::VT_MESSAGE, message);
  }
  explicit Response_Map_ListBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Response_Map_List> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Response_Map_List>(end);
    return o;
  }
};

inline flatbuffers::Offset<Response_Map_List> CreateResponse_Map_List(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> id = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SLAMNAV::MapFile>>> list = 0,
    flatbuffers::Offset<flatbuffers::String> result = 0,
    flatbuffers::Offset<flatbuffers::String> message = 0) {
  Response_Map_ListBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_result(result);
  builder_.add_list(list);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<Response_Map_List> CreateResponse_Map_ListDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const std::vector<flatbuffers::Offset<SLAMNAV::MapFile>> *list = nullptr,
    const char *result = nullptr,
    const char *message = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto list__ = list ? _fbb.CreateVector<flatbuffers::Offset<SLAMNAV::MapFile>>(*list) : 0;
  auto result__ = result ? _fbb.CreateString(result) : 0;
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return SLAMNAV::CreateResponse_Map_List(
      _fbb,
      id__,
      list__,
      result__,
      message__);
}

flatbuffers::Offset<Response_Map_List> CreateResponse_Map_List(flatbuffers::FlatBufferBuilder &_fbb, const Response_Map_ListT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Request_Map_DeleteT : public flatbuffers::NativeTable {
  typedef Request_Map_Delete TableType;
  std::string id;
  std::string map_name;
  Request_Map_DeleteT() {
  }
};

struct Request_Map_Delete FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Request_Map_DeleteT NativeTableType;
  typedef Request_Map_DeleteBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_MAP_NAME = 6
  };
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  flatbuffers::String *mutable_id() {
    return GetPointer<flatbuffers::String *>(VT_ID);
  }
  const flatbuffers::String *map_name() const {
    return GetPointer<const flatbuffers::String *>(VT_MAP_NAME);
  }
  flatbuffers::String *mutable_map_name() {
    return GetPointer<flatbuffers::String *>(VT_MAP_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_MAP_NAME) &&
           verifier.VerifyString(map_name()) &&
           verifier.EndTable();
  }
  Request_Map_DeleteT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_Map_DeleteT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Request_Map_Delete> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_Map_DeleteT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_Map_DeleteBuilder {
  typedef Request_Map_Delete Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(Request_Map_Delete::VT_ID, id);
  }
  void add_map_name(flatbuffers::Offset<flatbuffers::String> map_name) {
    fbb_.AddOffset(Request_Map_Delete::VT_MAP_NAME, map_name);
  }
  explicit Request_Map_DeleteBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Request_Map_Delete> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Request_Map_Delete>(end);
    return o;
  }
};

inline flatbuffers::Offset<Request_Map_Delete> CreateRequest_Map_Delete(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> id = 0,
    flatbuffers::Offset<flatbuffers::String> map_name = 0) {
  Request_Map_DeleteBuilder builder_(_fbb);
  builder_.add_map_name(map_name);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<Request_Map_Delete> CreateRequest_Map_DeleteDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *map_name = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto map_name__ = map_name ? _fbb.CreateString(map_name) : 0;
  return SLAMNAV::CreateRequest_Map_Delete(
      _fbb,
      id__,
      map_name__);
}

flatbuffers::Offset<Request_Map_Delete> CreateRequest_Map_Delete(flatbuffers::FlatBufferBuilder &_fbb, const Request_Map_DeleteT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Response_Map_DeleteT : public flatbuffers::NativeTable {
  typedef Response_Map_Delete TableType;
  std::string id;
  std::string map_name;
  std::string result;
  std::string message;
  Response_Map_DeleteT() {
  }
};

struct Response_Map_Delete FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Response_Map_DeleteT NativeTableType;
  typedef Response_Map_DeleteBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_MAP_NAME = 6,
    VT_RESULT = 8,
    VT_MESSAGE = 10
  };
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  flatbuffers::String *mutable_id() {
    return GetPointer<flatbuffers::String *>(VT_ID);
  }
  const flatbuffers::String *map_name() const {
    return GetPointer<const flatbuffers::String *>(VT_MAP_NAME);
  }
  flatbuffers::String *mutable_map_name() {
    return GetPointer<flatbuffers::String *>(VT_MAP_NAME);
  }
  const flatbuffers::String *result() const {
    return GetPointer<const flatbuffers::String *>(VT_RESULT);
  }
  flatbuffers::String *mutable_result() {
    return GetPointer<flatbuffers::String *>(VT_RESULT);
  }
  const flatbuffers::String *message() const {
    return GetPointer<const flatbuffers::String *>(VT_MESSAGE);
  }
  flatbuffers::String *mutable_message() {
    return GetPointer<flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_MAP_NAME) &&
           verifier.VerifyString(map_name()) &&
           VerifyOffset(verifier, VT_RESULT) &&
           verifier.VerifyString(result()) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
  Response_Map_DeleteT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Response_Map_DeleteT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Response_Map_Delete> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Response_Map_DeleteT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Response_Map_DeleteBuilder {
  typedef Response_Map_Delete Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(Response_Map_Delete::VT_ID, id);
  }
  void add_map_name(flatbuffers::Offset<flatbuffers::String> map_name) {
    fbb_.AddOffset(Response_Map_Delete::VT_MAP_NAME, map_name);
  }
  void add_result(flatbuffers::Offset<flatbuffers::String> result) {
    fbb_.AddOffset(Response_Map_Delete::VT_RESULT, result);
  }
  void add_message(flatbuffers::Offset<flatbuffers::String> message) {
    fbb_.AddOffset(Response_Map_Delete::VT_MESSAGE, message);
  }
  explicit Response_Map_DeleteBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Response_Map_Delete> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Response_Map_Delete>(end);
    return o;
  }
};

inline flatbuffers::Offset<Response_Map_Delete> CreateResponse_Map_Delete(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> id = 0,
    flatbuffers::Offset<flatbuffers::String> map_name = 0,
    flatbuffers::Offset<flatbuffers::String> result = 0,
    flatbuffers::Offset<flatbuffers::String> message = 0) {
  Response_Map_DeleteBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_result(result);
  builder_.add_map_name(map_name);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<Response_Map_Delete> CreateResponse_Map_DeleteDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *map_name = nullptr,
    const char *result = nullptr,
    const char *message = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto map_name__ = map_name ? _fbb.CreateString(map_name) : 0;
  auto result__ = result ? _fbb.CreateString(result) : 0;
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return SLAMNAV::CreateResponse_Map_Delete(
      _fbb,
      id__,
      map_name__,
      result__,
      message__);
}

flatbuffers::Offset<Response_Map_Delete> CreateResponse_Map_Delete(flatbuffers::FlatBufferBuilder &_fbb, const Response_Map_DeleteT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Request_Map_CurrentT : public flatbuffers::NativeTable {
  typedef Request_Map_Current TableType;
  std::string id;
  Request_Map_CurrentT() {
  }
};

struct Request_Map_Current FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Request_Map_CurrentT NativeTableType;
  typedef Request_Map_CurrentBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  flatbuffers::String *mutable_id() {
    return GetPointer<flatbuffers::String *>(VT_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           verifier.EndTable();
  }
  Request_Map_CurrentT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_Map_CurrentT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Request_Map_Current> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_Map_CurrentT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_Map_CurrentBuilder {
  typedef Request_Map_Current Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(Request_Map_Current::VT_ID, id);
  }
  explicit Request_Map_CurrentBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Request_Map_Current> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Request_Map_Current>(end);
    return o;
  }
};

inline flatbuffers::Offset<Request_Map_Current> CreateRequest_Map_Current(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> id = 0) {
  Request_Map_CurrentBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<Request_Map_Current> CreateRequest_Map_CurrentDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  return SLAMNAV::CreateRequest_Map_Current(
      _fbb,
      id__);
}

flatbuffers::Offset<Request_Map_Current> CreateRequest_Map_Current(flatbuffers::FlatBufferBuilder &_fbb, const Request_Map_CurrentT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Response_Map_CurrentT : public flatbuffers::NativeTable {
  typedef Response_Map_Current TableType;
  std::string id;
  std::string map_name;
  std::string result;
  std::string message;
  Response_Map_CurrentT() {
  }
};

struct Response_Map_Current FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Response_Map_CurrentT NativeTableType;
  typedef Response_Map_CurrentBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_MAP_NAME = 6,
    VT_RESULT = 8,
    VT_MESSAGE = 10
  };
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  flatbuffers::String *mutable_id() {
    return GetPointer<flatbuffers::String *>(VT_ID);
  }
  const flatbuffers::String *map_name() const {
    return GetPointer<const flatbuffers::String *>(VT_MAP_NAME);
  }
  flatbuffers::String *mutable_map_name() {
    return GetPointer<flatbuffers::String *>(VT_MAP_NAME);
  }
  const flatbuffers::String *result() const {
    return GetPointer<const flatbuffers::String *>(VT_RESULT);
  }
  flatbuffers::String *mutable_result() {
    return GetPointer<flatbuffers::String *>(VT_RESULT);
  }
  const flatbuffers::String *message() const {
    return GetPointer<const flatbuffers::String *>(VT_MESSAGE);
  }
  flatbuffers::String *mutable_message() {
    return GetPointer<flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_MAP_NAME) &&
           verifier.VerifyString(map_name()) &&
           VerifyOffset(verifier, VT_RESULT) &&
           verifier.VerifyString(result()) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
  Response_Map_CurrentT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Response_Map_CurrentT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Response_Map_Current> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Response_Map_CurrentT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Response_Map_CurrentBuilder {
  typedef Response_Map_Current Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(Response_Map_Current::VT_ID, id);
  }
  void add_map_name(flatbuffers::Offset<flatbuffers::String> map_name) {
    fbb_.AddOffset(Response_Map_Current::VT_MAP_NAME, map_name);
  }
  void add_result(flatbuffers::Offset<flatbuffers::String> result) {
    fbb_.AddOffset(Response_Map_Current::VT_RESULT, result);
  }
  void add_message(flatbuffers::Offset<flatbuffers::String> message) {
    fbb_.AddOffset(Response_Map_Current::VT_MESSAGE, message);
  }
  explicit Response_Map_CurrentBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Response_Map_Current> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Response_Map_Current>(end);
    return o;
  }
};

inline flatbuffers::Offset<Response_Map_Current> CreateResponse_Map_Current(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> id = 0,
    flatbuffers::Offset<flatbuffers::String> map_name = 0,
    flatbuffers::Offset<flatbuffers::String> result = 0,
    flatbuffers::Offset<flatbuffers::String> message = 0) {
  Response_Map_CurrentBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_result(result);
  builder_.add_map_name(map_name);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<Response_Map_Current> CreateResponse_Map_CurrentDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *map_name = nullptr,
    const char *result = nullptr,
    const char *message = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto map_name__ = map_name ? _fbb.CreateString(map_name) : 0;
  auto result__ = result ? _fbb.CreateString(result) : 0;
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return SLAMNAV::CreateResponse_Map_Current(
      _fbb,
      id__,
      map_name__,
      result__,
      message__);
}

flatbuffers::Offset<Response_Map_Current> CreateResponse_Map_Current(flatbuffers::FlatBufferBuilder &_fbb, const Response_Map_CurrentT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Request_Map_LoadT : public flatbuffers::NativeTable {
  typedef Request_Map_Load TableType;
  std::string id;
  std::string map_name;
  Request_Map_LoadT() {
  }
};

struct Request_Map_Load FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Request_Map_LoadT NativeTableType;
  typedef Request_Map_LoadBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_MAP_NAME = 6
  };
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  flatbuffers::String *mutable_id() {
    return GetPointer<flatbuffers::String *>(VT_ID);
  }
  const flatbuffers::String *map_name() const {
    return GetPointer<const flatbuffers::String *>(VT_MAP_NAME);
  }
  flatbuffers::String *mutable_map_name() {
    return GetPointer<flatbuffers::String *>(VT_MAP_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_MAP_NAME) &&
           verifier.VerifyString(map_name()) &&
           verifier.EndTable();
  }
  Request_Map_LoadT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_Map_LoadT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Request_Map_Load> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_Map_LoadT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_Map_LoadBuilder {
  typedef Request_Map_Load Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(Request_Map_Load::VT_ID, id);
  }
  void add_map_name(flatbuffers::Offset<flatbuffers::String> map_name) {
    fbb_.AddOffset(Request_Map_Load::VT_MAP_NAME, map_name);
  }
  explicit Request_Map_LoadBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Request_Map_Load> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Request_Map_Load>(end);
    return o;
  }
};

inline flatbuffers::Offset<Request_Map_Load> CreateRequest_Map_Load(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> id = 0,
    flatbuffers::Offset<flatbuffers::String> map_name = 0) {
  Request_Map_LoadBuilder builder_(_fbb);
  builder_.add_map_name(map_name);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<Request_Map_Load> CreateRequest_Map_LoadDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *map_name = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto map_name__ = map_name ? _fbb.CreateString(map_name) : 0;
  return SLAMNAV::CreateRequest_Map_Load(
      _fbb,
      id__,
      map_name__);
}

flatbuffers::Offset<Request_Map_Load> CreateRequest_Map_Load(flatbuffers::FlatBufferBuilder &_fbb, const Request_Map_LoadT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Response_Map_LoadT : public flatbuffers::NativeTable {
  typedef Response_Map_Load TableType;
  std::string id;
  std::string map_name;
  std::string result;
  std::string message;
  Response_Map_LoadT() {
  }
};

struct Response_Map_Load FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Response_Map_LoadT NativeTableType;
  typedef Response_Map_LoadBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_MAP_NAME = 6,
    VT_RESULT = 8,
    VT_MESSAGE = 10
  };
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  flatbuffers::String *mutable_id() {
    return GetPointer<flatbuffers::String *>(VT_ID);
  }
  const flatbuffers::String *map_name() const {
    return GetPointer<const flatbuffers::String *>(VT_MAP_NAME);
  }
  flatbuffers::String *mutable_map_name() {
    return GetPointer<flatbuffers::String *>(VT_MAP_NAME);
  }
  const flatbuffers::String *result() const {
    return GetPointer<const flatbuffers::String *>(VT_RESULT);
  }
  flatbuffers::String *mutable_result() {
    return GetPointer<flatbuffers::String *>(VT_RESULT);
  }
  const flatbuffers::String *message() const {
    return GetPointer<const flatbuffers::String *>(VT_MESSAGE);
  }
  flatbuffers::String *mutable_message() {
    return GetPointer<flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_MAP_NAME) &&
           verifier.VerifyString(map_name()) &&
           VerifyOffset(verifier, VT_RESULT) &&
           verifier.VerifyString(result()) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
  Response_Map_LoadT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Response_Map_LoadT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Response_Map_Load> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Response_Map_LoadT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Response_Map_LoadBuilder {
  typedef Response_Map_Load Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(Response_Map_Load::VT_ID, id);
  }
  void add_map_name(flatbuffers::Offset<flatbuffers::String> map_name) {
    fbb_.AddOffset(Response_Map_Load::VT_MAP_NAME, map_name);
  }
  void add_result(flatbuffers::Offset<flatbuffers::String> result) {
    fbb_.AddOffset(Response_Map_Load::VT_RESULT, result);
  }
  void add_message(flatbuffers::Offset<flatbuffers::String> message) {
    fbb_.AddOffset(Response_Map_Load::VT_MESSAGE, message);
  }
  explicit Response_Map_LoadBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Response_Map_Load> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Response_Map_Load>(end);
    return o;
  }
};

inline flatbuffers::Offset<Response_Map_Load> CreateResponse_Map_Load(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> id = 0,
    flatbuffers::Offset<flatbuffers::String> map_name = 0,
    flatbuffers::Offset<flatbuffers::String> result = 0,
    flatbuffers::Offset<flatbuffers::String> message = 0) {
  Response_Map_LoadBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_result(result);
  builder_.add_map_name(map_name);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<Response_Map_Load> CreateResponse_Map_LoadDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *map_name = nullptr,
    const char *result = nullptr,
    const char *message = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto map_name__ = map_name ? _fbb.CreateString(map_name) : 0;
  auto result__ = result ? _fbb.CreateString(result) : 0;
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return SLAMNAV::CreateResponse_Map_Load(
      _fbb,
      id__,
      map_name__,
      result__,
      message__);
}

flatbuffers::Offset<Response_Map_Load> CreateResponse_Map_Load(flatbuffers::FlatBufferBuilder &_fbb, const Response_Map_LoadT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Request_Get_Map_FileT : public flatbuffers::NativeTable {
  typedef Request_Get_Map_File TableType;
  std::string id;
  std::string map_name;
  std::string file_name;
  Request_Get_Map_FileT() {
  }
};

struct Request_Get_Map_File FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Request_Get_Map_FileT NativeTableType;
  typedef Request_Get_Map_FileBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_MAP_NAME = 6,
    VT_FILE_NAME = 8
  };
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  flatbuffers::String *mutable_id() {
    return GetPointer<flatbuffers::String *>(VT_ID);
  }
  const flatbuffers::String *map_name() const {
    return GetPointer<const flatbuffers::String *>(VT_MAP_NAME);
  }
  flatbuffers::String *mutable_map_name() {
    return GetPointer<flatbuffers::String *>(VT_MAP_NAME);
  }
  const flatbuffers::String *file_name() const {
    return GetPointer<const flatbuffers::String *>(VT_FILE_NAME);
  }
  flatbuffers::String *mutable_file_name() {
    return GetPointer<flatbuffers::String *>(VT_FILE_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_MAP_NAME) &&
           verifier.VerifyString(map_name()) &&
           VerifyOffset(verifier, VT_FILE_NAME) &&
           verifier.VerifyString(file_name()) &&
           verifier.EndTable();
  }
  Request_Get_Map_FileT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_Get_Map_FileT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Request_Get_Map_File> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_Get_Map_FileT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_Get_Map_FileBuilder {
  typedef Request_Get_Map_File Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(Request_Get_Map_File::VT_ID, id);
  }
  void add_map_name(flatbuffers::Offset<flatbuffers::String> map_name) {
    fbb_.AddOffset(Request_Get_Map_File::VT_MAP_NAME, map_name);
  }
  void add_file_name(flatbuffers::Offset<flatbuffers::String> file_name) {
    fbb_.AddOffset(Request_Get_Map_File::VT_FILE_NAME, file_name);
  }
  explicit Request_Get_Map_FileBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Request_Get_Map_File> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Request_Get_Map_File>(end);
    return o;
  }
};

inline flatbuffers::Offset<Request_Get_Map_File> CreateRequest_Get_Map_File(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> id = 0,
    flatbuffers::Offset<flatbuffers::String> map_name = 0,
    flatbuffers::Offset<flatbuffers::String> file_name = 0) {
  Request_Get_Map_FileBuilder builder_(_fbb);
  builder_.add_file_name(file_name);
  builder_.add_map_name(map_name);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<Request_Get_Map_File> CreateRequest_Get_Map_FileDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *map_name = nullptr,
    const char *file_name = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto map_name__ = map_name ? _fbb.CreateString(map_name) : 0;
  auto file_name__ = file_name ? _fbb.CreateString(file_name) : 0;
  return SLAMNAV::CreateRequest_Get_Map_File(
      _fbb,
      id__,
      map_name__,
      file_name__);
}

flatbuffers::Offset<Request_Get_Map_File> CreateRequest_Get_Map_File(flatbuffers::FlatBufferBuilder &_fbb, const Request_Get_Map_FileT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Response_Get_Map_FileT : public flatbuffers::NativeTable {
  typedef Response_Get_Map_File TableType;
  std::string id;
  std::string map_name;
  std::string file_name;
  uint32_t size;
  std::vector<SLAMNAV::CloudData> data;
  std::string result;
  std::string message;
  Response_Get_Map_FileT()
      : size(0) {
  }
};

struct Response_Get_Map_File FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Response_Get_Map_FileT NativeTableType;
  typedef Response_Get_Map_FileBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_MAP_NAME = 6,
    VT_FILE_NAME = 8,
    VT_SIZE = 10,
    VT_DATA = 12,
    VT_RESULT = 14,
    VT_MESSAGE = 16
  };
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  flatbuffers::String *mutable_id() {
    return GetPointer<flatbuffers::String *>(VT_ID);
  }
  const flatbuffers::String *map_name() const {
    return GetPointer<const flatbuffers::String *>(VT_MAP_NAME);
  }
  flatbuffers::String *mutable_map_name() {
    return GetPointer<flatbuffers::String *>(VT_MAP_NAME);
  }
  const flatbuffers::String *file_name() const {
    return GetPointer<const flatbuffers::String *>(VT_FILE_NAME);
  }
  flatbuffers::String *mutable_file_name() {
    return GetPointer<flatbuffers::String *>(VT_FILE_NAME);
  }
  uint32_t size() const {
    return GetField<uint32_t>(VT_SIZE, 0);
  }
  bool mutate_size(uint32_t _size) {
    return SetField<uint32_t>(VT_SIZE, _size, 0);
  }
  const flatbuffers::Vector<const SLAMNAV::CloudData *> *data() const {
    return GetPointer<const flatbuffers::Vector<const SLAMNAV::CloudData *> *>(VT_DATA);
  }
  flatbuffers::Vector<const SLAMNAV::CloudData *> *mutable_data() {
    return GetPointer<flatbuffers::Vector<const SLAMNAV::CloudData *> *>(VT_DATA);
  }
  const flatbuffers::String *result() const {
    return GetPointer<const flatbuffers::String *>(VT_RESULT);
  }
  flatbuffers::String *mutable_result() {
    return GetPointer<flatbuffers::String *>(VT_RESULT);
  }
  const flatbuffers::String *message() const {
    return GetPointer<const flatbuffers::String *>(VT_MESSAGE);
  }
  flatbuffers::String *mutable_message() {
    return GetPointer<flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_MAP_NAME) &&
           verifier.VerifyString(map_name()) &&
           VerifyOffset(verifier, VT_FILE_NAME) &&
           verifier.VerifyString(file_name()) &&
           VerifyField<uint32_t>(verifier, VT_SIZE) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           VerifyOffset(verifier, VT_RESULT) &&
           verifier.VerifyString(result()) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
  Response_Get_Map_FileT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Response_Get_Map_FileT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Response_Get_Map_File> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Response_Get_Map_FileT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Response_Get_Map_FileBuilder {
  typedef Response_Get_Map_File Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(Response_Get_Map_File::VT_ID, id);
  }
  void add_map_name(flatbuffers::Offset<flatbuffers::String> map_name) {
    fbb_.AddOffset(Response_Get_Map_File::VT_MAP_NAME, map_name);
  }
  void add_file_name(flatbuffers::Offset<flatbuffers::String> file_name) {
    fbb_.AddOffset(Response_Get_Map_File::VT_FILE_NAME, file_name);
  }
  void add_size(uint32_t size) {
    fbb_.AddElement<uint32_t>(Response_Get_Map_File::VT_SIZE, size, 0);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<const SLAMNAV::CloudData *>> data) {
    fbb_.AddOffset(Response_Get_Map_File::VT_DATA, data);
  }
  void add_result(flatbuffers::Offset<flatbuffers::String> result) {
    fbb_.AddOffset(Response_Get_Map_File::VT_RESULT, result);
  }
  void add_message(flatbuffers::Offset<flatbuffers::String> message) {
    fbb_.AddOffset(Response_Get_Map_File::VT_MESSAGE, message);
  }
  explicit Response_Get_Map_FileBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Response_Get_Map_File> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Response_Get_Map_File>(end);
    return o;
  }
};

inline flatbuffers::Offset<Response_Get_Map_File> CreateResponse_Get_Map_File(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> id = 0,
    flatbuffers::Offset<flatbuffers::String> map_name = 0,
    flatbuffers::Offset<flatbuffers::String> file_name = 0,
    uint32_t size = 0,
    flatbuffers::Offset<flatbuffers::Vector<const SLAMNAV::CloudData *>> data = 0,
    flatbuffers::Offset<flatbuffers::String> result = 0,
    flatbuffers::Offset<flatbuffers::String> message = 0) {
  Response_Get_Map_FileBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_result(result);
  builder_.add_data(data);
  builder_.add_size(size);
  builder_.add_file_name(file_name);
  builder_.add_map_name(map_name);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<Response_Get_Map_File> CreateResponse_Get_Map_FileDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *map_name = nullptr,
    const char *file_name = nullptr,
    uint32_t size = 0,
    const std::vector<SLAMNAV::CloudData> *data = nullptr,
    const char *result = nullptr,
    const char *message = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto map_name__ = map_name ? _fbb.CreateString(map_name) : 0;
  auto file_name__ = file_name ? _fbb.CreateString(file_name) : 0;
  auto data__ = data ? _fbb.CreateVectorOfStructs<SLAMNAV::CloudData>(*data) : 0;
  auto result__ = result ? _fbb.CreateString(result) : 0;
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return SLAMNAV::CreateResponse_Get_Map_File(
      _fbb,
      id__,
      map_name__,
      file_name__,
      size,
      data__,
      result__,
      message__);
}

flatbuffers::Offset<Response_Get_Map_File> CreateResponse_Get_Map_File(flatbuffers::FlatBufferBuilder &_fbb, const Response_Get_Map_FileT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LinkT : public flatbuffers::NativeTable {
  typedef Link TableType;
  std::string id;
  std::string info;
  float speed;
  std::string method;
  int32_t safety_field;
  LinkT()
      : speed(0.0f),
        safety_field(0) {
  }
};

struct Link FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LinkT NativeTableType;
  typedef LinkBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_INFO = 6,
    VT_SPEED = 8,
    VT_METHOD = 10,
    VT_SAFETY_FIELD = 12
  };
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  flatbuffers::String *mutable_id() {
    return GetPointer<flatbuffers::String *>(VT_ID);
  }
  const flatbuffers::String *info() const {
    return GetPointer<const flatbuffers::String *>(VT_INFO);
  }
  flatbuffers::String *mutable_info() {
    return GetPointer<flatbuffers::String *>(VT_INFO);
  }
  float speed() const {
    return GetField<float>(VT_SPEED, 0.0f);
  }
  bool mutate_speed(float _speed) {
    return SetField<float>(VT_SPEED, _speed, 0.0f);
  }
  const flatbuffers::String *method() const {
    return GetPointer<const flatbuffers::String *>(VT_METHOD);
  }
  flatbuffers::String *mutable_method() {
    return GetPointer<flatbuffers::String *>(VT_METHOD);
  }
  int32_t safety_field() const {
    return GetField<int32_t>(VT_SAFETY_FIELD, 0);
  }
  bool mutate_safety_field(int32_t _safety_field) {
    return SetField<int32_t>(VT_SAFETY_FIELD, _safety_field, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_INFO) &&
           verifier.VerifyString(info()) &&
           VerifyField<float>(verifier, VT_SPEED) &&
           VerifyOffset(verifier, VT_METHOD) &&
           verifier.VerifyString(method()) &&
           VerifyField<int32_t>(verifier, VT_SAFETY_FIELD) &&
           verifier.EndTable();
  }
  LinkT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LinkT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Link> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LinkT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LinkBuilder {
  typedef Link Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(Link::VT_ID, id);
  }
  void add_info(flatbuffers::Offset<flatbuffers::String> info) {
    fbb_.AddOffset(Link::VT_INFO, info);
  }
  void add_speed(float speed) {
    fbb_.AddElement<float>(Link::VT_SPEED, speed, 0.0f);
  }
  void add_method(flatbuffers::Offset<flatbuffers::String> method) {
    fbb_.AddOffset(Link::VT_METHOD, method);
  }
  void add_safety_field(int32_t safety_field) {
    fbb_.AddElement<int32_t>(Link::VT_SAFETY_FIELD, safety_field, 0);
  }
  explicit LinkBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Link> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Link>(end);
    return o;
  }
};

inline flatbuffers::Offset<Link> CreateLink(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> id = 0,
    flatbuffers::Offset<flatbuffers::String> info = 0,
    float speed = 0.0f,
    flatbuffers::Offset<flatbuffers::String> method = 0,
    int32_t safety_field = 0) {
  LinkBuilder builder_(_fbb);
  builder_.add_safety_field(safety_field);
  builder_.add_method(method);
  builder_.add_speed(speed);
  builder_.add_info(info);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<Link> CreateLinkDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *info = nullptr,
    float speed = 0.0f,
    const char *method = nullptr,
    int32_t safety_field = 0) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto info__ = info ? _fbb.CreateString(info) : 0;
  auto method__ = method ? _fbb.CreateString(method) : 0;
  return SLAMNAV::CreateLink(
      _fbb,
      id__,
      info__,
      speed,
      method__,
      safety_field);
}

flatbuffers::Offset<Link> CreateLink(flatbuffers::FlatBufferBuilder &_fbb, const LinkT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NodeT : public flatbuffers::NativeTable {
  typedef Node TableType;
  std::string id;
  std::string name;
  std::vector<float> pose;
  std::string info;
  std::vector<std::unique_ptr<SLAMNAV::LinkT>> links;
  std::string type;
  NodeT() {
  }
};

struct Node FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NodeT NativeTableType;
  typedef NodeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_NAME = 6,
    VT_POSE = 8,
    VT_INFO = 10,
    VT_LINKS = 12,
    VT_TYPE = 14
  };
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  flatbuffers::String *mutable_id() {
    return GetPointer<flatbuffers::String *>(VT_ID);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers::String *mutable_name() {
    return GetPointer<flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<float> *pose() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_POSE);
  }
  flatbuffers::Vector<float> *mutable_pose() {
    return GetPointer<flatbuffers::Vector<float> *>(VT_POSE);
  }
  const flatbuffers::String *info() const {
    return GetPointer<const flatbuffers::String *>(VT_INFO);
  }
  flatbuffers::String *mutable_info() {
    return GetPointer<flatbuffers::String *>(VT_INFO);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SLAMNAV::Link>> *links() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SLAMNAV::Link>> *>(VT_LINKS);
  }
  flatbuffers::Vector<flatbuffers::Offset<SLAMNAV::Link>> *mutable_links() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<SLAMNAV::Link>> *>(VT_LINKS);
  }
  const flatbuffers::String *type() const {
    return GetPointer<const flatbuffers::String *>(VT_TYPE);
  }
  flatbuffers::String *mutable_type() {
    return GetPointer<flatbuffers::String *>(VT_TYPE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_POSE) &&
           verifier.VerifyVector(pose()) &&
           VerifyOffset(verifier, VT_INFO) &&
           verifier.VerifyString(info()) &&
           VerifyOffset(verifier, VT_LINKS) &&
           verifier.VerifyVector(links()) &&
           verifier.VerifyVectorOfTables(links()) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyString(type()) &&
           verifier.EndTable();
  }
  NodeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NodeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Node> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NodeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NodeBuilder {
  typedef Node Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(Node::VT_ID, id);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Node::VT_NAME, name);
  }
  void add_pose(flatbuffers::Offset<flatbuffers::Vector<float>> pose) {
    fbb_.AddOffset(Node::VT_POSE, pose);
  }
  void add_info(flatbuffers::Offset<flatbuffers::String> info) {
    fbb_.AddOffset(Node::VT_INFO, info);
  }
  void add_links(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SLAMNAV::Link>>> links) {
    fbb_.AddOffset(Node::VT_LINKS, links);
  }
  void add_type(flatbuffers::Offset<flatbuffers::String> type) {
    fbb_.AddOffset(Node::VT_TYPE, type);
  }
  explicit NodeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Node> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Node>(end);
    return o;
  }
};

inline flatbuffers::Offset<Node> CreateNode(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> id = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> pose = 0,
    flatbuffers::Offset<flatbuffers::String> info = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SLAMNAV::Link>>> links = 0,
    flatbuffers::Offset<flatbuffers::String> type = 0) {
  NodeBuilder builder_(_fbb);
  builder_.add_type(type);
  builder_.add_links(links);
  builder_.add_info(info);
  builder_.add_pose(pose);
  builder_.add_name(name);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<Node> CreateNodeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *name = nullptr,
    const std::vector<float> *pose = nullptr,
    const char *info = nullptr,
    const std::vector<flatbuffers::Offset<SLAMNAV::Link>> *links = nullptr,
    const char *type = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto pose__ = pose ? _fbb.CreateVector<float>(*pose) : 0;
  auto info__ = info ? _fbb.CreateString(info) : 0;
  auto links__ = links ? _fbb.CreateVector<flatbuffers::Offset<SLAMNAV::Link>>(*links) : 0;
  auto type__ = type ? _fbb.CreateString(type) : 0;
  return SLAMNAV::CreateNode(
      _fbb,
      id__,
      name__,
      pose__,
      info__,
      links__,
      type__);
}

flatbuffers::Offset<Node> CreateNode(flatbuffers::FlatBufferBuilder &_fbb, const NodeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Request_Get_Map_CloudT : public flatbuffers::NativeTable {
  typedef Request_Get_Map_Cloud TableType;
  std::string id;
  std::string map_name;
  std::string file_name;
  Request_Get_Map_CloudT() {
  }
};

struct Request_Get_Map_Cloud FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Request_Get_Map_CloudT NativeTableType;
  typedef Request_Get_Map_CloudBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_MAP_NAME = 6,
    VT_FILE_NAME = 8
  };
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  flatbuffers::String *mutable_id() {
    return GetPointer<flatbuffers::String *>(VT_ID);
  }
  const flatbuffers::String *map_name() const {
    return GetPointer<const flatbuffers::String *>(VT_MAP_NAME);
  }
  flatbuffers::String *mutable_map_name() {
    return GetPointer<flatbuffers::String *>(VT_MAP_NAME);
  }
  const flatbuffers::String *file_name() const {
    return GetPointer<const flatbuffers::String *>(VT_FILE_NAME);
  }
  flatbuffers::String *mutable_file_name() {
    return GetPointer<flatbuffers::String *>(VT_FILE_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_MAP_NAME) &&
           verifier.VerifyString(map_name()) &&
           VerifyOffset(verifier, VT_FILE_NAME) &&
           verifier.VerifyString(file_name()) &&
           verifier.EndTable();
  }
  Request_Get_Map_CloudT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_Get_Map_CloudT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Request_Get_Map_Cloud> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_Get_Map_CloudT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_Get_Map_CloudBuilder {
  typedef Request_Get_Map_Cloud Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(Request_Get_Map_Cloud::VT_ID, id);
  }
  void add_map_name(flatbuffers::Offset<flatbuffers::String> map_name) {
    fbb_.AddOffset(Request_Get_Map_Cloud::VT_MAP_NAME, map_name);
  }
  void add_file_name(flatbuffers::Offset<flatbuffers::String> file_name) {
    fbb_.AddOffset(Request_Get_Map_Cloud::VT_FILE_NAME, file_name);
  }
  explicit Request_Get_Map_CloudBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Request_Get_Map_Cloud> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Request_Get_Map_Cloud>(end);
    return o;
  }
};

inline flatbuffers::Offset<Request_Get_Map_Cloud> CreateRequest_Get_Map_Cloud(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> id = 0,
    flatbuffers::Offset<flatbuffers::String> map_name = 0,
    flatbuffers::Offset<flatbuffers::String> file_name = 0) {
  Request_Get_Map_CloudBuilder builder_(_fbb);
  builder_.add_file_name(file_name);
  builder_.add_map_name(map_name);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<Request_Get_Map_Cloud> CreateRequest_Get_Map_CloudDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *map_name = nullptr,
    const char *file_name = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto map_name__ = map_name ? _fbb.CreateString(map_name) : 0;
  auto file_name__ = file_name ? _fbb.CreateString(file_name) : 0;
  return SLAMNAV::CreateRequest_Get_Map_Cloud(
      _fbb,
      id__,
      map_name__,
      file_name__);
}

flatbuffers::Offset<Request_Get_Map_Cloud> CreateRequest_Get_Map_Cloud(flatbuffers::FlatBufferBuilder &_fbb, const Request_Get_Map_CloudT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Response_Get_Map_CloudT : public flatbuffers::NativeTable {
  typedef Response_Get_Map_Cloud TableType;
  std::string id;
  std::string map_name;
  std::string file_name;
  uint32_t size;
  std::vector<SLAMNAV::CloudData> data;
  std::string result;
  std::string message;
  Response_Get_Map_CloudT()
      : size(0) {
  }
};

struct Response_Get_Map_Cloud FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Response_Get_Map_CloudT NativeTableType;
  typedef Response_Get_Map_CloudBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_MAP_NAME = 6,
    VT_FILE_NAME = 8,
    VT_SIZE = 10,
    VT_DATA = 12,
    VT_RESULT = 14,
    VT_MESSAGE = 16
  };
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  flatbuffers::String *mutable_id() {
    return GetPointer<flatbuffers::String *>(VT_ID);
  }
  const flatbuffers::String *map_name() const {
    return GetPointer<const flatbuffers::String *>(VT_MAP_NAME);
  }
  flatbuffers::String *mutable_map_name() {
    return GetPointer<flatbuffers::String *>(VT_MAP_NAME);
  }
  const flatbuffers::String *file_name() const {
    return GetPointer<const flatbuffers::String *>(VT_FILE_NAME);
  }
  flatbuffers::String *mutable_file_name() {
    return GetPointer<flatbuffers::String *>(VT_FILE_NAME);
  }
  uint32_t size() const {
    return GetField<uint32_t>(VT_SIZE, 0);
  }
  bool mutate_size(uint32_t _size) {
    return SetField<uint32_t>(VT_SIZE, _size, 0);
  }
  const flatbuffers::Vector<const SLAMNAV::CloudData *> *data() const {
    return GetPointer<const flatbuffers::Vector<const SLAMNAV::CloudData *> *>(VT_DATA);
  }
  flatbuffers::Vector<const SLAMNAV::CloudData *> *mutable_data() {
    return GetPointer<flatbuffers::Vector<const SLAMNAV::CloudData *> *>(VT_DATA);
  }
  const flatbuffers::String *result() const {
    return GetPointer<const flatbuffers::String *>(VT_RESULT);
  }
  flatbuffers::String *mutable_result() {
    return GetPointer<flatbuffers::String *>(VT_RESULT);
  }
  const flatbuffers::String *message() const {
    return GetPointer<const flatbuffers::String *>(VT_MESSAGE);
  }
  flatbuffers::String *mutable_message() {
    return GetPointer<flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_MAP_NAME) &&
           verifier.VerifyString(map_name()) &&
           VerifyOffset(verifier, VT_FILE_NAME) &&
           verifier.VerifyString(file_name()) &&
           VerifyField<uint32_t>(verifier, VT_SIZE) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           VerifyOffset(verifier, VT_RESULT) &&
           verifier.VerifyString(result()) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
  Response_Get_Map_CloudT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Response_Get_Map_CloudT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Response_Get_Map_Cloud> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Response_Get_Map_CloudT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Response_Get_Map_CloudBuilder {
  typedef Response_Get_Map_Cloud Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(Response_Get_Map_Cloud::VT_ID, id);
  }
  void add_map_name(flatbuffers::Offset<flatbuffers::String> map_name) {
    fbb_.AddOffset(Response_Get_Map_Cloud::VT_MAP_NAME, map_name);
  }
  void add_file_name(flatbuffers::Offset<flatbuffers::String> file_name) {
    fbb_.AddOffset(Response_Get_Map_Cloud::VT_FILE_NAME, file_name);
  }
  void add_size(uint32_t size) {
    fbb_.AddElement<uint32_t>(Response_Get_Map_Cloud::VT_SIZE, size, 0);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<const SLAMNAV::CloudData *>> data) {
    fbb_.AddOffset(Response_Get_Map_Cloud::VT_DATA, data);
  }
  void add_result(flatbuffers::Offset<flatbuffers::String> result) {
    fbb_.AddOffset(Response_Get_Map_Cloud::VT_RESULT, result);
  }
  void add_message(flatbuffers::Offset<flatbuffers::String> message) {
    fbb_.AddOffset(Response_Get_Map_Cloud::VT_MESSAGE, message);
  }
  explicit Response_Get_Map_CloudBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Response_Get_Map_Cloud> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Response_Get_Map_Cloud>(end);
    return o;
  }
};

inline flatbuffers::Offset<Response_Get_Map_Cloud> CreateResponse_Get_Map_Cloud(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> id = 0,
    flatbuffers::Offset<flatbuffers::String> map_name = 0,
    flatbuffers::Offset<flatbuffers::String> file_name = 0,
    uint32_t size = 0,
    flatbuffers::Offset<flatbuffers::Vector<const SLAMNAV::CloudData *>> data = 0,
    flatbuffers::Offset<flatbuffers::String> result = 0,
    flatbuffers::Offset<flatbuffers::String> message = 0) {
  Response_Get_Map_CloudBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_result(result);
  builder_.add_data(data);
  builder_.add_size(size);
  builder_.add_file_name(file_name);
  builder_.add_map_name(map_name);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<Response_Get_Map_Cloud> CreateResponse_Get_Map_CloudDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *map_name = nullptr,
    const char *file_name = nullptr,
    uint32_t size = 0,
    const std::vector<SLAMNAV::CloudData> *data = nullptr,
    const char *result = nullptr,
    const char *message = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto map_name__ = map_name ? _fbb.CreateString(map_name) : 0;
  auto file_name__ = file_name ? _fbb.CreateString(file_name) : 0;
  auto data__ = data ? _fbb.CreateVectorOfStructs<SLAMNAV::CloudData>(*data) : 0;
  auto result__ = result ? _fbb.CreateString(result) : 0;
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return SLAMNAV::CreateResponse_Get_Map_Cloud(
      _fbb,
      id__,
      map_name__,
      file_name__,
      size,
      data__,
      result__,
      message__);
}

flatbuffers::Offset<Response_Get_Map_Cloud> CreateResponse_Get_Map_Cloud(flatbuffers::FlatBufferBuilder &_fbb, const Response_Get_Map_CloudT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Request_Set_Map_CloudT : public flatbuffers::NativeTable {
  typedef Request_Set_Map_Cloud TableType;
  std::string id;
  std::string map_name;
  std::string file_name;
  uint32_t size;
  std::vector<SLAMNAV::CloudData> data;
  Request_Set_Map_CloudT()
      : size(0) {
  }
};

struct Request_Set_Map_Cloud FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Request_Set_Map_CloudT NativeTableType;
  typedef Request_Set_Map_CloudBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_MAP_NAME = 6,
    VT_FILE_NAME = 8,
    VT_SIZE = 10,
    VT_DATA = 12
  };
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  flatbuffers::String *mutable_id() {
    return GetPointer<flatbuffers::String *>(VT_ID);
  }
  const flatbuffers::String *map_name() const {
    return GetPointer<const flatbuffers::String *>(VT_MAP_NAME);
  }
  flatbuffers::String *mutable_map_name() {
    return GetPointer<flatbuffers::String *>(VT_MAP_NAME);
  }
  const flatbuffers::String *file_name() const {
    return GetPointer<const flatbuffers::String *>(VT_FILE_NAME);
  }
  flatbuffers::String *mutable_file_name() {
    return GetPointer<flatbuffers::String *>(VT_FILE_NAME);
  }
  uint32_t size() const {
    return GetField<uint32_t>(VT_SIZE, 0);
  }
  bool mutate_size(uint32_t _size) {
    return SetField<uint32_t>(VT_SIZE, _size, 0);
  }
  const flatbuffers::Vector<const SLAMNAV::CloudData *> *data() const {
    return GetPointer<const flatbuffers::Vector<const SLAMNAV::CloudData *> *>(VT_DATA);
  }
  flatbuffers::Vector<const SLAMNAV::CloudData *> *mutable_data() {
    return GetPointer<flatbuffers::Vector<const SLAMNAV::CloudData *> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_MAP_NAME) &&
           verifier.VerifyString(map_name()) &&
           VerifyOffset(verifier, VT_FILE_NAME) &&
           verifier.VerifyString(file_name()) &&
           VerifyField<uint32_t>(verifier, VT_SIZE) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
  Request_Set_Map_CloudT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_Set_Map_CloudT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Request_Set_Map_Cloud> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_Set_Map_CloudT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_Set_Map_CloudBuilder {
  typedef Request_Set_Map_Cloud Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(Request_Set_Map_Cloud::VT_ID, id);
  }
  void add_map_name(flatbuffers::Offset<flatbuffers::String> map_name) {
    fbb_.AddOffset(Request_Set_Map_Cloud::VT_MAP_NAME, map_name);
  }
  void add_file_name(flatbuffers::Offset<flatbuffers::String> file_name) {
    fbb_.AddOffset(Request_Set_Map_Cloud::VT_FILE_NAME, file_name);
  }
  void add_size(uint32_t size) {
    fbb_.AddElement<uint32_t>(Request_Set_Map_Cloud::VT_SIZE, size, 0);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<const SLAMNAV::CloudData *>> data) {
    fbb_.AddOffset(Request_Set_Map_Cloud::VT_DATA, data);
  }
  explicit Request_Set_Map_CloudBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Request_Set_Map_Cloud> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Request_Set_Map_Cloud>(end);
    return o;
  }
};

inline flatbuffers::Offset<Request_Set_Map_Cloud> CreateRequest_Set_Map_Cloud(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> id = 0,
    flatbuffers::Offset<flatbuffers::String> map_name = 0,
    flatbuffers::Offset<flatbuffers::String> file_name = 0,
    uint32_t size = 0,
    flatbuffers::Offset<flatbuffers::Vector<const SLAMNAV::CloudData *>> data = 0) {
  Request_Set_Map_CloudBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_size(size);
  builder_.add_file_name(file_name);
  builder_.add_map_name(map_name);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<Request_Set_Map_Cloud> CreateRequest_Set_Map_CloudDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *map_name = nullptr,
    const char *file_name = nullptr,
    uint32_t size = 0,
    const std::vector<SLAMNAV::CloudData> *data = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto map_name__ = map_name ? _fbb.CreateString(map_name) : 0;
  auto file_name__ = file_name ? _fbb.CreateString(file_name) : 0;
  auto data__ = data ? _fbb.CreateVectorOfStructs<SLAMNAV::CloudData>(*data) : 0;
  return SLAMNAV::CreateRequest_Set_Map_Cloud(
      _fbb,
      id__,
      map_name__,
      file_name__,
      size,
      data__);
}

flatbuffers::Offset<Request_Set_Map_Cloud> CreateRequest_Set_Map_Cloud(flatbuffers::FlatBufferBuilder &_fbb, const Request_Set_Map_CloudT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Response_Set_Map_CloudT : public flatbuffers::NativeTable {
  typedef Response_Set_Map_Cloud TableType;
  std::string id;
  std::string map_name;
  std::string file_name;
  uint32_t size;
  std::string result;
  std::string message;
  Response_Set_Map_CloudT()
      : size(0) {
  }
};

struct Response_Set_Map_Cloud FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Response_Set_Map_CloudT NativeTableType;
  typedef Response_Set_Map_CloudBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_MAP_NAME = 6,
    VT_FILE_NAME = 8,
    VT_SIZE = 10,
    VT_RESULT = 12,
    VT_MESSAGE = 14
  };
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  flatbuffers::String *mutable_id() {
    return GetPointer<flatbuffers::String *>(VT_ID);
  }
  const flatbuffers::String *map_name() const {
    return GetPointer<const flatbuffers::String *>(VT_MAP_NAME);
  }
  flatbuffers::String *mutable_map_name() {
    return GetPointer<flatbuffers::String *>(VT_MAP_NAME);
  }
  const flatbuffers::String *file_name() const {
    return GetPointer<const flatbuffers::String *>(VT_FILE_NAME);
  }
  flatbuffers::String *mutable_file_name() {
    return GetPointer<flatbuffers::String *>(VT_FILE_NAME);
  }
  uint32_t size() const {
    return GetField<uint32_t>(VT_SIZE, 0);
  }
  bool mutate_size(uint32_t _size) {
    return SetField<uint32_t>(VT_SIZE, _size, 0);
  }
  const flatbuffers::String *result() const {
    return GetPointer<const flatbuffers::String *>(VT_RESULT);
  }
  flatbuffers::String *mutable_result() {
    return GetPointer<flatbuffers::String *>(VT_RESULT);
  }
  const flatbuffers::String *message() const {
    return GetPointer<const flatbuffers::String *>(VT_MESSAGE);
  }
  flatbuffers::String *mutable_message() {
    return GetPointer<flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_MAP_NAME) &&
           verifier.VerifyString(map_name()) &&
           VerifyOffset(verifier, VT_FILE_NAME) &&
           verifier.VerifyString(file_name()) &&
           VerifyField<uint32_t>(verifier, VT_SIZE) &&
           VerifyOffset(verifier, VT_RESULT) &&
           verifier.VerifyString(result()) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
  Response_Set_Map_CloudT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Response_Set_Map_CloudT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Response_Set_Map_Cloud> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Response_Set_Map_CloudT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Response_Set_Map_CloudBuilder {
  typedef Response_Set_Map_Cloud Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(Response_Set_Map_Cloud::VT_ID, id);
  }
  void add_map_name(flatbuffers::Offset<flatbuffers::String> map_name) {
    fbb_.AddOffset(Response_Set_Map_Cloud::VT_MAP_NAME, map_name);
  }
  void add_file_name(flatbuffers::Offset<flatbuffers::String> file_name) {
    fbb_.AddOffset(Response_Set_Map_Cloud::VT_FILE_NAME, file_name);
  }
  void add_size(uint32_t size) {
    fbb_.AddElement<uint32_t>(Response_Set_Map_Cloud::VT_SIZE, size, 0);
  }
  void add_result(flatbuffers::Offset<flatbuffers::String> result) {
    fbb_.AddOffset(Response_Set_Map_Cloud::VT_RESULT, result);
  }
  void add_message(flatbuffers::Offset<flatbuffers::String> message) {
    fbb_.AddOffset(Response_Set_Map_Cloud::VT_MESSAGE, message);
  }
  explicit Response_Set_Map_CloudBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Response_Set_Map_Cloud> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Response_Set_Map_Cloud>(end);
    return o;
  }
};

inline flatbuffers::Offset<Response_Set_Map_Cloud> CreateResponse_Set_Map_Cloud(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> id = 0,
    flatbuffers::Offset<flatbuffers::String> map_name = 0,
    flatbuffers::Offset<flatbuffers::String> file_name = 0,
    uint32_t size = 0,
    flatbuffers::Offset<flatbuffers::String> result = 0,
    flatbuffers::Offset<flatbuffers::String> message = 0) {
  Response_Set_Map_CloudBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_result(result);
  builder_.add_size(size);
  builder_.add_file_name(file_name);
  builder_.add_map_name(map_name);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<Response_Set_Map_Cloud> CreateResponse_Set_Map_CloudDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *map_name = nullptr,
    const char *file_name = nullptr,
    uint32_t size = 0,
    const char *result = nullptr,
    const char *message = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto map_name__ = map_name ? _fbb.CreateString(map_name) : 0;
  auto file_name__ = file_name ? _fbb.CreateString(file_name) : 0;
  auto result__ = result ? _fbb.CreateString(result) : 0;
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return SLAMNAV::CreateResponse_Set_Map_Cloud(
      _fbb,
      id__,
      map_name__,
      file_name__,
      size,
      result__,
      message__);
}

flatbuffers::Offset<Response_Set_Map_Cloud> CreateResponse_Set_Map_Cloud(flatbuffers::FlatBufferBuilder &_fbb, const Response_Set_Map_CloudT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Request_Get_Map_pipeT : public flatbuffers::NativeTable {
  typedef Request_Get_Map_pipe TableType;
  Request_Get_Map_pipeT() {
  }
};

struct Request_Get_Map_pipe FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Request_Get_Map_pipeT NativeTableType;
  typedef Request_Get_Map_pipeBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  Request_Get_Map_pipeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_Get_Map_pipeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Request_Get_Map_pipe> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_Get_Map_pipeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_Get_Map_pipeBuilder {
  typedef Request_Get_Map_pipe Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit Request_Get_Map_pipeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Request_Get_Map_pipe> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Request_Get_Map_pipe>(end);
    return o;
  }
};

inline flatbuffers::Offset<Request_Get_Map_pipe> CreateRequest_Get_Map_pipe(
    flatbuffers::FlatBufferBuilder &_fbb) {
  Request_Get_Map_pipeBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Request_Get_Map_pipe> CreateRequest_Get_Map_pipe(flatbuffers::FlatBufferBuilder &_fbb, const Request_Get_Map_pipeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Response_Get_Map_pipeT : public flatbuffers::NativeTable {
  typedef Response_Get_Map_pipe TableType;
  Response_Get_Map_pipeT() {
  }
};

struct Response_Get_Map_pipe FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Response_Get_Map_pipeT NativeTableType;
  typedef Response_Get_Map_pipeBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  Response_Get_Map_pipeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Response_Get_Map_pipeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Response_Get_Map_pipe> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Response_Get_Map_pipeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Response_Get_Map_pipeBuilder {
  typedef Response_Get_Map_pipe Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit Response_Get_Map_pipeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Response_Get_Map_pipe> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Response_Get_Map_pipe>(end);
    return o;
  }
};

inline flatbuffers::Offset<Response_Get_Map_pipe> CreateResponse_Get_Map_pipe(
    flatbuffers::FlatBufferBuilder &_fbb) {
  Response_Get_Map_pipeBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Response_Get_Map_pipe> CreateResponse_Get_Map_pipe(flatbuffers::FlatBufferBuilder &_fbb, const Response_Get_Map_pipeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Request_Get_Map_TilesT : public flatbuffers::NativeTable {
  typedef Request_Get_Map_Tiles TableType;
  Request_Get_Map_TilesT() {
  }
};

struct Request_Get_Map_Tiles FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Request_Get_Map_TilesT NativeTableType;
  typedef Request_Get_Map_TilesBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  Request_Get_Map_TilesT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_Get_Map_TilesT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Request_Get_Map_Tiles> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_Get_Map_TilesT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_Get_Map_TilesBuilder {
  typedef Request_Get_Map_Tiles Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit Request_Get_Map_TilesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Request_Get_Map_Tiles> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Request_Get_Map_Tiles>(end);
    return o;
  }
};

inline flatbuffers::Offset<Request_Get_Map_Tiles> CreateRequest_Get_Map_Tiles(
    flatbuffers::FlatBufferBuilder &_fbb) {
  Request_Get_Map_TilesBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Request_Get_Map_Tiles> CreateRequest_Get_Map_Tiles(flatbuffers::FlatBufferBuilder &_fbb, const Request_Get_Map_TilesT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Response_Get_Map_TilesT : public flatbuffers::NativeTable {
  typedef Response_Get_Map_Tiles TableType;
  Response_Get_Map_TilesT() {
  }
};

struct Response_Get_Map_Tiles FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Response_Get_Map_TilesT NativeTableType;
  typedef Response_Get_Map_TilesBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  Response_Get_Map_TilesT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Response_Get_Map_TilesT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Response_Get_Map_Tiles> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Response_Get_Map_TilesT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Response_Get_Map_TilesBuilder {
  typedef Response_Get_Map_Tiles Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit Response_Get_Map_TilesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Response_Get_Map_Tiles> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Response_Get_Map_Tiles>(end);
    return o;
  }
};

inline flatbuffers::Offset<Response_Get_Map_Tiles> CreateResponse_Get_Map_Tiles(
    flatbuffers::FlatBufferBuilder &_fbb) {
  Response_Get_Map_TilesBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Response_Get_Map_Tiles> CreateResponse_Get_Map_Tiles(flatbuffers::FlatBufferBuilder &_fbb, const Response_Get_Map_TilesT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Request_Set_Map_TopologyT : public flatbuffers::NativeTable {
  typedef Request_Set_Map_Topology TableType;
  std::string id;
  std::string map_name;
  std::vector<std::unique_ptr<SLAMNAV::NodeT>> data;
  Request_Set_Map_TopologyT() {
  }
};

struct Request_Set_Map_Topology FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Request_Set_Map_TopologyT NativeTableType;
  typedef Request_Set_Map_TopologyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_MAP_NAME = 6,
    VT_DATA = 8
  };
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  flatbuffers::String *mutable_id() {
    return GetPointer<flatbuffers::String *>(VT_ID);
  }
  const flatbuffers::String *map_name() const {
    return GetPointer<const flatbuffers::String *>(VT_MAP_NAME);
  }
  flatbuffers::String *mutable_map_name() {
    return GetPointer<flatbuffers::String *>(VT_MAP_NAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SLAMNAV::Node>> *data() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SLAMNAV::Node>> *>(VT_DATA);
  }
  flatbuffers::Vector<flatbuffers::Offset<SLAMNAV::Node>> *mutable_data() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<SLAMNAV::Node>> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_MAP_NAME) &&
           verifier.VerifyString(map_name()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.VerifyVectorOfTables(data()) &&
           verifier.EndTable();
  }
  Request_Set_Map_TopologyT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_Set_Map_TopologyT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Request_Set_Map_Topology> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_Set_Map_TopologyT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_Set_Map_TopologyBuilder {
  typedef Request_Set_Map_Topology Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(Request_Set_Map_Topology::VT_ID, id);
  }
  void add_map_name(flatbuffers::Offset<flatbuffers::String> map_name) {
    fbb_.AddOffset(Request_Set_Map_Topology::VT_MAP_NAME, map_name);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SLAMNAV::Node>>> data) {
    fbb_.AddOffset(Request_Set_Map_Topology::VT_DATA, data);
  }
  explicit Request_Set_Map_TopologyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Request_Set_Map_Topology> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Request_Set_Map_Topology>(end);
    return o;
  }
};

inline flatbuffers::Offset<Request_Set_Map_Topology> CreateRequest_Set_Map_Topology(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> id = 0,
    flatbuffers::Offset<flatbuffers::String> map_name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SLAMNAV::Node>>> data = 0) {
  Request_Set_Map_TopologyBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_map_name(map_name);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<Request_Set_Map_Topology> CreateRequest_Set_Map_TopologyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *map_name = nullptr,
    const std::vector<flatbuffers::Offset<SLAMNAV::Node>> *data = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto map_name__ = map_name ? _fbb.CreateString(map_name) : 0;
  auto data__ = data ? _fbb.CreateVector<flatbuffers::Offset<SLAMNAV::Node>>(*data) : 0;
  return SLAMNAV::CreateRequest_Set_Map_Topology(
      _fbb,
      id__,
      map_name__,
      data__);
}

flatbuffers::Offset<Request_Set_Map_Topology> CreateRequest_Set_Map_Topology(flatbuffers::FlatBufferBuilder &_fbb, const Request_Set_Map_TopologyT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Response_Set_Map_TopologyT : public flatbuffers::NativeTable {
  typedef Response_Set_Map_Topology TableType;
  std::string id;
  std::string map_name;
  std::string result;
  std::string message;
  Response_Set_Map_TopologyT() {
  }
};

struct Response_Set_Map_Topology FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Response_Set_Map_TopologyT NativeTableType;
  typedef Response_Set_Map_TopologyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_MAP_NAME = 6,
    VT_RESULT = 8,
    VT_MESSAGE = 10
  };
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  flatbuffers::String *mutable_id() {
    return GetPointer<flatbuffers::String *>(VT_ID);
  }
  const flatbuffers::String *map_name() const {
    return GetPointer<const flatbuffers::String *>(VT_MAP_NAME);
  }
  flatbuffers::String *mutable_map_name() {
    return GetPointer<flatbuffers::String *>(VT_MAP_NAME);
  }
  const flatbuffers::String *result() const {
    return GetPointer<const flatbuffers::String *>(VT_RESULT);
  }
  flatbuffers::String *mutable_result() {
    return GetPointer<flatbuffers::String *>(VT_RESULT);
  }
  const flatbuffers::String *message() const {
    return GetPointer<const flatbuffers::String *>(VT_MESSAGE);
  }
  flatbuffers::String *mutable_message() {
    return GetPointer<flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_MAP_NAME) &&
           verifier.VerifyString(map_name()) &&
           VerifyOffset(verifier, VT_RESULT) &&
           verifier.VerifyString(result()) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
  Response_Set_Map_TopologyT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Response_Set_Map_TopologyT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Response_Set_Map_Topology> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Response_Set_Map_TopologyT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Response_Set_Map_TopologyBuilder {
  typedef Response_Set_Map_Topology Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(Response_Set_Map_Topology::VT_ID, id);
  }
  void add_map_name(flatbuffers::Offset<flatbuffers::String> map_name) {
    fbb_.AddOffset(Response_Set_Map_Topology::VT_MAP_NAME, map_name);
  }
  void add_result(flatbuffers::Offset<flatbuffers::String> result) {
    fbb_.AddOffset(Response_Set_Map_Topology::VT_RESULT, result);
  }
  void add_message(flatbuffers::Offset<flatbuffers::String> message) {
    fbb_.AddOffset(Response_Set_Map_Topology::VT_MESSAGE, message);
  }
  explicit Response_Set_Map_TopologyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Response_Set_Map_Topology> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Response_Set_Map_Topology>(end);
    return o;
  }
};

inline flatbuffers::Offset<Response_Set_Map_Topology> CreateResponse_Set_Map_Topology(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> id = 0,
    flatbuffers::Offset<flatbuffers::String> map_name = 0,
    flatbuffers::Offset<flatbuffers::String> result = 0,
    flatbuffers::Offset<flatbuffers::String> message = 0) {
  Response_Set_Map_TopologyBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_result(result);
  builder_.add_map_name(map_name);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<Response_Set_Map_Topology> CreateResponse_Set_Map_TopologyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *map_name = nullptr,
    const char *result = nullptr,
    const char *message = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto map_name__ = map_name ? _fbb.CreateString(map_name) : 0;
  auto result__ = result ? _fbb.CreateString(result) : 0;
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return SLAMNAV::CreateResponse_Set_Map_Topology(
      _fbb,
      id__,
      map_name__,
      result__,
      message__);
}

flatbuffers::Offset<Response_Set_Map_Topology> CreateResponse_Set_Map_Topology(flatbuffers::FlatBufferBuilder &_fbb, const Response_Set_Map_TopologyT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Request_Get_Map_TopologyT : public flatbuffers::NativeTable {
  typedef Request_Get_Map_Topology TableType;
  std::string id;
  std::string map_name;
  Request_Get_Map_TopologyT() {
  }
};

struct Request_Get_Map_Topology FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Request_Get_Map_TopologyT NativeTableType;
  typedef Request_Get_Map_TopologyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_MAP_NAME = 6
  };
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  flatbuffers::String *mutable_id() {
    return GetPointer<flatbuffers::String *>(VT_ID);
  }
  const flatbuffers::String *map_name() const {
    return GetPointer<const flatbuffers::String *>(VT_MAP_NAME);
  }
  flatbuffers::String *mutable_map_name() {
    return GetPointer<flatbuffers::String *>(VT_MAP_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_MAP_NAME) &&
           verifier.VerifyString(map_name()) &&
           verifier.EndTable();
  }
  Request_Get_Map_TopologyT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_Get_Map_TopologyT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Request_Get_Map_Topology> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_Get_Map_TopologyT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_Get_Map_TopologyBuilder {
  typedef Request_Get_Map_Topology Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(Request_Get_Map_Topology::VT_ID, id);
  }
  void add_map_name(flatbuffers::Offset<flatbuffers::String> map_name) {
    fbb_.AddOffset(Request_Get_Map_Topology::VT_MAP_NAME, map_name);
  }
  explicit Request_Get_Map_TopologyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Request_Get_Map_Topology> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Request_Get_Map_Topology>(end);
    return o;
  }
};

inline flatbuffers::Offset<Request_Get_Map_Topology> CreateRequest_Get_Map_Topology(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> id = 0,
    flatbuffers::Offset<flatbuffers::String> map_name = 0) {
  Request_Get_Map_TopologyBuilder builder_(_fbb);
  builder_.add_map_name(map_name);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<Request_Get_Map_Topology> CreateRequest_Get_Map_TopologyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *map_name = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto map_name__ = map_name ? _fbb.CreateString(map_name) : 0;
  return SLAMNAV::CreateRequest_Get_Map_Topology(
      _fbb,
      id__,
      map_name__);
}

flatbuffers::Offset<Request_Get_Map_Topology> CreateRequest_Get_Map_Topology(flatbuffers::FlatBufferBuilder &_fbb, const Request_Get_Map_TopologyT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Response_Get_Map_TopologyT : public flatbuffers::NativeTable {
  typedef Response_Get_Map_Topology TableType;
  std::string id;
  std::string map_name;
  std::vector<std::unique_ptr<SLAMNAV::NodeT>> data;
  std::string result;
  std::string message;
  Response_Get_Map_TopologyT() {
  }
};

struct Response_Get_Map_Topology FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Response_Get_Map_TopologyT NativeTableType;
  typedef Response_Get_Map_TopologyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_MAP_NAME = 6,
    VT_DATA = 8,
    VT_RESULT = 10,
    VT_MESSAGE = 12
  };
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  flatbuffers::String *mutable_id() {
    return GetPointer<flatbuffers::String *>(VT_ID);
  }
  const flatbuffers::String *map_name() const {
    return GetPointer<const flatbuffers::String *>(VT_MAP_NAME);
  }
  flatbuffers::String *mutable_map_name() {
    return GetPointer<flatbuffers::String *>(VT_MAP_NAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SLAMNAV::Node>> *data() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SLAMNAV::Node>> *>(VT_DATA);
  }
  flatbuffers::Vector<flatbuffers::Offset<SLAMNAV::Node>> *mutable_data() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<SLAMNAV::Node>> *>(VT_DATA);
  }
  const flatbuffers::String *result() const {
    return GetPointer<const flatbuffers::String *>(VT_RESULT);
  }
  flatbuffers::String *mutable_result() {
    return GetPointer<flatbuffers::String *>(VT_RESULT);
  }
  const flatbuffers::String *message() const {
    return GetPointer<const flatbuffers::String *>(VT_MESSAGE);
  }
  flatbuffers::String *mutable_message() {
    return GetPointer<flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_MAP_NAME) &&
           verifier.VerifyString(map_name()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.VerifyVectorOfTables(data()) &&
           VerifyOffset(verifier, VT_RESULT) &&
           verifier.VerifyString(result()) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
  Response_Get_Map_TopologyT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Response_Get_Map_TopologyT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Response_Get_Map_Topology> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Response_Get_Map_TopologyT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Response_Get_Map_TopologyBuilder {
  typedef Response_Get_Map_Topology Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(Response_Get_Map_Topology::VT_ID, id);
  }
  void add_map_name(flatbuffers::Offset<flatbuffers::String> map_name) {
    fbb_.AddOffset(Response_Get_Map_Topology::VT_MAP_NAME, map_name);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SLAMNAV::Node>>> data) {
    fbb_.AddOffset(Response_Get_Map_Topology::VT_DATA, data);
  }
  void add_result(flatbuffers::Offset<flatbuffers::String> result) {
    fbb_.AddOffset(Response_Get_Map_Topology::VT_RESULT, result);
  }
  void add_message(flatbuffers::Offset<flatbuffers::String> message) {
    fbb_.AddOffset(Response_Get_Map_Topology::VT_MESSAGE, message);
  }
  explicit Response_Get_Map_TopologyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Response_Get_Map_Topology> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Response_Get_Map_Topology>(end);
    return o;
  }
};

inline flatbuffers::Offset<Response_Get_Map_Topology> CreateResponse_Get_Map_Topology(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> id = 0,
    flatbuffers::Offset<flatbuffers::String> map_name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SLAMNAV::Node>>> data = 0,
    flatbuffers::Offset<flatbuffers::String> result = 0,
    flatbuffers::Offset<flatbuffers::String> message = 0) {
  Response_Get_Map_TopologyBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_result(result);
  builder_.add_data(data);
  builder_.add_map_name(map_name);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<Response_Get_Map_Topology> CreateResponse_Get_Map_TopologyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *map_name = nullptr,
    const std::vector<flatbuffers::Offset<SLAMNAV::Node>> *data = nullptr,
    const char *result = nullptr,
    const char *message = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto map_name__ = map_name ? _fbb.CreateString(map_name) : 0;
  auto data__ = data ? _fbb.CreateVector<flatbuffers::Offset<SLAMNAV::Node>>(*data) : 0;
  auto result__ = result ? _fbb.CreateString(result) : 0;
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return SLAMNAV::CreateResponse_Get_Map_Topology(
      _fbb,
      id__,
      map_name__,
      data__,
      result__,
      message__);
}

flatbuffers::Offset<Response_Get_Map_Topology> CreateResponse_Get_Map_Topology(flatbuffers::FlatBufferBuilder &_fbb, const Response_Get_Map_TopologyT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Request_Mapping_StartT : public flatbuffers::NativeTable {
  typedef Request_Mapping_Start TableType;
  std::string id;
  Request_Mapping_StartT() {
  }
};

struct Request_Mapping_Start FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Request_Mapping_StartT NativeTableType;
  typedef Request_Mapping_StartBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  flatbuffers::String *mutable_id() {
    return GetPointer<flatbuffers::String *>(VT_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           verifier.EndTable();
  }
  Request_Mapping_StartT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_Mapping_StartT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Request_Mapping_Start> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_Mapping_StartT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_Mapping_StartBuilder {
  typedef Request_Mapping_Start Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(Request_Mapping_Start::VT_ID, id);
  }
  explicit Request_Mapping_StartBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Request_Mapping_Start> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Request_Mapping_Start>(end);
    return o;
  }
};

inline flatbuffers::Offset<Request_Mapping_Start> CreateRequest_Mapping_Start(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> id = 0) {
  Request_Mapping_StartBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<Request_Mapping_Start> CreateRequest_Mapping_StartDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  return SLAMNAV::CreateRequest_Mapping_Start(
      _fbb,
      id__);
}

flatbuffers::Offset<Request_Mapping_Start> CreateRequest_Mapping_Start(flatbuffers::FlatBufferBuilder &_fbb, const Request_Mapping_StartT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Response_Mapping_StartT : public flatbuffers::NativeTable {
  typedef Response_Mapping_Start TableType;
  std::string id;
  std::string result;
  std::string message;
  Response_Mapping_StartT() {
  }
};

struct Response_Mapping_Start FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Response_Mapping_StartT NativeTableType;
  typedef Response_Mapping_StartBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_RESULT = 6,
    VT_MESSAGE = 8
  };
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  flatbuffers::String *mutable_id() {
    return GetPointer<flatbuffers::String *>(VT_ID);
  }
  const flatbuffers::String *result() const {
    return GetPointer<const flatbuffers::String *>(VT_RESULT);
  }
  flatbuffers::String *mutable_result() {
    return GetPointer<flatbuffers::String *>(VT_RESULT);
  }
  const flatbuffers::String *message() const {
    return GetPointer<const flatbuffers::String *>(VT_MESSAGE);
  }
  flatbuffers::String *mutable_message() {
    return GetPointer<flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_RESULT) &&
           verifier.VerifyString(result()) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
  Response_Mapping_StartT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Response_Mapping_StartT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Response_Mapping_Start> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Response_Mapping_StartT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Response_Mapping_StartBuilder {
  typedef Response_Mapping_Start Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(Response_Mapping_Start::VT_ID, id);
  }
  void add_result(flatbuffers::Offset<flatbuffers::String> result) {
    fbb_.AddOffset(Response_Mapping_Start::VT_RESULT, result);
  }
  void add_message(flatbuffers::Offset<flatbuffers::String> message) {
    fbb_.AddOffset(Response_Mapping_Start::VT_MESSAGE, message);
  }
  explicit Response_Mapping_StartBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Response_Mapping_Start> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Response_Mapping_Start>(end);
    return o;
  }
};

inline flatbuffers::Offset<Response_Mapping_Start> CreateResponse_Mapping_Start(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> id = 0,
    flatbuffers::Offset<flatbuffers::String> result = 0,
    flatbuffers::Offset<flatbuffers::String> message = 0) {
  Response_Mapping_StartBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_result(result);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<Response_Mapping_Start> CreateResponse_Mapping_StartDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *result = nullptr,
    const char *message = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto result__ = result ? _fbb.CreateString(result) : 0;
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return SLAMNAV::CreateResponse_Mapping_Start(
      _fbb,
      id__,
      result__,
      message__);
}

flatbuffers::Offset<Response_Mapping_Start> CreateResponse_Mapping_Start(flatbuffers::FlatBufferBuilder &_fbb, const Response_Mapping_StartT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Request_Mapping_StopT : public flatbuffers::NativeTable {
  typedef Request_Mapping_Stop TableType;
  std::string id;
  Request_Mapping_StopT() {
  }
};

struct Request_Mapping_Stop FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Request_Mapping_StopT NativeTableType;
  typedef Request_Mapping_StopBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  flatbuffers::String *mutable_id() {
    return GetPointer<flatbuffers::String *>(VT_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           verifier.EndTable();
  }
  Request_Mapping_StopT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_Mapping_StopT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Request_Mapping_Stop> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_Mapping_StopT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_Mapping_StopBuilder {
  typedef Request_Mapping_Stop Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(Request_Mapping_Stop::VT_ID, id);
  }
  explicit Request_Mapping_StopBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Request_Mapping_Stop> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Request_Mapping_Stop>(end);
    return o;
  }
};

inline flatbuffers::Offset<Request_Mapping_Stop> CreateRequest_Mapping_Stop(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> id = 0) {
  Request_Mapping_StopBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<Request_Mapping_Stop> CreateRequest_Mapping_StopDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  return SLAMNAV::CreateRequest_Mapping_Stop(
      _fbb,
      id__);
}

flatbuffers::Offset<Request_Mapping_Stop> CreateRequest_Mapping_Stop(flatbuffers::FlatBufferBuilder &_fbb, const Request_Mapping_StopT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Response_Mapping_StopT : public flatbuffers::NativeTable {
  typedef Response_Mapping_Stop TableType;
  std::string id;
  std::string result;
  std::string message;
  Response_Mapping_StopT() {
  }
};

struct Response_Mapping_Stop FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Response_Mapping_StopT NativeTableType;
  typedef Response_Mapping_StopBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_RESULT = 6,
    VT_MESSAGE = 8
  };
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  flatbuffers::String *mutable_id() {
    return GetPointer<flatbuffers::String *>(VT_ID);
  }
  const flatbuffers::String *result() const {
    return GetPointer<const flatbuffers::String *>(VT_RESULT);
  }
  flatbuffers::String *mutable_result() {
    return GetPointer<flatbuffers::String *>(VT_RESULT);
  }
  const flatbuffers::String *message() const {
    return GetPointer<const flatbuffers::String *>(VT_MESSAGE);
  }
  flatbuffers::String *mutable_message() {
    return GetPointer<flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_RESULT) &&
           verifier.VerifyString(result()) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
  Response_Mapping_StopT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Response_Mapping_StopT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Response_Mapping_Stop> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Response_Mapping_StopT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Response_Mapping_StopBuilder {
  typedef Response_Mapping_Stop Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(Response_Mapping_Stop::VT_ID, id);
  }
  void add_result(flatbuffers::Offset<flatbuffers::String> result) {
    fbb_.AddOffset(Response_Mapping_Stop::VT_RESULT, result);
  }
  void add_message(flatbuffers::Offset<flatbuffers::String> message) {
    fbb_.AddOffset(Response_Mapping_Stop::VT_MESSAGE, message);
  }
  explicit Response_Mapping_StopBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Response_Mapping_Stop> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Response_Mapping_Stop>(end);
    return o;
  }
};

inline flatbuffers::Offset<Response_Mapping_Stop> CreateResponse_Mapping_Stop(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> id = 0,
    flatbuffers::Offset<flatbuffers::String> result = 0,
    flatbuffers::Offset<flatbuffers::String> message = 0) {
  Response_Mapping_StopBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_result(result);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<Response_Mapping_Stop> CreateResponse_Mapping_StopDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *result = nullptr,
    const char *message = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto result__ = result ? _fbb.CreateString(result) : 0;
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return SLAMNAV::CreateResponse_Mapping_Stop(
      _fbb,
      id__,
      result__,
      message__);
}

flatbuffers::Offset<Response_Mapping_Stop> CreateResponse_Mapping_Stop(flatbuffers::FlatBufferBuilder &_fbb, const Response_Mapping_StopT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Request_Mapping_SaveT : public flatbuffers::NativeTable {
  typedef Request_Mapping_Save TableType;
  std::string id;
  std::string map_name;
  Request_Mapping_SaveT() {
  }
};

struct Request_Mapping_Save FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Request_Mapping_SaveT NativeTableType;
  typedef Request_Mapping_SaveBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_MAP_NAME = 6
  };
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  flatbuffers::String *mutable_id() {
    return GetPointer<flatbuffers::String *>(VT_ID);
  }
  const flatbuffers::String *map_name() const {
    return GetPointer<const flatbuffers::String *>(VT_MAP_NAME);
  }
  flatbuffers::String *mutable_map_name() {
    return GetPointer<flatbuffers::String *>(VT_MAP_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_MAP_NAME) &&
           verifier.VerifyString(map_name()) &&
           verifier.EndTable();
  }
  Request_Mapping_SaveT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_Mapping_SaveT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Request_Mapping_Save> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_Mapping_SaveT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_Mapping_SaveBuilder {
  typedef Request_Mapping_Save Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(Request_Mapping_Save::VT_ID, id);
  }
  void add_map_name(flatbuffers::Offset<flatbuffers::String> map_name) {
    fbb_.AddOffset(Request_Mapping_Save::VT_MAP_NAME, map_name);
  }
  explicit Request_Mapping_SaveBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Request_Mapping_Save> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Request_Mapping_Save>(end);
    return o;
  }
};

inline flatbuffers::Offset<Request_Mapping_Save> CreateRequest_Mapping_Save(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> id = 0,
    flatbuffers::Offset<flatbuffers::String> map_name = 0) {
  Request_Mapping_SaveBuilder builder_(_fbb);
  builder_.add_map_name(map_name);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<Request_Mapping_Save> CreateRequest_Mapping_SaveDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *map_name = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto map_name__ = map_name ? _fbb.CreateString(map_name) : 0;
  return SLAMNAV::CreateRequest_Mapping_Save(
      _fbb,
      id__,
      map_name__);
}

flatbuffers::Offset<Request_Mapping_Save> CreateRequest_Mapping_Save(flatbuffers::FlatBufferBuilder &_fbb, const Request_Mapping_SaveT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Response_Mapping_SaveT : public flatbuffers::NativeTable {
  typedef Response_Mapping_Save TableType;
  std::string id;
  std::string map_name;
  std::string result;
  std::string message;
  Response_Mapping_SaveT() {
  }
};

struct Response_Mapping_Save FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Response_Mapping_SaveT NativeTableType;
  typedef Response_Mapping_SaveBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_MAP_NAME = 6,
    VT_RESULT = 8,
    VT_MESSAGE = 10
  };
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  flatbuffers::String *mutable_id() {
    return GetPointer<flatbuffers::String *>(VT_ID);
  }
  const flatbuffers::String *map_name() const {
    return GetPointer<const flatbuffers::String *>(VT_MAP_NAME);
  }
  flatbuffers::String *mutable_map_name() {
    return GetPointer<flatbuffers::String *>(VT_MAP_NAME);
  }
  const flatbuffers::String *result() const {
    return GetPointer<const flatbuffers::String *>(VT_RESULT);
  }
  flatbuffers::String *mutable_result() {
    return GetPointer<flatbuffers::String *>(VT_RESULT);
  }
  const flatbuffers::String *message() const {
    return GetPointer<const flatbuffers::String *>(VT_MESSAGE);
  }
  flatbuffers::String *mutable_message() {
    return GetPointer<flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_MAP_NAME) &&
           verifier.VerifyString(map_name()) &&
           VerifyOffset(verifier, VT_RESULT) &&
           verifier.VerifyString(result()) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
  Response_Mapping_SaveT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Response_Mapping_SaveT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Response_Mapping_Save> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Response_Mapping_SaveT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Response_Mapping_SaveBuilder {
  typedef Response_Mapping_Save Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(Response_Mapping_Save::VT_ID, id);
  }
  void add_map_name(flatbuffers::Offset<flatbuffers::String> map_name) {
    fbb_.AddOffset(Response_Mapping_Save::VT_MAP_NAME, map_name);
  }
  void add_result(flatbuffers::Offset<flatbuffers::String> result) {
    fbb_.AddOffset(Response_Mapping_Save::VT_RESULT, result);
  }
  void add_message(flatbuffers::Offset<flatbuffers::String> message) {
    fbb_.AddOffset(Response_Mapping_Save::VT_MESSAGE, message);
  }
  explicit Response_Mapping_SaveBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Response_Mapping_Save> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Response_Mapping_Save>(end);
    return o;
  }
};

inline flatbuffers::Offset<Response_Mapping_Save> CreateResponse_Mapping_Save(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> id = 0,
    flatbuffers::Offset<flatbuffers::String> map_name = 0,
    flatbuffers::Offset<flatbuffers::String> result = 0,
    flatbuffers::Offset<flatbuffers::String> message = 0) {
  Response_Mapping_SaveBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_result(result);
  builder_.add_map_name(map_name);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<Response_Mapping_Save> CreateResponse_Mapping_SaveDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *map_name = nullptr,
    const char *result = nullptr,
    const char *message = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto map_name__ = map_name ? _fbb.CreateString(map_name) : 0;
  auto result__ = result ? _fbb.CreateString(result) : 0;
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return SLAMNAV::CreateResponse_Mapping_Save(
      _fbb,
      id__,
      map_name__,
      result__,
      message__);
}

flatbuffers::Offset<Response_Mapping_Save> CreateResponse_Mapping_Save(flatbuffers::FlatBufferBuilder &_fbb, const Response_Mapping_SaveT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Request_Mapping_Cloud_ReloadT : public flatbuffers::NativeTable {
  typedef Request_Mapping_Cloud_Reload TableType;
  Request_Mapping_Cloud_ReloadT() {
  }
};

struct Request_Mapping_Cloud_Reload FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Request_Mapping_Cloud_ReloadT NativeTableType;
  typedef Request_Mapping_Cloud_ReloadBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  Request_Mapping_Cloud_ReloadT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_Mapping_Cloud_ReloadT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Request_Mapping_Cloud_Reload> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_Mapping_Cloud_ReloadT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_Mapping_Cloud_ReloadBuilder {
  typedef Request_Mapping_Cloud_Reload Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit Request_Mapping_Cloud_ReloadBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Request_Mapping_Cloud_Reload> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Request_Mapping_Cloud_Reload>(end);
    return o;
  }
};

inline flatbuffers::Offset<Request_Mapping_Cloud_Reload> CreateRequest_Mapping_Cloud_Reload(
    flatbuffers::FlatBufferBuilder &_fbb) {
  Request_Mapping_Cloud_ReloadBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Request_Mapping_Cloud_Reload> CreateRequest_Mapping_Cloud_Reload(flatbuffers::FlatBufferBuilder &_fbb, const Request_Mapping_Cloud_ReloadT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Response_Mapping_Cloud_ReloadT : public flatbuffers::NativeTable {
  typedef Response_Mapping_Cloud_Reload TableType;
  Response_Mapping_Cloud_ReloadT() {
  }
};

struct Response_Mapping_Cloud_Reload FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Response_Mapping_Cloud_ReloadT NativeTableType;
  typedef Response_Mapping_Cloud_ReloadBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  Response_Mapping_Cloud_ReloadT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Response_Mapping_Cloud_ReloadT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Response_Mapping_Cloud_Reload> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Response_Mapping_Cloud_ReloadT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Response_Mapping_Cloud_ReloadBuilder {
  typedef Response_Mapping_Cloud_Reload Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit Response_Mapping_Cloud_ReloadBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Response_Mapping_Cloud_Reload> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Response_Mapping_Cloud_Reload>(end);
    return o;
  }
};

inline flatbuffers::Offset<Response_Mapping_Cloud_Reload> CreateResponse_Mapping_Cloud_Reload(
    flatbuffers::FlatBufferBuilder &_fbb) {
  Response_Mapping_Cloud_ReloadBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Response_Mapping_Cloud_Reload> CreateResponse_Mapping_Cloud_Reload(flatbuffers::FlatBufferBuilder &_fbb, const Response_Mapping_Cloud_ReloadT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Map_ResultT : public flatbuffers::NativeTable {
  typedef Map_Result TableType;
  std::string id;
  std::string result;
  std::string message;
  Map_ResultT() {
  }
};

struct Map_Result FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Map_ResultT NativeTableType;
  typedef Map_ResultBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_RESULT = 6,
    VT_MESSAGE = 8
  };
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  flatbuffers::String *mutable_id() {
    return GetPointer<flatbuffers::String *>(VT_ID);
  }
  const flatbuffers::String *result() const {
    return GetPointer<const flatbuffers::String *>(VT_RESULT);
  }
  flatbuffers::String *mutable_result() {
    return GetPointer<flatbuffers::String *>(VT_RESULT);
  }
  const flatbuffers::String *message() const {
    return GetPointer<const flatbuffers::String *>(VT_MESSAGE);
  }
  flatbuffers::String *mutable_message() {
    return GetPointer<flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_RESULT) &&
           verifier.VerifyString(result()) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
  Map_ResultT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Map_ResultT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Map_Result> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Map_ResultT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Map_ResultBuilder {
  typedef Map_Result Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(Map_Result::VT_ID, id);
  }
  void add_result(flatbuffers::Offset<flatbuffers::String> result) {
    fbb_.AddOffset(Map_Result::VT_RESULT, result);
  }
  void add_message(flatbuffers::Offset<flatbuffers::String> message) {
    fbb_.AddOffset(Map_Result::VT_MESSAGE, message);
  }
  explicit Map_ResultBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Map_Result> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Map_Result>(end);
    return o;
  }
};

inline flatbuffers::Offset<Map_Result> CreateMap_Result(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> id = 0,
    flatbuffers::Offset<flatbuffers::String> result = 0,
    flatbuffers::Offset<flatbuffers::String> message = 0) {
  Map_ResultBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_result(result);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<Map_Result> CreateMap_ResultDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *result = nullptr,
    const char *message = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto result__ = result ? _fbb.CreateString(result) : 0;
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return SLAMNAV::CreateMap_Result(
      _fbb,
      id__,
      result__,
      message__);
}

flatbuffers::Offset<Map_Result> CreateMap_Result(flatbuffers::FlatBufferBuilder &_fbb, const Map_ResultT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline MapFileInfoT *MapFileInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<SLAMNAV::MapFileInfoT> _o = std::unique_ptr<SLAMNAV::MapFileInfoT>(new MapFileInfoT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MapFileInfo::UnPackTo(MapFileInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = map_name(); if (_e) _o->map_name = _e->str(); }
  { auto _e = created_at(); if (_e) _o->created_at = _e->str(); }
  { auto _e = update_at(); if (_e) _o->update_at = _e->str(); }
  { auto _e = map_type(); if (_e) _o->map_type = _e->str(); }
  { auto _e = map_size(); _o->map_size = _e; }
}

inline flatbuffers::Offset<MapFileInfo> MapFileInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MapFileInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMapFileInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MapFileInfo> CreateMapFileInfo(flatbuffers::FlatBufferBuilder &_fbb, const MapFileInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MapFileInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _map_name = _o->map_name.empty() ? 0 : _fbb.CreateString(_o->map_name);
  auto _created_at = _o->created_at.empty() ? 0 : _fbb.CreateString(_o->created_at);
  auto _update_at = _o->update_at.empty() ? 0 : _fbb.CreateString(_o->update_at);
  auto _map_type = _o->map_type.empty() ? 0 : _fbb.CreateString(_o->map_type);
  auto _map_size = _o->map_size;
  return SLAMNAV::CreateMapFileInfo(
      _fbb,
      _map_name,
      _created_at,
      _update_at,
      _map_type,
      _map_size);
}

inline MapFileT *MapFile::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<SLAMNAV::MapFileT> _o = std::unique_ptr<SLAMNAV::MapFileT>(new MapFileT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MapFile::UnPackTo(MapFileT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = file_name(); if (_e) _o->file_name = _e->str(); }
  { auto _e = created_at(); if (_e) _o->created_at = _e->str(); }
  { auto _e = update_at(); if (_e) _o->update_at = _e->str(); }
  { auto _e = file_type(); if (_e) _o->file_type = _e->str(); }
  { auto _e = cloud_info(); if (_e) _o->cloud_info = std::unique_ptr<SLAMNAV::MapFileInfoT>(_e->UnPack(_resolver)); }
  { auto _e = topo_info(); if (_e) _o->topo_info = std::unique_ptr<SLAMNAV::MapFileInfoT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<MapFile> MapFile::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MapFileT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMapFile(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MapFile> CreateMapFile(flatbuffers::FlatBufferBuilder &_fbb, const MapFileT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MapFileT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _file_name = _o->file_name.empty() ? 0 : _fbb.CreateString(_o->file_name);
  auto _created_at = _o->created_at.empty() ? 0 : _fbb.CreateString(_o->created_at);
  auto _update_at = _o->update_at.empty() ? 0 : _fbb.CreateString(_o->update_at);
  auto _file_type = _o->file_type.empty() ? 0 : _fbb.CreateString(_o->file_type);
  auto _cloud_info = _o->cloud_info ? CreateMapFileInfo(_fbb, _o->cloud_info.get(), _rehasher) : 0;
  auto _topo_info = _o->topo_info ? CreateMapFileInfo(_fbb, _o->topo_info.get(), _rehasher) : 0;
  return SLAMNAV::CreateMapFile(
      _fbb,
      _file_name,
      _created_at,
      _update_at,
      _file_type,
      _cloud_info,
      _topo_info);
}

inline Request_Map_ListT *Request_Map_List::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<SLAMNAV::Request_Map_ListT> _o = std::unique_ptr<SLAMNAV::Request_Map_ListT>(new Request_Map_ListT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Request_Map_List::UnPackTo(Request_Map_ListT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); }
}

inline flatbuffers::Offset<Request_Map_List> Request_Map_List::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_Map_ListT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_Map_List(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Request_Map_List> CreateRequest_Map_List(flatbuffers::FlatBufferBuilder &_fbb, const Request_Map_ListT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Request_Map_ListT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id.empty() ? 0 : _fbb.CreateString(_o->id);
  return SLAMNAV::CreateRequest_Map_List(
      _fbb,
      _id);
}

inline Response_Map_ListT *Response_Map_List::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<SLAMNAV::Response_Map_ListT> _o = std::unique_ptr<SLAMNAV::Response_Map_ListT>(new Response_Map_ListT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Response_Map_List::UnPackTo(Response_Map_ListT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); }
  { auto _e = list(); if (_e) { _o->list.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->list[_i] = std::unique_ptr<SLAMNAV::MapFileT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = result(); if (_e) _o->result = _e->str(); }
  { auto _e = message(); if (_e) _o->message = _e->str(); }
}

inline flatbuffers::Offset<Response_Map_List> Response_Map_List::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Response_Map_ListT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateResponse_Map_List(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Response_Map_List> CreateResponse_Map_List(flatbuffers::FlatBufferBuilder &_fbb, const Response_Map_ListT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Response_Map_ListT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id.empty() ? 0 : _fbb.CreateString(_o->id);
  auto _list = _o->list.size() ? _fbb.CreateVector<flatbuffers::Offset<SLAMNAV::MapFile>> (_o->list.size(), [](size_t i, _VectorArgs *__va) { return CreateMapFile(*__va->__fbb, __va->__o->list[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _result = _o->result.empty() ? 0 : _fbb.CreateString(_o->result);
  auto _message = _o->message.empty() ? 0 : _fbb.CreateString(_o->message);
  return SLAMNAV::CreateResponse_Map_List(
      _fbb,
      _id,
      _list,
      _result,
      _message);
}

inline Request_Map_DeleteT *Request_Map_Delete::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<SLAMNAV::Request_Map_DeleteT> _o = std::unique_ptr<SLAMNAV::Request_Map_DeleteT>(new Request_Map_DeleteT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Request_Map_Delete::UnPackTo(Request_Map_DeleteT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); }
  { auto _e = map_name(); if (_e) _o->map_name = _e->str(); }
}

inline flatbuffers::Offset<Request_Map_Delete> Request_Map_Delete::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_Map_DeleteT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_Map_Delete(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Request_Map_Delete> CreateRequest_Map_Delete(flatbuffers::FlatBufferBuilder &_fbb, const Request_Map_DeleteT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Request_Map_DeleteT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id.empty() ? 0 : _fbb.CreateString(_o->id);
  auto _map_name = _o->map_name.empty() ? 0 : _fbb.CreateString(_o->map_name);
  return SLAMNAV::CreateRequest_Map_Delete(
      _fbb,
      _id,
      _map_name);
}

inline Response_Map_DeleteT *Response_Map_Delete::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<SLAMNAV::Response_Map_DeleteT> _o = std::unique_ptr<SLAMNAV::Response_Map_DeleteT>(new Response_Map_DeleteT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Response_Map_Delete::UnPackTo(Response_Map_DeleteT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); }
  { auto _e = map_name(); if (_e) _o->map_name = _e->str(); }
  { auto _e = result(); if (_e) _o->result = _e->str(); }
  { auto _e = message(); if (_e) _o->message = _e->str(); }
}

inline flatbuffers::Offset<Response_Map_Delete> Response_Map_Delete::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Response_Map_DeleteT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateResponse_Map_Delete(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Response_Map_Delete> CreateResponse_Map_Delete(flatbuffers::FlatBufferBuilder &_fbb, const Response_Map_DeleteT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Response_Map_DeleteT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id.empty() ? 0 : _fbb.CreateString(_o->id);
  auto _map_name = _o->map_name.empty() ? 0 : _fbb.CreateString(_o->map_name);
  auto _result = _o->result.empty() ? 0 : _fbb.CreateString(_o->result);
  auto _message = _o->message.empty() ? 0 : _fbb.CreateString(_o->message);
  return SLAMNAV::CreateResponse_Map_Delete(
      _fbb,
      _id,
      _map_name,
      _result,
      _message);
}

inline Request_Map_CurrentT *Request_Map_Current::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<SLAMNAV::Request_Map_CurrentT> _o = std::unique_ptr<SLAMNAV::Request_Map_CurrentT>(new Request_Map_CurrentT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Request_Map_Current::UnPackTo(Request_Map_CurrentT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); }
}

inline flatbuffers::Offset<Request_Map_Current> Request_Map_Current::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_Map_CurrentT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_Map_Current(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Request_Map_Current> CreateRequest_Map_Current(flatbuffers::FlatBufferBuilder &_fbb, const Request_Map_CurrentT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Request_Map_CurrentT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id.empty() ? 0 : _fbb.CreateString(_o->id);
  return SLAMNAV::CreateRequest_Map_Current(
      _fbb,
      _id);
}

inline Response_Map_CurrentT *Response_Map_Current::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<SLAMNAV::Response_Map_CurrentT> _o = std::unique_ptr<SLAMNAV::Response_Map_CurrentT>(new Response_Map_CurrentT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Response_Map_Current::UnPackTo(Response_Map_CurrentT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); }
  { auto _e = map_name(); if (_e) _o->map_name = _e->str(); }
  { auto _e = result(); if (_e) _o->result = _e->str(); }
  { auto _e = message(); if (_e) _o->message = _e->str(); }
}

inline flatbuffers::Offset<Response_Map_Current> Response_Map_Current::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Response_Map_CurrentT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateResponse_Map_Current(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Response_Map_Current> CreateResponse_Map_Current(flatbuffers::FlatBufferBuilder &_fbb, const Response_Map_CurrentT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Response_Map_CurrentT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id.empty() ? 0 : _fbb.CreateString(_o->id);
  auto _map_name = _o->map_name.empty() ? 0 : _fbb.CreateString(_o->map_name);
  auto _result = _o->result.empty() ? 0 : _fbb.CreateString(_o->result);
  auto _message = _o->message.empty() ? 0 : _fbb.CreateString(_o->message);
  return SLAMNAV::CreateResponse_Map_Current(
      _fbb,
      _id,
      _map_name,
      _result,
      _message);
}

inline Request_Map_LoadT *Request_Map_Load::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<SLAMNAV::Request_Map_LoadT> _o = std::unique_ptr<SLAMNAV::Request_Map_LoadT>(new Request_Map_LoadT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Request_Map_Load::UnPackTo(Request_Map_LoadT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); }
  { auto _e = map_name(); if (_e) _o->map_name = _e->str(); }
}

inline flatbuffers::Offset<Request_Map_Load> Request_Map_Load::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_Map_LoadT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_Map_Load(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Request_Map_Load> CreateRequest_Map_Load(flatbuffers::FlatBufferBuilder &_fbb, const Request_Map_LoadT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Request_Map_LoadT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id.empty() ? 0 : _fbb.CreateString(_o->id);
  auto _map_name = _o->map_name.empty() ? 0 : _fbb.CreateString(_o->map_name);
  return SLAMNAV::CreateRequest_Map_Load(
      _fbb,
      _id,
      _map_name);
}

inline Response_Map_LoadT *Response_Map_Load::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<SLAMNAV::Response_Map_LoadT> _o = std::unique_ptr<SLAMNAV::Response_Map_LoadT>(new Response_Map_LoadT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Response_Map_Load::UnPackTo(Response_Map_LoadT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); }
  { auto _e = map_name(); if (_e) _o->map_name = _e->str(); }
  { auto _e = result(); if (_e) _o->result = _e->str(); }
  { auto _e = message(); if (_e) _o->message = _e->str(); }
}

inline flatbuffers::Offset<Response_Map_Load> Response_Map_Load::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Response_Map_LoadT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateResponse_Map_Load(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Response_Map_Load> CreateResponse_Map_Load(flatbuffers::FlatBufferBuilder &_fbb, const Response_Map_LoadT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Response_Map_LoadT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id.empty() ? 0 : _fbb.CreateString(_o->id);
  auto _map_name = _o->map_name.empty() ? 0 : _fbb.CreateString(_o->map_name);
  auto _result = _o->result.empty() ? 0 : _fbb.CreateString(_o->result);
  auto _message = _o->message.empty() ? 0 : _fbb.CreateString(_o->message);
  return SLAMNAV::CreateResponse_Map_Load(
      _fbb,
      _id,
      _map_name,
      _result,
      _message);
}

inline Request_Get_Map_FileT *Request_Get_Map_File::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<SLAMNAV::Request_Get_Map_FileT> _o = std::unique_ptr<SLAMNAV::Request_Get_Map_FileT>(new Request_Get_Map_FileT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Request_Get_Map_File::UnPackTo(Request_Get_Map_FileT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); }
  { auto _e = map_name(); if (_e) _o->map_name = _e->str(); }
  { auto _e = file_name(); if (_e) _o->file_name = _e->str(); }
}

inline flatbuffers::Offset<Request_Get_Map_File> Request_Get_Map_File::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_Get_Map_FileT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_Get_Map_File(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Request_Get_Map_File> CreateRequest_Get_Map_File(flatbuffers::FlatBufferBuilder &_fbb, const Request_Get_Map_FileT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Request_Get_Map_FileT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id.empty() ? 0 : _fbb.CreateString(_o->id);
  auto _map_name = _o->map_name.empty() ? 0 : _fbb.CreateString(_o->map_name);
  auto _file_name = _o->file_name.empty() ? 0 : _fbb.CreateString(_o->file_name);
  return SLAMNAV::CreateRequest_Get_Map_File(
      _fbb,
      _id,
      _map_name,
      _file_name);
}

inline Response_Get_Map_FileT *Response_Get_Map_File::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<SLAMNAV::Response_Get_Map_FileT> _o = std::unique_ptr<SLAMNAV::Response_Get_Map_FileT>(new Response_Get_Map_FileT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Response_Get_Map_File::UnPackTo(Response_Get_Map_FileT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); }
  { auto _e = map_name(); if (_e) _o->map_name = _e->str(); }
  { auto _e = file_name(); if (_e) _o->file_name = _e->str(); }
  { auto _e = size(); _o->size = _e; }
  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->data[_i] = *_e->Get(_i); } } }
  { auto _e = result(); if (_e) _o->result = _e->str(); }
  { auto _e = message(); if (_e) _o->message = _e->str(); }
}

inline flatbuffers::Offset<Response_Get_Map_File> Response_Get_Map_File::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Response_Get_Map_FileT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateResponse_Get_Map_File(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Response_Get_Map_File> CreateResponse_Get_Map_File(flatbuffers::FlatBufferBuilder &_fbb, const Response_Get_Map_FileT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Response_Get_Map_FileT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id.empty() ? 0 : _fbb.CreateString(_o->id);
  auto _map_name = _o->map_name.empty() ? 0 : _fbb.CreateString(_o->map_name);
  auto _file_name = _o->file_name.empty() ? 0 : _fbb.CreateString(_o->file_name);
  auto _size = _o->size;
  auto _data = _o->data.size() ? _fbb.CreateVectorOfStructs(_o->data) : 0;
  auto _result = _o->result.empty() ? 0 : _fbb.CreateString(_o->result);
  auto _message = _o->message.empty() ? 0 : _fbb.CreateString(_o->message);
  return SLAMNAV::CreateResponse_Get_Map_File(
      _fbb,
      _id,
      _map_name,
      _file_name,
      _size,
      _data,
      _result,
      _message);
}

inline LinkT *Link::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<SLAMNAV::LinkT> _o = std::unique_ptr<SLAMNAV::LinkT>(new LinkT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Link::UnPackTo(LinkT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); }
  { auto _e = info(); if (_e) _o->info = _e->str(); }
  { auto _e = speed(); _o->speed = _e; }
  { auto _e = method(); if (_e) _o->method = _e->str(); }
  { auto _e = safety_field(); _o->safety_field = _e; }
}

inline flatbuffers::Offset<Link> Link::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LinkT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLink(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Link> CreateLink(flatbuffers::FlatBufferBuilder &_fbb, const LinkT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LinkT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id.empty() ? 0 : _fbb.CreateString(_o->id);
  auto _info = _o->info.empty() ? 0 : _fbb.CreateString(_o->info);
  auto _speed = _o->speed;
  auto _method = _o->method.empty() ? 0 : _fbb.CreateString(_o->method);
  auto _safety_field = _o->safety_field;
  return SLAMNAV::CreateLink(
      _fbb,
      _id,
      _info,
      _speed,
      _method,
      _safety_field);
}

inline NodeT *Node::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<SLAMNAV::NodeT> _o = std::unique_ptr<SLAMNAV::NodeT>(new NodeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Node::UnPackTo(NodeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); }
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = pose(); if (_e) { _o->pose.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->pose[_i] = _e->Get(_i); } } }
  { auto _e = info(); if (_e) _o->info = _e->str(); }
  { auto _e = links(); if (_e) { _o->links.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->links[_i] = std::unique_ptr<SLAMNAV::LinkT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = type(); if (_e) _o->type = _e->str(); }
}

inline flatbuffers::Offset<Node> Node::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NodeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNode(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Node> CreateNode(flatbuffers::FlatBufferBuilder &_fbb, const NodeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NodeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id.empty() ? 0 : _fbb.CreateString(_o->id);
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _pose = _o->pose.size() ? _fbb.CreateVector(_o->pose) : 0;
  auto _info = _o->info.empty() ? 0 : _fbb.CreateString(_o->info);
  auto _links = _o->links.size() ? _fbb.CreateVector<flatbuffers::Offset<SLAMNAV::Link>> (_o->links.size(), [](size_t i, _VectorArgs *__va) { return CreateLink(*__va->__fbb, __va->__o->links[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _type = _o->type.empty() ? 0 : _fbb.CreateString(_o->type);
  return SLAMNAV::CreateNode(
      _fbb,
      _id,
      _name,
      _pose,
      _info,
      _links,
      _type);
}

inline Request_Get_Map_CloudT *Request_Get_Map_Cloud::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<SLAMNAV::Request_Get_Map_CloudT> _o = std::unique_ptr<SLAMNAV::Request_Get_Map_CloudT>(new Request_Get_Map_CloudT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Request_Get_Map_Cloud::UnPackTo(Request_Get_Map_CloudT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); }
  { auto _e = map_name(); if (_e) _o->map_name = _e->str(); }
  { auto _e = file_name(); if (_e) _o->file_name = _e->str(); }
}

inline flatbuffers::Offset<Request_Get_Map_Cloud> Request_Get_Map_Cloud::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_Get_Map_CloudT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_Get_Map_Cloud(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Request_Get_Map_Cloud> CreateRequest_Get_Map_Cloud(flatbuffers::FlatBufferBuilder &_fbb, const Request_Get_Map_CloudT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Request_Get_Map_CloudT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id.empty() ? 0 : _fbb.CreateString(_o->id);
  auto _map_name = _o->map_name.empty() ? 0 : _fbb.CreateString(_o->map_name);
  auto _file_name = _o->file_name.empty() ? 0 : _fbb.CreateString(_o->file_name);
  return SLAMNAV::CreateRequest_Get_Map_Cloud(
      _fbb,
      _id,
      _map_name,
      _file_name);
}

inline Response_Get_Map_CloudT *Response_Get_Map_Cloud::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<SLAMNAV::Response_Get_Map_CloudT> _o = std::unique_ptr<SLAMNAV::Response_Get_Map_CloudT>(new Response_Get_Map_CloudT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Response_Get_Map_Cloud::UnPackTo(Response_Get_Map_CloudT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); }
  { auto _e = map_name(); if (_e) _o->map_name = _e->str(); }
  { auto _e = file_name(); if (_e) _o->file_name = _e->str(); }
  { auto _e = size(); _o->size = _e; }
  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->data[_i] = *_e->Get(_i); } } }
  { auto _e = result(); if (_e) _o->result = _e->str(); }
  { auto _e = message(); if (_e) _o->message = _e->str(); }
}

inline flatbuffers::Offset<Response_Get_Map_Cloud> Response_Get_Map_Cloud::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Response_Get_Map_CloudT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateResponse_Get_Map_Cloud(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Response_Get_Map_Cloud> CreateResponse_Get_Map_Cloud(flatbuffers::FlatBufferBuilder &_fbb, const Response_Get_Map_CloudT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Response_Get_Map_CloudT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id.empty() ? 0 : _fbb.CreateString(_o->id);
  auto _map_name = _o->map_name.empty() ? 0 : _fbb.CreateString(_o->map_name);
  auto _file_name = _o->file_name.empty() ? 0 : _fbb.CreateString(_o->file_name);
  auto _size = _o->size;
  auto _data = _o->data.size() ? _fbb.CreateVectorOfStructs(_o->data) : 0;
  auto _result = _o->result.empty() ? 0 : _fbb.CreateString(_o->result);
  auto _message = _o->message.empty() ? 0 : _fbb.CreateString(_o->message);
  return SLAMNAV::CreateResponse_Get_Map_Cloud(
      _fbb,
      _id,
      _map_name,
      _file_name,
      _size,
      _data,
      _result,
      _message);
}

inline Request_Set_Map_CloudT *Request_Set_Map_Cloud::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<SLAMNAV::Request_Set_Map_CloudT> _o = std::unique_ptr<SLAMNAV::Request_Set_Map_CloudT>(new Request_Set_Map_CloudT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Request_Set_Map_Cloud::UnPackTo(Request_Set_Map_CloudT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); }
  { auto _e = map_name(); if (_e) _o->map_name = _e->str(); }
  { auto _e = file_name(); if (_e) _o->file_name = _e->str(); }
  { auto _e = size(); _o->size = _e; }
  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->data[_i] = *_e->Get(_i); } } }
}

inline flatbuffers::Offset<Request_Set_Map_Cloud> Request_Set_Map_Cloud::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_Set_Map_CloudT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_Set_Map_Cloud(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Request_Set_Map_Cloud> CreateRequest_Set_Map_Cloud(flatbuffers::FlatBufferBuilder &_fbb, const Request_Set_Map_CloudT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Request_Set_Map_CloudT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id.empty() ? 0 : _fbb.CreateString(_o->id);
  auto _map_name = _o->map_name.empty() ? 0 : _fbb.CreateString(_o->map_name);
  auto _file_name = _o->file_name.empty() ? 0 : _fbb.CreateString(_o->file_name);
  auto _size = _o->size;
  auto _data = _o->data.size() ? _fbb.CreateVectorOfStructs(_o->data) : 0;
  return SLAMNAV::CreateRequest_Set_Map_Cloud(
      _fbb,
      _id,
      _map_name,
      _file_name,
      _size,
      _data);
}

inline Response_Set_Map_CloudT *Response_Set_Map_Cloud::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<SLAMNAV::Response_Set_Map_CloudT> _o = std::unique_ptr<SLAMNAV::Response_Set_Map_CloudT>(new Response_Set_Map_CloudT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Response_Set_Map_Cloud::UnPackTo(Response_Set_Map_CloudT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); }
  { auto _e = map_name(); if (_e) _o->map_name = _e->str(); }
  { auto _e = file_name(); if (_e) _o->file_name = _e->str(); }
  { auto _e = size(); _o->size = _e; }
  { auto _e = result(); if (_e) _o->result = _e->str(); }
  { auto _e = message(); if (_e) _o->message = _e->str(); }
}

inline flatbuffers::Offset<Response_Set_Map_Cloud> Response_Set_Map_Cloud::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Response_Set_Map_CloudT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateResponse_Set_Map_Cloud(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Response_Set_Map_Cloud> CreateResponse_Set_Map_Cloud(flatbuffers::FlatBufferBuilder &_fbb, const Response_Set_Map_CloudT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Response_Set_Map_CloudT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id.empty() ? 0 : _fbb.CreateString(_o->id);
  auto _map_name = _o->map_name.empty() ? 0 : _fbb.CreateString(_o->map_name);
  auto _file_name = _o->file_name.empty() ? 0 : _fbb.CreateString(_o->file_name);
  auto _size = _o->size;
  auto _result = _o->result.empty() ? 0 : _fbb.CreateString(_o->result);
  auto _message = _o->message.empty() ? 0 : _fbb.CreateString(_o->message);
  return SLAMNAV::CreateResponse_Set_Map_Cloud(
      _fbb,
      _id,
      _map_name,
      _file_name,
      _size,
      _result,
      _message);
}

inline Request_Get_Map_pipeT *Request_Get_Map_pipe::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<SLAMNAV::Request_Get_Map_pipeT> _o = std::unique_ptr<SLAMNAV::Request_Get_Map_pipeT>(new Request_Get_Map_pipeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Request_Get_Map_pipe::UnPackTo(Request_Get_Map_pipeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Request_Get_Map_pipe> Request_Get_Map_pipe::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_Get_Map_pipeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_Get_Map_pipe(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Request_Get_Map_pipe> CreateRequest_Get_Map_pipe(flatbuffers::FlatBufferBuilder &_fbb, const Request_Get_Map_pipeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Request_Get_Map_pipeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return SLAMNAV::CreateRequest_Get_Map_pipe(
      _fbb);
}

inline Response_Get_Map_pipeT *Response_Get_Map_pipe::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<SLAMNAV::Response_Get_Map_pipeT> _o = std::unique_ptr<SLAMNAV::Response_Get_Map_pipeT>(new Response_Get_Map_pipeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Response_Get_Map_pipe::UnPackTo(Response_Get_Map_pipeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Response_Get_Map_pipe> Response_Get_Map_pipe::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Response_Get_Map_pipeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateResponse_Get_Map_pipe(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Response_Get_Map_pipe> CreateResponse_Get_Map_pipe(flatbuffers::FlatBufferBuilder &_fbb, const Response_Get_Map_pipeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Response_Get_Map_pipeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return SLAMNAV::CreateResponse_Get_Map_pipe(
      _fbb);
}

inline Request_Get_Map_TilesT *Request_Get_Map_Tiles::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<SLAMNAV::Request_Get_Map_TilesT> _o = std::unique_ptr<SLAMNAV::Request_Get_Map_TilesT>(new Request_Get_Map_TilesT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Request_Get_Map_Tiles::UnPackTo(Request_Get_Map_TilesT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Request_Get_Map_Tiles> Request_Get_Map_Tiles::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_Get_Map_TilesT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_Get_Map_Tiles(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Request_Get_Map_Tiles> CreateRequest_Get_Map_Tiles(flatbuffers::FlatBufferBuilder &_fbb, const Request_Get_Map_TilesT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Request_Get_Map_TilesT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return SLAMNAV::CreateRequest_Get_Map_Tiles(
      _fbb);
}

inline Response_Get_Map_TilesT *Response_Get_Map_Tiles::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<SLAMNAV::Response_Get_Map_TilesT> _o = std::unique_ptr<SLAMNAV::Response_Get_Map_TilesT>(new Response_Get_Map_TilesT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Response_Get_Map_Tiles::UnPackTo(Response_Get_Map_TilesT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Response_Get_Map_Tiles> Response_Get_Map_Tiles::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Response_Get_Map_TilesT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateResponse_Get_Map_Tiles(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Response_Get_Map_Tiles> CreateResponse_Get_Map_Tiles(flatbuffers::FlatBufferBuilder &_fbb, const Response_Get_Map_TilesT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Response_Get_Map_TilesT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return SLAMNAV::CreateResponse_Get_Map_Tiles(
      _fbb);
}

inline Request_Set_Map_TopologyT *Request_Set_Map_Topology::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<SLAMNAV::Request_Set_Map_TopologyT> _o = std::unique_ptr<SLAMNAV::Request_Set_Map_TopologyT>(new Request_Set_Map_TopologyT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Request_Set_Map_Topology::UnPackTo(Request_Set_Map_TopologyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); }
  { auto _e = map_name(); if (_e) _o->map_name = _e->str(); }
  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->data[_i] = std::unique_ptr<SLAMNAV::NodeT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<Request_Set_Map_Topology> Request_Set_Map_Topology::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_Set_Map_TopologyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_Set_Map_Topology(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Request_Set_Map_Topology> CreateRequest_Set_Map_Topology(flatbuffers::FlatBufferBuilder &_fbb, const Request_Set_Map_TopologyT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Request_Set_Map_TopologyT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id.empty() ? 0 : _fbb.CreateString(_o->id);
  auto _map_name = _o->map_name.empty() ? 0 : _fbb.CreateString(_o->map_name);
  auto _data = _o->data.size() ? _fbb.CreateVector<flatbuffers::Offset<SLAMNAV::Node>> (_o->data.size(), [](size_t i, _VectorArgs *__va) { return CreateNode(*__va->__fbb, __va->__o->data[i].get(), __va->__rehasher); }, &_va ) : 0;
  return SLAMNAV::CreateRequest_Set_Map_Topology(
      _fbb,
      _id,
      _map_name,
      _data);
}

inline Response_Set_Map_TopologyT *Response_Set_Map_Topology::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<SLAMNAV::Response_Set_Map_TopologyT> _o = std::unique_ptr<SLAMNAV::Response_Set_Map_TopologyT>(new Response_Set_Map_TopologyT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Response_Set_Map_Topology::UnPackTo(Response_Set_Map_TopologyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); }
  { auto _e = map_name(); if (_e) _o->map_name = _e->str(); }
  { auto _e = result(); if (_e) _o->result = _e->str(); }
  { auto _e = message(); if (_e) _o->message = _e->str(); }
}

inline flatbuffers::Offset<Response_Set_Map_Topology> Response_Set_Map_Topology::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Response_Set_Map_TopologyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateResponse_Set_Map_Topology(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Response_Set_Map_Topology> CreateResponse_Set_Map_Topology(flatbuffers::FlatBufferBuilder &_fbb, const Response_Set_Map_TopologyT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Response_Set_Map_TopologyT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id.empty() ? 0 : _fbb.CreateString(_o->id);
  auto _map_name = _o->map_name.empty() ? 0 : _fbb.CreateString(_o->map_name);
  auto _result = _o->result.empty() ? 0 : _fbb.CreateString(_o->result);
  auto _message = _o->message.empty() ? 0 : _fbb.CreateString(_o->message);
  return SLAMNAV::CreateResponse_Set_Map_Topology(
      _fbb,
      _id,
      _map_name,
      _result,
      _message);
}

inline Request_Get_Map_TopologyT *Request_Get_Map_Topology::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<SLAMNAV::Request_Get_Map_TopologyT> _o = std::unique_ptr<SLAMNAV::Request_Get_Map_TopologyT>(new Request_Get_Map_TopologyT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Request_Get_Map_Topology::UnPackTo(Request_Get_Map_TopologyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); }
  { auto _e = map_name(); if (_e) _o->map_name = _e->str(); }
}

inline flatbuffers::Offset<Request_Get_Map_Topology> Request_Get_Map_Topology::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_Get_Map_TopologyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_Get_Map_Topology(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Request_Get_Map_Topology> CreateRequest_Get_Map_Topology(flatbuffers::FlatBufferBuilder &_fbb, const Request_Get_Map_TopologyT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Request_Get_Map_TopologyT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id.empty() ? 0 : _fbb.CreateString(_o->id);
  auto _map_name = _o->map_name.empty() ? 0 : _fbb.CreateString(_o->map_name);
  return SLAMNAV::CreateRequest_Get_Map_Topology(
      _fbb,
      _id,
      _map_name);
}

inline Response_Get_Map_TopologyT *Response_Get_Map_Topology::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<SLAMNAV::Response_Get_Map_TopologyT> _o = std::unique_ptr<SLAMNAV::Response_Get_Map_TopologyT>(new Response_Get_Map_TopologyT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Response_Get_Map_Topology::UnPackTo(Response_Get_Map_TopologyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); }
  { auto _e = map_name(); if (_e) _o->map_name = _e->str(); }
  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->data[_i] = std::unique_ptr<SLAMNAV::NodeT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = result(); if (_e) _o->result = _e->str(); }
  { auto _e = message(); if (_e) _o->message = _e->str(); }
}

inline flatbuffers::Offset<Response_Get_Map_Topology> Response_Get_Map_Topology::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Response_Get_Map_TopologyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateResponse_Get_Map_Topology(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Response_Get_Map_Topology> CreateResponse_Get_Map_Topology(flatbuffers::FlatBufferBuilder &_fbb, const Response_Get_Map_TopologyT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Response_Get_Map_TopologyT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id.empty() ? 0 : _fbb.CreateString(_o->id);
  auto _map_name = _o->map_name.empty() ? 0 : _fbb.CreateString(_o->map_name);
  auto _data = _o->data.size() ? _fbb.CreateVector<flatbuffers::Offset<SLAMNAV::Node>> (_o->data.size(), [](size_t i, _VectorArgs *__va) { return CreateNode(*__va->__fbb, __va->__o->data[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _result = _o->result.empty() ? 0 : _fbb.CreateString(_o->result);
  auto _message = _o->message.empty() ? 0 : _fbb.CreateString(_o->message);
  return SLAMNAV::CreateResponse_Get_Map_Topology(
      _fbb,
      _id,
      _map_name,
      _data,
      _result,
      _message);
}

inline Request_Mapping_StartT *Request_Mapping_Start::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<SLAMNAV::Request_Mapping_StartT> _o = std::unique_ptr<SLAMNAV::Request_Mapping_StartT>(new Request_Mapping_StartT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Request_Mapping_Start::UnPackTo(Request_Mapping_StartT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); }
}

inline flatbuffers::Offset<Request_Mapping_Start> Request_Mapping_Start::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_Mapping_StartT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_Mapping_Start(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Request_Mapping_Start> CreateRequest_Mapping_Start(flatbuffers::FlatBufferBuilder &_fbb, const Request_Mapping_StartT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Request_Mapping_StartT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id.empty() ? 0 : _fbb.CreateString(_o->id);
  return SLAMNAV::CreateRequest_Mapping_Start(
      _fbb,
      _id);
}

inline Response_Mapping_StartT *Response_Mapping_Start::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<SLAMNAV::Response_Mapping_StartT> _o = std::unique_ptr<SLAMNAV::Response_Mapping_StartT>(new Response_Mapping_StartT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Response_Mapping_Start::UnPackTo(Response_Mapping_StartT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); }
  { auto _e = result(); if (_e) _o->result = _e->str(); }
  { auto _e = message(); if (_e) _o->message = _e->str(); }
}

inline flatbuffers::Offset<Response_Mapping_Start> Response_Mapping_Start::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Response_Mapping_StartT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateResponse_Mapping_Start(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Response_Mapping_Start> CreateResponse_Mapping_Start(flatbuffers::FlatBufferBuilder &_fbb, const Response_Mapping_StartT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Response_Mapping_StartT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id.empty() ? 0 : _fbb.CreateString(_o->id);
  auto _result = _o->result.empty() ? 0 : _fbb.CreateString(_o->result);
  auto _message = _o->message.empty() ? 0 : _fbb.CreateString(_o->message);
  return SLAMNAV::CreateResponse_Mapping_Start(
      _fbb,
      _id,
      _result,
      _message);
}

inline Request_Mapping_StopT *Request_Mapping_Stop::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<SLAMNAV::Request_Mapping_StopT> _o = std::unique_ptr<SLAMNAV::Request_Mapping_StopT>(new Request_Mapping_StopT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Request_Mapping_Stop::UnPackTo(Request_Mapping_StopT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); }
}

inline flatbuffers::Offset<Request_Mapping_Stop> Request_Mapping_Stop::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_Mapping_StopT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_Mapping_Stop(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Request_Mapping_Stop> CreateRequest_Mapping_Stop(flatbuffers::FlatBufferBuilder &_fbb, const Request_Mapping_StopT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Request_Mapping_StopT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id.empty() ? 0 : _fbb.CreateString(_o->id);
  return SLAMNAV::CreateRequest_Mapping_Stop(
      _fbb,
      _id);
}

inline Response_Mapping_StopT *Response_Mapping_Stop::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<SLAMNAV::Response_Mapping_StopT> _o = std::unique_ptr<SLAMNAV::Response_Mapping_StopT>(new Response_Mapping_StopT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Response_Mapping_Stop::UnPackTo(Response_Mapping_StopT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); }
  { auto _e = result(); if (_e) _o->result = _e->str(); }
  { auto _e = message(); if (_e) _o->message = _e->str(); }
}

inline flatbuffers::Offset<Response_Mapping_Stop> Response_Mapping_Stop::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Response_Mapping_StopT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateResponse_Mapping_Stop(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Response_Mapping_Stop> CreateResponse_Mapping_Stop(flatbuffers::FlatBufferBuilder &_fbb, const Response_Mapping_StopT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Response_Mapping_StopT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id.empty() ? 0 : _fbb.CreateString(_o->id);
  auto _result = _o->result.empty() ? 0 : _fbb.CreateString(_o->result);
  auto _message = _o->message.empty() ? 0 : _fbb.CreateString(_o->message);
  return SLAMNAV::CreateResponse_Mapping_Stop(
      _fbb,
      _id,
      _result,
      _message);
}

inline Request_Mapping_SaveT *Request_Mapping_Save::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<SLAMNAV::Request_Mapping_SaveT> _o = std::unique_ptr<SLAMNAV::Request_Mapping_SaveT>(new Request_Mapping_SaveT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Request_Mapping_Save::UnPackTo(Request_Mapping_SaveT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); }
  { auto _e = map_name(); if (_e) _o->map_name = _e->str(); }
}

inline flatbuffers::Offset<Request_Mapping_Save> Request_Mapping_Save::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_Mapping_SaveT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_Mapping_Save(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Request_Mapping_Save> CreateRequest_Mapping_Save(flatbuffers::FlatBufferBuilder &_fbb, const Request_Mapping_SaveT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Request_Mapping_SaveT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id.empty() ? 0 : _fbb.CreateString(_o->id);
  auto _map_name = _o->map_name.empty() ? 0 : _fbb.CreateString(_o->map_name);
  return SLAMNAV::CreateRequest_Mapping_Save(
      _fbb,
      _id,
      _map_name);
}

inline Response_Mapping_SaveT *Response_Mapping_Save::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<SLAMNAV::Response_Mapping_SaveT> _o = std::unique_ptr<SLAMNAV::Response_Mapping_SaveT>(new Response_Mapping_SaveT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Response_Mapping_Save::UnPackTo(Response_Mapping_SaveT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); }
  { auto _e = map_name(); if (_e) _o->map_name = _e->str(); }
  { auto _e = result(); if (_e) _o->result = _e->str(); }
  { auto _e = message(); if (_e) _o->message = _e->str(); }
}

inline flatbuffers::Offset<Response_Mapping_Save> Response_Mapping_Save::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Response_Mapping_SaveT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateResponse_Mapping_Save(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Response_Mapping_Save> CreateResponse_Mapping_Save(flatbuffers::FlatBufferBuilder &_fbb, const Response_Mapping_SaveT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Response_Mapping_SaveT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id.empty() ? 0 : _fbb.CreateString(_o->id);
  auto _map_name = _o->map_name.empty() ? 0 : _fbb.CreateString(_o->map_name);
  auto _result = _o->result.empty() ? 0 : _fbb.CreateString(_o->result);
  auto _message = _o->message.empty() ? 0 : _fbb.CreateString(_o->message);
  return SLAMNAV::CreateResponse_Mapping_Save(
      _fbb,
      _id,
      _map_name,
      _result,
      _message);
}

inline Request_Mapping_Cloud_ReloadT *Request_Mapping_Cloud_Reload::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<SLAMNAV::Request_Mapping_Cloud_ReloadT> _o = std::unique_ptr<SLAMNAV::Request_Mapping_Cloud_ReloadT>(new Request_Mapping_Cloud_ReloadT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Request_Mapping_Cloud_Reload::UnPackTo(Request_Mapping_Cloud_ReloadT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Request_Mapping_Cloud_Reload> Request_Mapping_Cloud_Reload::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_Mapping_Cloud_ReloadT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_Mapping_Cloud_Reload(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Request_Mapping_Cloud_Reload> CreateRequest_Mapping_Cloud_Reload(flatbuffers::FlatBufferBuilder &_fbb, const Request_Mapping_Cloud_ReloadT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Request_Mapping_Cloud_ReloadT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return SLAMNAV::CreateRequest_Mapping_Cloud_Reload(
      _fbb);
}

inline Response_Mapping_Cloud_ReloadT *Response_Mapping_Cloud_Reload::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<SLAMNAV::Response_Mapping_Cloud_ReloadT> _o = std::unique_ptr<SLAMNAV::Response_Mapping_Cloud_ReloadT>(new Response_Mapping_Cloud_ReloadT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Response_Mapping_Cloud_Reload::UnPackTo(Response_Mapping_Cloud_ReloadT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Response_Mapping_Cloud_Reload> Response_Mapping_Cloud_Reload::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Response_Mapping_Cloud_ReloadT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateResponse_Mapping_Cloud_Reload(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Response_Mapping_Cloud_Reload> CreateResponse_Mapping_Cloud_Reload(flatbuffers::FlatBufferBuilder &_fbb, const Response_Mapping_Cloud_ReloadT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Response_Mapping_Cloud_ReloadT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return SLAMNAV::CreateResponse_Mapping_Cloud_Reload(
      _fbb);
}

inline Map_ResultT *Map_Result::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<SLAMNAV::Map_ResultT> _o = std::unique_ptr<SLAMNAV::Map_ResultT>(new Map_ResultT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Map_Result::UnPackTo(Map_ResultT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); }
  { auto _e = result(); if (_e) _o->result = _e->str(); }
  { auto _e = message(); if (_e) _o->message = _e->str(); }
}

inline flatbuffers::Offset<Map_Result> Map_Result::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Map_ResultT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMap_Result(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Map_Result> CreateMap_Result(flatbuffers::FlatBufferBuilder &_fbb, const Map_ResultT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Map_ResultT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id.empty() ? 0 : _fbb.CreateString(_o->id);
  auto _result = _o->result.empty() ? 0 : _fbb.CreateString(_o->result);
  auto _message = _o->message.empty() ? 0 : _fbb.CreateString(_o->message);
  return SLAMNAV::CreateMap_Result(
      _fbb,
      _id,
      _result,
      _message);
}

}  // namespace SLAMNAV

#endif  // FLATBUFFERS_GENERATED_SLAMNAVMAP_SLAMNAV_H_
